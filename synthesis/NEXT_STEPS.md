# CoreMiniAxi 进一步优化计划

## 当前状态

### 第一轮优化结果
- **配置**: RTL 参数优化 + 启用 Float
- **结果**: 330,041 instances
- **减少**: 110,303 instances (25.0%)
- **距离目标**: +230,041 instances

### 第二轮优化 (进行中)
- **配置**: RTL 参数优化 + **禁用 Float**
- **Verilog 大小**: 616KB (vs 1.2MB)
- **预期**: ~250,000 instances
- **状态**: 🔄 综合进行中

## 优化策略分析

### 已实施的优化

#### RTL 级优化 ✅
1. instructionLanes: 4 → 2
2. rvvVlen: 128 → 64
3. fetchDataBits: 256 → 128
4. ITCM: 8KB → 4KB
5. DTCM: 32KB → 8KB

#### 功能裁剪 ✅
1. enableFloat: True → **False** (第二轮)
2. enableRvv: False (已禁用)
3. enableDebug: False (已禁用)
4. enableVerification: False (已禁用)

### 待实施的优化

#### 优先级 1: 进一步减少数据宽度

**修改 Parameters.scala**:
```scala
var lsuDataBits = 64  // 从 128 减少到 64
```

**预期效果**:
- 减少 LSU 数据路径宽度
- 减少相关的 MUX 和逻辑
- 预期减少: ~30,000 instances (9%)

**风险**:
- ⚠️ 性能下降 20-30%
- ⚠️ 内存访问效率降低

#### 优先级 2: 减少缓存大小

**修改 Parameters.scala**:
```scala
val l1islots = 128        // 从 256 减少到 128
val l1dslots = 128        // 从 256 减少到 128
val fetchCacheBytes = 512 // 从 1024 减少到 512
```

**预期效果**:
- 减少缓存存储单元
- 预期减少: ~20,000 instances (6%)

**风险**:
- ⚠️ 缓存命中率下降
- ⚠️ 性能下降 10-15%

#### 优先级 3: 禁用 FetchL0 缓存

**修改 Parameters.scala**:
```scala
var enableFetchL0 = false  // 从 true 改为 false
```

**预期效果**:
- 移除 L0 取指缓存
- 预期减少: ~10,000 instances (3%)

**风险**:
- ⚠️ 取指效率降低
- ⚠️ 性能下降 5-10%

#### 优先级 4: 减少指令通道

**修改 Parameters.scala**:
```scala
val instructionLanes = 1  // 从 2 减少到 1
```

**预期效果**:
- 减少并行指令处理能力
- 预期减少: ~15,000 instances (5%)

**风险**:
- ⚠️ 指令吞吐量减半
- ⚠️ 性能下降 30-40%

#### 优先级 5: 激进综合优化

**策略**:
1. 多次迭代 opt 命令
2. 使用更激进的 ABC 脚本
3. 调整 MUX 优化参数
4. 使用 flatten 后再次优化

**预期效果**:
- 预期减少: ~10,000 instances (3%)

**风险**:
- 综合时间显著增加
- 可能导致时序违例

## 达到目标的路径

### 保守路径 (保留基本性能)

| 步骤 | 优化措施 | 预期 Instances | 累计减少 |
|------|----------|----------------|----------|
| 当前 | 第一轮 | 330,041 | 25% |
| 步骤 1 | 禁用 Float | ~250,000 | 43% |
| 步骤 2 | 减少缓存 | ~230,000 | 48% |
| 步骤 3 | 禁用 FetchL0 | ~220,000 | 50% |
| 步骤 4 | 激进综合 | ~210,000 | 52% |

**结论**: 保守路径**无法达到** 100,000 目标

### 激进路径 (牺牲性能)

| 步骤 | 优化措施 | 预期 Instances | 累计减少 |
|------|----------|----------------|----------|
| 当前 | 第一轮 | 330,041 | 25% |
| 步骤 1 | 禁用 Float | ~250,000 | 43% |
| 步骤 2 | LSU 64-bit | ~220,000 | 50% |
| 步骤 3 | 减少缓存 | ~200,000 | 55% |
| 步骤 4 | 禁用 FetchL0 | ~190,000 | 57% |
| 步骤 5 | 指令通道=1 | ~175,000 | 60% |
| 步骤 6 | Fetch 64-bit | ~160,000 | 64% |
| 步骤 7 | 激进综合 | ~150,000 | 66% |

**结论**: 激进路径**仍然无法达到** 100,000 目标

### 极限路径 (最小可用配置)

| 步骤 | 优化措施 | 预期 Instances | 累计减少 |
|------|----------|----------------|----------|
| 当前 | 第一轮 | 330,041 | 25% |
| 步骤 1 | 禁用 Float | ~250,000 | 43% |
| 步骤 2 | LSU 64-bit | ~220,000 | 50% |
| 步骤 3 | Fetch 64-bit | ~200,000 | 55% |
| 步骤 4 | 指令通道=1 | ~185,000 | 58% |
| 步骤 5 | 减少缓存 50% | ~165,000 | 63% |
| 步骤 6 | 禁用 FetchL0 | ~155,000 | 65% |
| 步骤 7 | ITCM 2KB | ~150,000 | 66% |
| 步骤 8 | DTCM 4KB | ~145,000 | 67% |
| 步骤 9 | 激进综合 | ~135,000 | 69% |
| 步骤 10 | 移除调试逻辑 | ~130,000 | 70% |
| 步骤 11 | 简化 CSR | ~120,000 | 73% |
| 步骤 12 | 简化 LSU | ~110,000 | 75% |
| 步骤 13 | 架构重新设计 | **~100,000** | **77%** |

**结论**: 需要**架构级重新设计**才能达到 100,000 目标

## 现实评估

### 可行性分析

1. **技术可行性**: ✅ 可行
   - 通过极限优化可以接近目标
   - 需要架构级修改

2. **功能可行性**: ⚠️ 有限
   - 会严重影响性能和功能
   - 可能不满足实际应用需求

3. **时间可行性**: ⚠️ 需要时间
   - 每轮优化需要重新生成和综合
   - 需要充分测试和验证

### 建议

#### 短期目标 (1-2 天)
- ✅ 完成禁用 Float 的综合
- 实施优先级 1-3 的优化
- 目标: 降低到 ~200,000 instances

#### 中期目标 (1 周)
- 实施优先级 4-5 的优化
- 评估性能影响
- 目标: 降低到 ~150,000 instances

#### 长期目标 (2-4 周)
- 架构级优化和重新设计
- 简化不必要的功能
- 目标: 接近 100,000 instances

## 下一步行动

### 立即执行
1. ⏳ 等待第二轮综合完成
2. 分析禁用 Float 的效果
3. 决定是否继续激进优化

### 准备工作
1. 创建优化分支
2. 准备性能测试基准
3. 文档化每次优化的影响

### 决策点
- 如果第二轮 < 200,000: 继续优先级 1-2
- 如果第二轮 > 200,000: 重新评估策略
- 如果无法达到 100,000: 调整目标或重新设计

---

**更新时间**: 2024-11-23 19:00
**状态**: 第二轮综合进行中
**预计完成**: 10-15 分钟
