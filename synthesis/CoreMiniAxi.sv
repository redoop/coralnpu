// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Include register initializers in init blocks unless synthesis is set
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Standard header to adapt well known macros for register randomization.

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_
module CoreCSR(
  input          clock,
                 reset,
  input  [31:0]  io_fabric_readDataAddr_bits,
  output         io_fabric_readData_valid,
  output [127:0] io_fabric_readData_bits,
  input          io_fabric_writeDataAddr_valid,
  input  [31:0]  io_fabric_writeDataAddr_bits,
  input  [127:0] io_fabric_writeDataBits,
  output         io_fabric_writeResp,
                 io_reset,
                 io_cg,
  output [31:0]  io_pcStart,
  input          io_halted,
                 io_fault,
  input  [31:0]  io_coralnpu_csr_value_0,
                 io_coralnpu_csr_value_1,
                 io_coralnpu_csr_value_2,
                 io_coralnpu_csr_value_3,
                 io_coralnpu_csr_value_4,
                 io_coralnpu_csr_value_5,
                 io_coralnpu_csr_value_6,
                 io_coralnpu_csr_value_7,
                 io_coralnpu_csr_value_8
);

  reg  [31:0]  resetReg;
  reg  [31:0]  pcStartReg;
  reg  [31:0]  statusReg;
  wire         readDataValid =
    io_fabric_readDataAddr_bits == 32'h0 | io_fabric_readDataAddr_bits == 32'h4
    | io_fabric_readDataAddr_bits == 32'h118 | io_fabric_readDataAddr_bits == 32'h100
    | io_fabric_readDataAddr_bits == 32'h114 | io_fabric_readDataAddr_bits == 32'h10C
    | io_fabric_readDataAddr_bits == 32'h120 | io_fabric_readDataAddr_bits == 32'h104
    | io_fabric_readDataAddr_bits == 32'h110 | io_fabric_readDataAddr_bits == 32'h8
    | io_fabric_readDataAddr_bits == 32'h108 | io_fabric_readDataAddr_bits == 32'h11C;
  reg          readDataNext_pipe_v;
  reg  [127:0] readDataNext_pipe_b;
  wire         _io_fabric_writeResp_T_1 = io_fabric_writeDataAddr_bits == 32'h0;
  wire         _io_fabric_writeResp_T_2 = io_fabric_writeDataAddr_bits == 32'h4;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      resetReg <= 32'h3;
      pcStartReg <= 32'h0;
      statusReg <= 32'h0;
      readDataNext_pipe_v <= 1'h0;
    end
    else begin
      if (io_fabric_writeDataAddr_valid & _io_fabric_writeResp_T_1)
        resetReg <= io_fabric_writeDataBits[31:0];
      if (io_fabric_writeDataAddr_valid & _io_fabric_writeResp_T_2)
        pcStartReg <= io_fabric_writeDataBits[63:32];
      statusReg <= {30'h0, io_fault, io_halted};
      readDataNext_pipe_v <= readDataValid;
    end
  end // always @(posedge, posedge)
  wire         _GEN = io_fabric_readDataAddr_bits[31:4] == 28'h0;
  wire         _GEN_0 = io_fabric_readDataAddr_bits[31:4] == 28'h10;
  wire         _GEN_1 = io_fabric_readDataAddr_bits[31:4] == 28'h11;
  always @(posedge clock) begin
    if (readDataValid)
      readDataNext_pipe_b <=
        {_GEN_1 ? io_coralnpu_csr_value_7 : _GEN_0 ? io_coralnpu_csr_value_3 : 32'h0,
         _GEN_1
           ? io_coralnpu_csr_value_6
           : _GEN_0 ? io_coralnpu_csr_value_2 : _GEN ? statusReg : 32'h0,
         _GEN_1
           ? io_coralnpu_csr_value_5
           : _GEN_0 ? io_coralnpu_csr_value_1 : _GEN ? pcStartReg : 32'h0,
         _GEN_1
           ? io_coralnpu_csr_value_4
           : _GEN_0
               ? io_coralnpu_csr_value_0
               : io_fabric_readDataAddr_bits[31:4] == 28'h12
                   ? io_coralnpu_csr_value_8
                   : _GEN ? resetReg : 32'h0};
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:7];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [3:0] i = 4'h0; i < 4'h8; i += 4'h1) begin
          _RANDOM[i[2:0]] = `RANDOM;
        end
        resetReg = _RANDOM[3'h0];
        pcStartReg = _RANDOM[3'h1];
        statusReg = _RANDOM[3'h2];
        readDataNext_pipe_v = _RANDOM[3'h3][0];
        readDataNext_pipe_b =
          {_RANDOM[3'h3][31:1],
           _RANDOM[3'h4],
           _RANDOM[3'h5],
           _RANDOM[3'h6],
           _RANDOM[3'h7][0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        resetReg = 32'h3;
        pcStartReg = 32'h0;
        statusReg = 32'h0;
        readDataNext_pipe_v = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_fabric_readData_valid = readDataNext_pipe_v;
  assign io_fabric_readData_bits = readDataNext_pipe_b;
  assign io_fabric_writeResp =
    io_fabric_writeDataAddr_valid & (_io_fabric_writeResp_T_2 | _io_fabric_writeResp_T_1);
  assign io_reset = resetReg[0];
  assign io_cg = resetReg[1];
  assign io_pcStart = pcStartReg;
endmodule

module Regfile(
  input         clock,
                reset,
                io_readAddr_0_valid,
  input  [4:0]  io_readAddr_0_addr,
  input         io_readAddr_1_valid,
  input  [4:0]  io_readAddr_1_addr,
  input         io_readAddr_2_valid,
  input  [4:0]  io_readAddr_2_addr,
  input         io_readAddr_3_valid,
  input  [4:0]  io_readAddr_3_addr,
  input         io_readSet_0_valid,
  input  [31:0] io_readSet_0_value,
  input         io_readSet_1_valid,
  input  [31:0] io_readSet_1_value,
  input         io_readSet_2_valid,
  input  [31:0] io_readSet_2_value,
  input         io_readSet_3_valid,
  input  [31:0] io_readSet_3_value,
  input         io_writeAddr_0_valid,
  input  [4:0]  io_writeAddr_0_addr,
  input         io_writeAddr_1_valid,
  input  [4:0]  io_writeAddr_1_addr,
  input         io_busAddr_0_bypass,
                io_busAddr_0_immen,
  input  [31:0] io_busAddr_0_immed,
  input         io_busAddr_1_bypass,
  input  [31:0] io_busAddr_1_immed,
  output [31:0] io_target_0_data,
                io_target_1_data,
                io_busPort_addr_0,
                io_busPort_addr_1,
                io_busPort_data_0,
                io_busPort_data_1,
  output        io_readData_0_valid,
  output [31:0] io_readData_0_data,
  output        io_readData_1_valid,
  output [31:0] io_readData_1_data,
  output        io_readData_2_valid,
  output [31:0] io_readData_2_data,
  output        io_readData_3_valid,
  output [31:0] io_readData_3_data,
  input         io_writeData_0_valid,
  input  [4:0]  io_writeData_0_bits_addr,
  input  [31:0] io_writeData_0_bits_data,
  input         io_writeData_1_valid,
  input  [4:0]  io_writeData_1_bits_addr,
  input  [31:0] io_writeData_1_bits_data,
  input         io_writeData_2_valid,
  input  [4:0]  io_writeData_2_bits_addr,
  input  [31:0] io_writeData_2_bits_data,
  input         io_writeData_3_valid,
  input  [4:0]  io_writeData_3_bits_addr,
  input  [31:0] io_writeData_3_bits_data,
  input         io_writeMask_1_valid,
                io_writeMask_3_valid,
  output [31:0] io_scoreboard_regd,
                io_scoreboard_comb,
  output [5:0]  io_rfwriteCount
);

  reg  [31:0] regfile_1;
  reg  [31:0] regfile_2;
  reg  [31:0] regfile_3;
  reg  [31:0] regfile_4;
  reg  [31:0] regfile_5;
  reg  [31:0] regfile_6;
  reg  [31:0] regfile_7;
  reg  [31:0] regfile_8;
  reg  [31:0] regfile_9;
  reg  [31:0] regfile_10;
  reg  [31:0] regfile_11;
  reg  [31:0] regfile_12;
  reg  [31:0] regfile_13;
  reg  [31:0] regfile_14;
  reg  [31:0] regfile_15;
  reg  [31:0] regfile_16;
  reg  [31:0] regfile_17;
  reg  [31:0] regfile_18;
  reg  [31:0] regfile_19;
  reg  [31:0] regfile_20;
  reg  [31:0] regfile_21;
  reg  [31:0] regfile_22;
  reg  [31:0] regfile_23;
  reg  [31:0] regfile_24;
  reg  [31:0] regfile_25;
  reg  [31:0] regfile_26;
  reg  [31:0] regfile_27;
  reg  [31:0] regfile_28;
  reg  [31:0] regfile_29;
  reg  [31:0] regfile_30;
  reg  [31:0] regfile_31;
  reg  [31:0] scoreboard;
  wire [31:0] _scoreboard_clr0_T_1 = 32'h1 << io_writeData_0_bits_addr;
  wire [31:0] _scoreboard_clr0_T_4 = 32'h1 << io_writeData_1_bits_addr;
  wire [31:0] _scoreboard_clr0_T_7 = 32'h1 << io_writeData_2_bits_addr;
  wire [31:0] _scoreboard_clr0_T_10 = 32'h1 << io_writeData_3_bits_addr;
  wire [30:0] scoreboard_clr0 =
    (io_writeData_0_valid ? _scoreboard_clr0_T_1[31:1] : 31'h0)
    | (io_writeData_1_valid ? _scoreboard_clr0_T_4[31:1] : 31'h0)
    | (io_writeData_2_valid ? _scoreboard_clr0_T_7[31:1] : 31'h0)
    | (io_writeData_3_valid ? _scoreboard_clr0_T_10[31:1] : 31'h0);
  reg         readDataReady_0;
  reg         readDataReady_1;
  reg         readDataReady_2;
  reg         readDataReady_3;
  reg  [31:0] readDataBits_0;
  reg  [31:0] readDataBits_1;
  reg  [31:0] readDataBits_2;
  reg  [31:0] readDataBits_3;
  wire        _valid_T = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h1;
  wire        valid_1 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h1 & ~io_writeMask_1_valid;
  wire        _valid_T_4 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h1;
  wire        valid_3 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h1 & ~io_writeMask_3_valid;
  wire [31:0] data =
    (_valid_T ? io_writeData_0_bits_data : 32'h0)
    | (valid_1 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_4 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_1_T = {_valid_T, valid_1, _valid_T_4, valid_3};
  wire        _valid_T_8 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h2;
  wire        valid_1_1 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h2 & ~io_writeMask_1_valid;
  wire        _valid_T_12 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h2;
  wire        valid_3_1 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h2 & ~io_writeMask_3_valid;
  wire [31:0] data_1 =
    (_valid_T_8 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_1 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_12 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_1 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_2_T = {_valid_T_8, valid_1_1, _valid_T_12, valid_3_1};
  wire        _valid_T_16 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h3;
  wire        valid_1_2 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h3 & ~io_writeMask_1_valid;
  wire        _valid_T_20 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h3;
  wire        valid_3_2 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h3 & ~io_writeMask_3_valid;
  wire [31:0] data_2 =
    (_valid_T_16 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_2 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_20 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_2 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_3_T = {_valid_T_16, valid_1_2, _valid_T_20, valid_3_2};
  wire        _valid_T_24 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h4;
  wire        valid_1_3 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h4 & ~io_writeMask_1_valid;
  wire        _valid_T_28 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h4;
  wire        valid_3_3 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h4 & ~io_writeMask_3_valid;
  wire [31:0] data_3 =
    (_valid_T_24 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_3 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_28 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_3 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_4_T = {_valid_T_24, valid_1_3, _valid_T_28, valid_3_3};
  wire        _valid_T_32 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h5;
  wire        valid_1_4 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h5 & ~io_writeMask_1_valid;
  wire        _valid_T_36 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h5;
  wire        valid_3_4 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h5 & ~io_writeMask_3_valid;
  wire [31:0] data_4 =
    (_valid_T_32 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_4 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_36 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_4 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_5_T = {_valid_T_32, valid_1_4, _valid_T_36, valid_3_4};
  wire        _valid_T_40 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h6;
  wire        valid_1_5 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h6 & ~io_writeMask_1_valid;
  wire        _valid_T_44 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h6;
  wire        valid_3_5 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h6 & ~io_writeMask_3_valid;
  wire [31:0] data_5 =
    (_valid_T_40 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_5 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_44 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_5 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_6_T = {_valid_T_40, valid_1_5, _valid_T_44, valid_3_5};
  wire        _valid_T_48 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h7;
  wire        valid_1_6 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h7 & ~io_writeMask_1_valid;
  wire        _valid_T_52 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h7;
  wire        valid_3_6 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h7 & ~io_writeMask_3_valid;
  wire [31:0] data_6 =
    (_valid_T_48 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_6 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_52 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_6 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_7_T = {_valid_T_48, valid_1_6, _valid_T_52, valid_3_6};
  wire        _valid_T_56 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h8;
  wire        valid_1_7 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h8 & ~io_writeMask_1_valid;
  wire        _valid_T_60 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h8;
  wire        valid_3_7 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h8 & ~io_writeMask_3_valid;
  wire [31:0] data_7 =
    (_valid_T_56 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_7 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_60 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_7 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_8_T = {_valid_T_56, valid_1_7, _valid_T_60, valid_3_7};
  wire        _valid_T_64 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h9;
  wire        valid_1_8 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h9 & ~io_writeMask_1_valid;
  wire        _valid_T_68 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h9;
  wire        valid_3_8 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h9 & ~io_writeMask_3_valid;
  wire [31:0] data_8 =
    (_valid_T_64 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_8 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_68 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_8 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_9_T = {_valid_T_64, valid_1_8, _valid_T_68, valid_3_8};
  wire        _valid_T_72 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'hA;
  wire        valid_1_9 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'hA & ~io_writeMask_1_valid;
  wire        _valid_T_76 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'hA;
  wire        valid_3_9 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'hA & ~io_writeMask_3_valid;
  wire [31:0] data_9 =
    (_valid_T_72 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_9 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_76 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_9 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_10_T = {_valid_T_72, valid_1_9, _valid_T_76, valid_3_9};
  wire        _valid_T_80 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'hB;
  wire        valid_1_10 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'hB & ~io_writeMask_1_valid;
  wire        _valid_T_84 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'hB;
  wire        valid_3_10 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'hB & ~io_writeMask_3_valid;
  wire [31:0] data_10 =
    (_valid_T_80 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_10 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_84 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_10 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_11_T = {_valid_T_80, valid_1_10, _valid_T_84, valid_3_10};
  wire        _valid_T_88 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'hC;
  wire        valid_1_11 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'hC & ~io_writeMask_1_valid;
  wire        _valid_T_92 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'hC;
  wire        valid_3_11 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'hC & ~io_writeMask_3_valid;
  wire [31:0] data_11 =
    (_valid_T_88 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_11 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_92 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_11 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_12_T = {_valid_T_88, valid_1_11, _valid_T_92, valid_3_11};
  wire        _valid_T_96 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'hD;
  wire        valid_1_12 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'hD & ~io_writeMask_1_valid;
  wire        _valid_T_100 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'hD;
  wire        valid_3_12 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'hD & ~io_writeMask_3_valid;
  wire [31:0] data_12 =
    (_valid_T_96 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_12 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_100 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_12 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_13_T = {_valid_T_96, valid_1_12, _valid_T_100, valid_3_12};
  wire        _valid_T_104 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'hE;
  wire        valid_1_13 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'hE & ~io_writeMask_1_valid;
  wire        _valid_T_108 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'hE;
  wire        valid_3_13 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'hE & ~io_writeMask_3_valid;
  wire [31:0] data_13 =
    (_valid_T_104 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_13 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_108 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_13 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_14_T = {_valid_T_104, valid_1_13, _valid_T_108, valid_3_13};
  wire        _valid_T_112 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'hF;
  wire        valid_1_14 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'hF & ~io_writeMask_1_valid;
  wire        _valid_T_116 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'hF;
  wire        valid_3_14 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'hF & ~io_writeMask_3_valid;
  wire [31:0] data_14 =
    (_valid_T_112 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_14 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_116 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_14 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_15_T = {_valid_T_112, valid_1_14, _valid_T_116, valid_3_14};
  wire        _valid_T_120 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h10;
  wire        valid_1_15 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h10 & ~io_writeMask_1_valid;
  wire        _valid_T_124 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h10;
  wire        valid_3_15 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h10 & ~io_writeMask_3_valid;
  wire [31:0] data_15 =
    (_valid_T_120 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_15 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_124 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_15 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_16_T = {_valid_T_120, valid_1_15, _valid_T_124, valid_3_15};
  wire        _valid_T_128 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h11;
  wire        valid_1_16 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h11 & ~io_writeMask_1_valid;
  wire        _valid_T_132 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h11;
  wire        valid_3_16 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h11 & ~io_writeMask_3_valid;
  wire [31:0] data_16 =
    (_valid_T_128 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_16 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_132 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_16 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_17_T = {_valid_T_128, valid_1_16, _valid_T_132, valid_3_16};
  wire        _valid_T_136 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h12;
  wire        valid_1_17 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h12 & ~io_writeMask_1_valid;
  wire        _valid_T_140 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h12;
  wire        valid_3_17 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h12 & ~io_writeMask_3_valid;
  wire [31:0] data_17 =
    (_valid_T_136 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_17 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_140 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_17 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_18_T = {_valid_T_136, valid_1_17, _valid_T_140, valid_3_17};
  wire        _valid_T_144 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h13;
  wire        valid_1_18 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h13 & ~io_writeMask_1_valid;
  wire        _valid_T_148 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h13;
  wire        valid_3_18 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h13 & ~io_writeMask_3_valid;
  wire [31:0] data_18 =
    (_valid_T_144 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_18 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_148 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_18 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_19_T = {_valid_T_144, valid_1_18, _valid_T_148, valid_3_18};
  wire        _valid_T_152 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h14;
  wire        valid_1_19 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h14 & ~io_writeMask_1_valid;
  wire        _valid_T_156 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h14;
  wire        valid_3_19 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h14 & ~io_writeMask_3_valid;
  wire [31:0] data_19 =
    (_valid_T_152 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_19 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_156 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_19 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_20_T = {_valid_T_152, valid_1_19, _valid_T_156, valid_3_19};
  wire        _valid_T_160 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h15;
  wire        valid_1_20 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h15 & ~io_writeMask_1_valid;
  wire        _valid_T_164 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h15;
  wire        valid_3_20 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h15 & ~io_writeMask_3_valid;
  wire [31:0] data_20 =
    (_valid_T_160 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_20 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_164 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_20 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_21_T = {_valid_T_160, valid_1_20, _valid_T_164, valid_3_20};
  wire        _valid_T_168 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h16;
  wire        valid_1_21 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h16 & ~io_writeMask_1_valid;
  wire        _valid_T_172 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h16;
  wire        valid_3_21 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h16 & ~io_writeMask_3_valid;
  wire [31:0] data_21 =
    (_valid_T_168 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_21 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_172 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_21 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_22_T = {_valid_T_168, valid_1_21, _valid_T_172, valid_3_21};
  wire        _valid_T_176 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h17;
  wire        valid_1_22 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h17 & ~io_writeMask_1_valid;
  wire        _valid_T_180 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h17;
  wire        valid_3_22 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h17 & ~io_writeMask_3_valid;
  wire [31:0] data_22 =
    (_valid_T_176 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_22 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_180 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_22 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_23_T = {_valid_T_176, valid_1_22, _valid_T_180, valid_3_22};
  wire        _valid_T_184 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h18;
  wire        valid_1_23 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h18 & ~io_writeMask_1_valid;
  wire        _valid_T_188 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h18;
  wire        valid_3_23 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h18 & ~io_writeMask_3_valid;
  wire [31:0] data_23 =
    (_valid_T_184 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_23 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_188 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_23 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_24_T = {_valid_T_184, valid_1_23, _valid_T_188, valid_3_23};
  wire        _valid_T_192 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h19;
  wire        valid_1_24 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h19 & ~io_writeMask_1_valid;
  wire        _valid_T_196 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h19;
  wire        valid_3_24 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h19 & ~io_writeMask_3_valid;
  wire [31:0] data_24 =
    (_valid_T_192 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_24 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_196 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_24 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_25_T = {_valid_T_192, valid_1_24, _valid_T_196, valid_3_24};
  wire        _valid_T_200 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h1A;
  wire        valid_1_25 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h1A & ~io_writeMask_1_valid;
  wire        _valid_T_204 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h1A;
  wire        valid_3_25 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h1A & ~io_writeMask_3_valid;
  wire [31:0] data_25 =
    (_valid_T_200 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_25 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_204 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_25 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_26_T = {_valid_T_200, valid_1_25, _valid_T_204, valid_3_25};
  wire        _valid_T_208 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h1B;
  wire        valid_1_26 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h1B & ~io_writeMask_1_valid;
  wire        _valid_T_212 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h1B;
  wire        valid_3_26 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h1B & ~io_writeMask_3_valid;
  wire [31:0] data_26 =
    (_valid_T_208 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_26 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_212 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_26 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_27_T = {_valid_T_208, valid_1_26, _valid_T_212, valid_3_26};
  wire        _valid_T_216 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h1C;
  wire        valid_1_27 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h1C & ~io_writeMask_1_valid;
  wire        _valid_T_220 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h1C;
  wire        valid_3_27 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h1C & ~io_writeMask_3_valid;
  wire [31:0] data_27 =
    (_valid_T_216 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_27 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_220 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_27 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_28_T = {_valid_T_216, valid_1_27, _valid_T_220, valid_3_27};
  wire        _valid_T_224 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h1D;
  wire        valid_1_28 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h1D & ~io_writeMask_1_valid;
  wire        _valid_T_228 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h1D;
  wire        valid_3_28 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h1D & ~io_writeMask_3_valid;
  wire [31:0] data_28 =
    (_valid_T_224 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_28 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_228 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_28 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_29_T = {_valid_T_224, valid_1_28, _valid_T_228, valid_3_28};
  wire        _valid_T_232 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h1E;
  wire        valid_1_29 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h1E & ~io_writeMask_1_valid;
  wire        _valid_T_236 = io_writeData_2_valid & io_writeData_2_bits_addr == 5'h1E;
  wire        valid_3_29 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h1E & ~io_writeMask_3_valid;
  wire [31:0] data_29 =
    (_valid_T_232 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_29 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_236 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_29 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_30_T = {_valid_T_232, valid_1_29, _valid_T_236, valid_3_29};
  wire        _valid_T_240 = io_writeData_0_valid & (&io_writeData_0_bits_addr);
  wire        valid_1_30 =
    io_writeData_1_valid & (&io_writeData_1_bits_addr) & ~io_writeMask_1_valid;
  wire        _valid_T_244 = io_writeData_2_valid & (&io_writeData_2_bits_addr);
  wire        valid_3_30 =
    io_writeData_3_valid & (&io_writeData_3_bits_addr) & ~io_writeMask_3_valid;
  wire [31:0] data_30 =
    (_valid_T_240 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_30 ? io_writeData_1_bits_data : 32'h0)
    | (_valid_T_244 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_30 ? io_writeData_3_bits_data : 32'h0);
  wire [3:0]  _writeValid_31_T = {_valid_T_240, valid_1_30, _valid_T_244, valid_3_30};
  wire        _wdata_0_value_1_T = io_readAddr_0_addr == 5'h1;
  wire        _wdata_0_value_2_T = io_readAddr_0_addr == 5'h2;
  wire        _wdata_0_value_3_T = io_readAddr_0_addr == 5'h3;
  wire        _wdata_0_value_4_T = io_readAddr_0_addr == 5'h4;
  wire        _wdata_0_value_5_T = io_readAddr_0_addr == 5'h5;
  wire        _wdata_0_value_6_T = io_readAddr_0_addr == 5'h6;
  wire        _wdata_0_value_7_T = io_readAddr_0_addr == 5'h7;
  wire        _wdata_0_value_8_T = io_readAddr_0_addr == 5'h8;
  wire        _wdata_0_value_9_T = io_readAddr_0_addr == 5'h9;
  wire        _wdata_0_value_10_T = io_readAddr_0_addr == 5'hA;
  wire        _wdata_0_value_11_T = io_readAddr_0_addr == 5'hB;
  wire        _wdata_0_value_12_T = io_readAddr_0_addr == 5'hC;
  wire        _wdata_0_value_13_T = io_readAddr_0_addr == 5'hD;
  wire        _wdata_0_value_14_T = io_readAddr_0_addr == 5'hE;
  wire        _wdata_0_value_15_T = io_readAddr_0_addr == 5'hF;
  wire        _wdata_0_value_16_T = io_readAddr_0_addr == 5'h10;
  wire        _wdata_0_value_17_T = io_readAddr_0_addr == 5'h11;
  wire        _wdata_0_value_18_T = io_readAddr_0_addr == 5'h12;
  wire        _wdata_0_value_19_T = io_readAddr_0_addr == 5'h13;
  wire        _wdata_0_value_20_T = io_readAddr_0_addr == 5'h14;
  wire        _wdata_0_value_21_T = io_readAddr_0_addr == 5'h15;
  wire        _wdata_0_value_22_T = io_readAddr_0_addr == 5'h16;
  wire        _wdata_0_value_23_T = io_readAddr_0_addr == 5'h17;
  wire        _wdata_0_value_24_T = io_readAddr_0_addr == 5'h18;
  wire        _wdata_0_value_25_T = io_readAddr_0_addr == 5'h19;
  wire        _wdata_0_value_26_T = io_readAddr_0_addr == 5'h1A;
  wire        _wdata_0_value_27_T = io_readAddr_0_addr == 5'h1B;
  wire        _wdata_0_value_28_T = io_readAddr_0_addr == 5'h1C;
  wire        _wdata_0_value_29_T = io_readAddr_0_addr == 5'h1D;
  wire        _wdata_0_value_30_T = io_readAddr_0_addr == 5'h1E;
  wire [31:0] rdata_0_value_5_0 =
    (_wdata_0_value_1_T ? regfile_1 : 32'h0) | (_wdata_0_value_2_T ? regfile_2 : 32'h0)
    | (_wdata_0_value_3_T ? regfile_3 : 32'h0) | (_wdata_0_value_4_T ? regfile_4 : 32'h0)
    | (_wdata_0_value_5_T ? regfile_5 : 32'h0) | (_wdata_0_value_6_T ? regfile_6 : 32'h0)
    | (_wdata_0_value_7_T ? regfile_7 : 32'h0) | (_wdata_0_value_8_T ? regfile_8 : 32'h0)
    | (_wdata_0_value_9_T ? regfile_9 : 32'h0)
    | (_wdata_0_value_10_T ? regfile_10 : 32'h0)
    | (_wdata_0_value_11_T ? regfile_11 : 32'h0)
    | (_wdata_0_value_12_T ? regfile_12 : 32'h0)
    | (_wdata_0_value_13_T ? regfile_13 : 32'h0)
    | (_wdata_0_value_14_T ? regfile_14 : 32'h0)
    | (_wdata_0_value_15_T ? regfile_15 : 32'h0)
    | (_wdata_0_value_16_T ? regfile_16 : 32'h0)
    | (_wdata_0_value_17_T ? regfile_17 : 32'h0)
    | (_wdata_0_value_18_T ? regfile_18 : 32'h0)
    | (_wdata_0_value_19_T ? regfile_19 : 32'h0)
    | (_wdata_0_value_20_T ? regfile_20 : 32'h0)
    | (_wdata_0_value_21_T ? regfile_21 : 32'h0)
    | (_wdata_0_value_22_T ? regfile_22 : 32'h0)
    | (_wdata_0_value_23_T ? regfile_23 : 32'h0)
    | (_wdata_0_value_24_T ? regfile_24 : 32'h0)
    | (_wdata_0_value_25_T ? regfile_25 : 32'h0)
    | (_wdata_0_value_26_T ? regfile_26 : 32'h0)
    | (_wdata_0_value_27_T ? regfile_27 : 32'h0)
    | (_wdata_0_value_28_T ? regfile_28 : 32'h0)
    | (_wdata_0_value_29_T ? regfile_29 : 32'h0)
    | (_wdata_0_value_30_T ? regfile_30 : 32'h0)
    | ((&io_readAddr_0_addr) ? regfile_31 : 32'h0);
  wire [31:0] rwdata_0 =
    io_readAddr_0_addr == 5'h0 | _wdata_0_value_1_T & (|_writeValid_1_T)
    | _wdata_0_value_2_T & (|_writeValid_2_T) | _wdata_0_value_3_T & (|_writeValid_3_T)
    | _wdata_0_value_4_T & (|_writeValid_4_T) | _wdata_0_value_5_T & (|_writeValid_5_T)
    | _wdata_0_value_6_T & (|_writeValid_6_T) | _wdata_0_value_7_T & (|_writeValid_7_T)
    | _wdata_0_value_8_T & (|_writeValid_8_T) | _wdata_0_value_9_T & (|_writeValid_9_T)
    | _wdata_0_value_10_T & (|_writeValid_10_T) | _wdata_0_value_11_T
    & (|_writeValid_11_T) | _wdata_0_value_12_T & (|_writeValid_12_T)
    | _wdata_0_value_13_T & (|_writeValid_13_T) | _wdata_0_value_14_T
    & (|_writeValid_14_T) | _wdata_0_value_15_T & (|_writeValid_15_T)
    | _wdata_0_value_16_T & (|_writeValid_16_T) | _wdata_0_value_17_T
    & (|_writeValid_17_T) | _wdata_0_value_18_T & (|_writeValid_18_T)
    | _wdata_0_value_19_T & (|_writeValid_19_T) | _wdata_0_value_20_T
    & (|_writeValid_20_T) | _wdata_0_value_21_T & (|_writeValid_21_T)
    | _wdata_0_value_22_T & (|_writeValid_22_T) | _wdata_0_value_23_T
    & (|_writeValid_23_T) | _wdata_0_value_24_T & (|_writeValid_24_T)
    | _wdata_0_value_25_T & (|_writeValid_25_T) | _wdata_0_value_26_T
    & (|_writeValid_26_T) | _wdata_0_value_27_T & (|_writeValid_27_T)
    | _wdata_0_value_28_T & (|_writeValid_28_T) | _wdata_0_value_29_T
    & (|_writeValid_29_T) | _wdata_0_value_30_T & (|_writeValid_30_T)
    | (&io_readAddr_0_addr) & (|_writeValid_31_T)
      ? (_wdata_0_value_1_T ? data : 32'h0) | (_wdata_0_value_2_T ? data_1 : 32'h0)
        | (_wdata_0_value_3_T ? data_2 : 32'h0) | (_wdata_0_value_4_T ? data_3 : 32'h0)
        | (_wdata_0_value_5_T ? data_4 : 32'h0) | (_wdata_0_value_6_T ? data_5 : 32'h0)
        | (_wdata_0_value_7_T ? data_6 : 32'h0) | (_wdata_0_value_8_T ? data_7 : 32'h0)
        | (_wdata_0_value_9_T ? data_8 : 32'h0) | (_wdata_0_value_10_T ? data_9 : 32'h0)
        | (_wdata_0_value_11_T ? data_10 : 32'h0)
        | (_wdata_0_value_12_T ? data_11 : 32'h0)
        | (_wdata_0_value_13_T ? data_12 : 32'h0)
        | (_wdata_0_value_14_T ? data_13 : 32'h0)
        | (_wdata_0_value_15_T ? data_14 : 32'h0)
        | (_wdata_0_value_16_T ? data_15 : 32'h0)
        | (_wdata_0_value_17_T ? data_16 : 32'h0)
        | (_wdata_0_value_18_T ? data_17 : 32'h0)
        | (_wdata_0_value_19_T ? data_18 : 32'h0)
        | (_wdata_0_value_20_T ? data_19 : 32'h0)
        | (_wdata_0_value_21_T ? data_20 : 32'h0)
        | (_wdata_0_value_22_T ? data_21 : 32'h0)
        | (_wdata_0_value_23_T ? data_22 : 32'h0)
        | (_wdata_0_value_24_T ? data_23 : 32'h0)
        | (_wdata_0_value_25_T ? data_24 : 32'h0)
        | (_wdata_0_value_26_T ? data_25 : 32'h0)
        | (_wdata_0_value_27_T ? data_26 : 32'h0)
        | (_wdata_0_value_28_T ? data_27 : 32'h0)
        | (_wdata_0_value_29_T ? data_28 : 32'h0)
        | (_wdata_0_value_30_T ? data_29 : 32'h0)
        | ((&io_readAddr_0_addr) ? data_30 : 32'h0)
      : rdata_0_value_5_0;
  wire        _wdata_1_value_1_T = io_readAddr_1_addr == 5'h1;
  wire        _wdata_1_value_2_T = io_readAddr_1_addr == 5'h2;
  wire        _wdata_1_value_3_T = io_readAddr_1_addr == 5'h3;
  wire        _wdata_1_value_4_T = io_readAddr_1_addr == 5'h4;
  wire        _wdata_1_value_5_T = io_readAddr_1_addr == 5'h5;
  wire        _wdata_1_value_6_T = io_readAddr_1_addr == 5'h6;
  wire        _wdata_1_value_7_T = io_readAddr_1_addr == 5'h7;
  wire        _wdata_1_value_8_T = io_readAddr_1_addr == 5'h8;
  wire        _wdata_1_value_9_T = io_readAddr_1_addr == 5'h9;
  wire        _wdata_1_value_10_T = io_readAddr_1_addr == 5'hA;
  wire        _wdata_1_value_11_T = io_readAddr_1_addr == 5'hB;
  wire        _wdata_1_value_12_T = io_readAddr_1_addr == 5'hC;
  wire        _wdata_1_value_13_T = io_readAddr_1_addr == 5'hD;
  wire        _wdata_1_value_14_T = io_readAddr_1_addr == 5'hE;
  wire        _wdata_1_value_15_T = io_readAddr_1_addr == 5'hF;
  wire        _wdata_1_value_16_T = io_readAddr_1_addr == 5'h10;
  wire        _wdata_1_value_17_T = io_readAddr_1_addr == 5'h11;
  wire        _wdata_1_value_18_T = io_readAddr_1_addr == 5'h12;
  wire        _wdata_1_value_19_T = io_readAddr_1_addr == 5'h13;
  wire        _wdata_1_value_20_T = io_readAddr_1_addr == 5'h14;
  wire        _wdata_1_value_21_T = io_readAddr_1_addr == 5'h15;
  wire        _wdata_1_value_22_T = io_readAddr_1_addr == 5'h16;
  wire        _wdata_1_value_23_T = io_readAddr_1_addr == 5'h17;
  wire        _wdata_1_value_24_T = io_readAddr_1_addr == 5'h18;
  wire        _wdata_1_value_25_T = io_readAddr_1_addr == 5'h19;
  wire        _wdata_1_value_26_T = io_readAddr_1_addr == 5'h1A;
  wire        _wdata_1_value_27_T = io_readAddr_1_addr == 5'h1B;
  wire        _wdata_1_value_28_T = io_readAddr_1_addr == 5'h1C;
  wire        _wdata_1_value_29_T = io_readAddr_1_addr == 5'h1D;
  wire        _wdata_1_value_30_T = io_readAddr_1_addr == 5'h1E;
  wire [31:0] rwdata_1 =
    io_readAddr_1_addr == 5'h0 | _wdata_1_value_1_T & (|_writeValid_1_T)
    | _wdata_1_value_2_T & (|_writeValid_2_T) | _wdata_1_value_3_T & (|_writeValid_3_T)
    | _wdata_1_value_4_T & (|_writeValid_4_T) | _wdata_1_value_5_T & (|_writeValid_5_T)
    | _wdata_1_value_6_T & (|_writeValid_6_T) | _wdata_1_value_7_T & (|_writeValid_7_T)
    | _wdata_1_value_8_T & (|_writeValid_8_T) | _wdata_1_value_9_T & (|_writeValid_9_T)
    | _wdata_1_value_10_T & (|_writeValid_10_T) | _wdata_1_value_11_T
    & (|_writeValid_11_T) | _wdata_1_value_12_T & (|_writeValid_12_T)
    | _wdata_1_value_13_T & (|_writeValid_13_T) | _wdata_1_value_14_T
    & (|_writeValid_14_T) | _wdata_1_value_15_T & (|_writeValid_15_T)
    | _wdata_1_value_16_T & (|_writeValid_16_T) | _wdata_1_value_17_T
    & (|_writeValid_17_T) | _wdata_1_value_18_T & (|_writeValid_18_T)
    | _wdata_1_value_19_T & (|_writeValid_19_T) | _wdata_1_value_20_T
    & (|_writeValid_20_T) | _wdata_1_value_21_T & (|_writeValid_21_T)
    | _wdata_1_value_22_T & (|_writeValid_22_T) | _wdata_1_value_23_T
    & (|_writeValid_23_T) | _wdata_1_value_24_T & (|_writeValid_24_T)
    | _wdata_1_value_25_T & (|_writeValid_25_T) | _wdata_1_value_26_T
    & (|_writeValid_26_T) | _wdata_1_value_27_T & (|_writeValid_27_T)
    | _wdata_1_value_28_T & (|_writeValid_28_T) | _wdata_1_value_29_T
    & (|_writeValid_29_T) | _wdata_1_value_30_T & (|_writeValid_30_T)
    | (&io_readAddr_1_addr) & (|_writeValid_31_T)
      ? (_wdata_1_value_1_T ? data : 32'h0) | (_wdata_1_value_2_T ? data_1 : 32'h0)
        | (_wdata_1_value_3_T ? data_2 : 32'h0) | (_wdata_1_value_4_T ? data_3 : 32'h0)
        | (_wdata_1_value_5_T ? data_4 : 32'h0) | (_wdata_1_value_6_T ? data_5 : 32'h0)
        | (_wdata_1_value_7_T ? data_6 : 32'h0) | (_wdata_1_value_8_T ? data_7 : 32'h0)
        | (_wdata_1_value_9_T ? data_8 : 32'h0) | (_wdata_1_value_10_T ? data_9 : 32'h0)
        | (_wdata_1_value_11_T ? data_10 : 32'h0)
        | (_wdata_1_value_12_T ? data_11 : 32'h0)
        | (_wdata_1_value_13_T ? data_12 : 32'h0)
        | (_wdata_1_value_14_T ? data_13 : 32'h0)
        | (_wdata_1_value_15_T ? data_14 : 32'h0)
        | (_wdata_1_value_16_T ? data_15 : 32'h0)
        | (_wdata_1_value_17_T ? data_16 : 32'h0)
        | (_wdata_1_value_18_T ? data_17 : 32'h0)
        | (_wdata_1_value_19_T ? data_18 : 32'h0)
        | (_wdata_1_value_20_T ? data_19 : 32'h0)
        | (_wdata_1_value_21_T ? data_20 : 32'h0)
        | (_wdata_1_value_22_T ? data_21 : 32'h0)
        | (_wdata_1_value_23_T ? data_22 : 32'h0)
        | (_wdata_1_value_24_T ? data_23 : 32'h0)
        | (_wdata_1_value_25_T ? data_24 : 32'h0)
        | (_wdata_1_value_26_T ? data_25 : 32'h0)
        | (_wdata_1_value_27_T ? data_26 : 32'h0)
        | (_wdata_1_value_28_T ? data_27 : 32'h0)
        | (_wdata_1_value_29_T ? data_28 : 32'h0)
        | (_wdata_1_value_30_T ? data_29 : 32'h0)
        | ((&io_readAddr_1_addr) ? data_30 : 32'h0)
      : (_wdata_1_value_1_T ? regfile_1 : 32'h0)
        | (_wdata_1_value_2_T ? regfile_2 : 32'h0)
        | (_wdata_1_value_3_T ? regfile_3 : 32'h0)
        | (_wdata_1_value_4_T ? regfile_4 : 32'h0)
        | (_wdata_1_value_5_T ? regfile_5 : 32'h0)
        | (_wdata_1_value_6_T ? regfile_6 : 32'h0)
        | (_wdata_1_value_7_T ? regfile_7 : 32'h0)
        | (_wdata_1_value_8_T ? regfile_8 : 32'h0)
        | (_wdata_1_value_9_T ? regfile_9 : 32'h0)
        | (_wdata_1_value_10_T ? regfile_10 : 32'h0)
        | (_wdata_1_value_11_T ? regfile_11 : 32'h0)
        | (_wdata_1_value_12_T ? regfile_12 : 32'h0)
        | (_wdata_1_value_13_T ? regfile_13 : 32'h0)
        | (_wdata_1_value_14_T ? regfile_14 : 32'h0)
        | (_wdata_1_value_15_T ? regfile_15 : 32'h0)
        | (_wdata_1_value_16_T ? regfile_16 : 32'h0)
        | (_wdata_1_value_17_T ? regfile_17 : 32'h0)
        | (_wdata_1_value_18_T ? regfile_18 : 32'h0)
        | (_wdata_1_value_19_T ? regfile_19 : 32'h0)
        | (_wdata_1_value_20_T ? regfile_20 : 32'h0)
        | (_wdata_1_value_21_T ? regfile_21 : 32'h0)
        | (_wdata_1_value_22_T ? regfile_22 : 32'h0)
        | (_wdata_1_value_23_T ? regfile_23 : 32'h0)
        | (_wdata_1_value_24_T ? regfile_24 : 32'h0)
        | (_wdata_1_value_25_T ? regfile_25 : 32'h0)
        | (_wdata_1_value_26_T ? regfile_26 : 32'h0)
        | (_wdata_1_value_27_T ? regfile_27 : 32'h0)
        | (_wdata_1_value_28_T ? regfile_28 : 32'h0)
        | (_wdata_1_value_29_T ? regfile_29 : 32'h0)
        | (_wdata_1_value_30_T ? regfile_30 : 32'h0)
        | ((&io_readAddr_1_addr) ? regfile_31 : 32'h0);
  wire        _wdata_2_value_1_T = io_readAddr_2_addr == 5'h1;
  wire        _wdata_2_value_2_T = io_readAddr_2_addr == 5'h2;
  wire        _wdata_2_value_3_T = io_readAddr_2_addr == 5'h3;
  wire        _wdata_2_value_4_T = io_readAddr_2_addr == 5'h4;
  wire        _wdata_2_value_5_T = io_readAddr_2_addr == 5'h5;
  wire        _wdata_2_value_6_T = io_readAddr_2_addr == 5'h6;
  wire        _wdata_2_value_7_T = io_readAddr_2_addr == 5'h7;
  wire        _wdata_2_value_8_T = io_readAddr_2_addr == 5'h8;
  wire        _wdata_2_value_9_T = io_readAddr_2_addr == 5'h9;
  wire        _wdata_2_value_10_T = io_readAddr_2_addr == 5'hA;
  wire        _wdata_2_value_11_T = io_readAddr_2_addr == 5'hB;
  wire        _wdata_2_value_12_T = io_readAddr_2_addr == 5'hC;
  wire        _wdata_2_value_13_T = io_readAddr_2_addr == 5'hD;
  wire        _wdata_2_value_14_T = io_readAddr_2_addr == 5'hE;
  wire        _wdata_2_value_15_T = io_readAddr_2_addr == 5'hF;
  wire        _wdata_2_value_16_T = io_readAddr_2_addr == 5'h10;
  wire        _wdata_2_value_17_T = io_readAddr_2_addr == 5'h11;
  wire        _wdata_2_value_18_T = io_readAddr_2_addr == 5'h12;
  wire        _wdata_2_value_19_T = io_readAddr_2_addr == 5'h13;
  wire        _wdata_2_value_20_T = io_readAddr_2_addr == 5'h14;
  wire        _wdata_2_value_21_T = io_readAddr_2_addr == 5'h15;
  wire        _wdata_2_value_22_T = io_readAddr_2_addr == 5'h16;
  wire        _wdata_2_value_23_T = io_readAddr_2_addr == 5'h17;
  wire        _wdata_2_value_24_T = io_readAddr_2_addr == 5'h18;
  wire        _wdata_2_value_25_T = io_readAddr_2_addr == 5'h19;
  wire        _wdata_2_value_26_T = io_readAddr_2_addr == 5'h1A;
  wire        _wdata_2_value_27_T = io_readAddr_2_addr == 5'h1B;
  wire        _wdata_2_value_28_T = io_readAddr_2_addr == 5'h1C;
  wire        _wdata_2_value_29_T = io_readAddr_2_addr == 5'h1D;
  wire        _wdata_2_value_30_T = io_readAddr_2_addr == 5'h1E;
  wire [31:0] rdata_2_value_5_0 =
    (_wdata_2_value_1_T ? regfile_1 : 32'h0) | (_wdata_2_value_2_T ? regfile_2 : 32'h0)
    | (_wdata_2_value_3_T ? regfile_3 : 32'h0) | (_wdata_2_value_4_T ? regfile_4 : 32'h0)
    | (_wdata_2_value_5_T ? regfile_5 : 32'h0) | (_wdata_2_value_6_T ? regfile_6 : 32'h0)
    | (_wdata_2_value_7_T ? regfile_7 : 32'h0) | (_wdata_2_value_8_T ? regfile_8 : 32'h0)
    | (_wdata_2_value_9_T ? regfile_9 : 32'h0)
    | (_wdata_2_value_10_T ? regfile_10 : 32'h0)
    | (_wdata_2_value_11_T ? regfile_11 : 32'h0)
    | (_wdata_2_value_12_T ? regfile_12 : 32'h0)
    | (_wdata_2_value_13_T ? regfile_13 : 32'h0)
    | (_wdata_2_value_14_T ? regfile_14 : 32'h0)
    | (_wdata_2_value_15_T ? regfile_15 : 32'h0)
    | (_wdata_2_value_16_T ? regfile_16 : 32'h0)
    | (_wdata_2_value_17_T ? regfile_17 : 32'h0)
    | (_wdata_2_value_18_T ? regfile_18 : 32'h0)
    | (_wdata_2_value_19_T ? regfile_19 : 32'h0)
    | (_wdata_2_value_20_T ? regfile_20 : 32'h0)
    | (_wdata_2_value_21_T ? regfile_21 : 32'h0)
    | (_wdata_2_value_22_T ? regfile_22 : 32'h0)
    | (_wdata_2_value_23_T ? regfile_23 : 32'h0)
    | (_wdata_2_value_24_T ? regfile_24 : 32'h0)
    | (_wdata_2_value_25_T ? regfile_25 : 32'h0)
    | (_wdata_2_value_26_T ? regfile_26 : 32'h0)
    | (_wdata_2_value_27_T ? regfile_27 : 32'h0)
    | (_wdata_2_value_28_T ? regfile_28 : 32'h0)
    | (_wdata_2_value_29_T ? regfile_29 : 32'h0)
    | (_wdata_2_value_30_T ? regfile_30 : 32'h0)
    | ((&io_readAddr_2_addr) ? regfile_31 : 32'h0);
  wire [31:0] rwdata_2 =
    io_readAddr_2_addr == 5'h0 | _wdata_2_value_1_T & (|_writeValid_1_T)
    | _wdata_2_value_2_T & (|_writeValid_2_T) | _wdata_2_value_3_T & (|_writeValid_3_T)
    | _wdata_2_value_4_T & (|_writeValid_4_T) | _wdata_2_value_5_T & (|_writeValid_5_T)
    | _wdata_2_value_6_T & (|_writeValid_6_T) | _wdata_2_value_7_T & (|_writeValid_7_T)
    | _wdata_2_value_8_T & (|_writeValid_8_T) | _wdata_2_value_9_T & (|_writeValid_9_T)
    | _wdata_2_value_10_T & (|_writeValid_10_T) | _wdata_2_value_11_T
    & (|_writeValid_11_T) | _wdata_2_value_12_T & (|_writeValid_12_T)
    | _wdata_2_value_13_T & (|_writeValid_13_T) | _wdata_2_value_14_T
    & (|_writeValid_14_T) | _wdata_2_value_15_T & (|_writeValid_15_T)
    | _wdata_2_value_16_T & (|_writeValid_16_T) | _wdata_2_value_17_T
    & (|_writeValid_17_T) | _wdata_2_value_18_T & (|_writeValid_18_T)
    | _wdata_2_value_19_T & (|_writeValid_19_T) | _wdata_2_value_20_T
    & (|_writeValid_20_T) | _wdata_2_value_21_T & (|_writeValid_21_T)
    | _wdata_2_value_22_T & (|_writeValid_22_T) | _wdata_2_value_23_T
    & (|_writeValid_23_T) | _wdata_2_value_24_T & (|_writeValid_24_T)
    | _wdata_2_value_25_T & (|_writeValid_25_T) | _wdata_2_value_26_T
    & (|_writeValid_26_T) | _wdata_2_value_27_T & (|_writeValid_27_T)
    | _wdata_2_value_28_T & (|_writeValid_28_T) | _wdata_2_value_29_T
    & (|_writeValid_29_T) | _wdata_2_value_30_T & (|_writeValid_30_T)
    | (&io_readAddr_2_addr) & (|_writeValid_31_T)
      ? (_wdata_2_value_1_T ? data : 32'h0) | (_wdata_2_value_2_T ? data_1 : 32'h0)
        | (_wdata_2_value_3_T ? data_2 : 32'h0) | (_wdata_2_value_4_T ? data_3 : 32'h0)
        | (_wdata_2_value_5_T ? data_4 : 32'h0) | (_wdata_2_value_6_T ? data_5 : 32'h0)
        | (_wdata_2_value_7_T ? data_6 : 32'h0) | (_wdata_2_value_8_T ? data_7 : 32'h0)
        | (_wdata_2_value_9_T ? data_8 : 32'h0) | (_wdata_2_value_10_T ? data_9 : 32'h0)
        | (_wdata_2_value_11_T ? data_10 : 32'h0)
        | (_wdata_2_value_12_T ? data_11 : 32'h0)
        | (_wdata_2_value_13_T ? data_12 : 32'h0)
        | (_wdata_2_value_14_T ? data_13 : 32'h0)
        | (_wdata_2_value_15_T ? data_14 : 32'h0)
        | (_wdata_2_value_16_T ? data_15 : 32'h0)
        | (_wdata_2_value_17_T ? data_16 : 32'h0)
        | (_wdata_2_value_18_T ? data_17 : 32'h0)
        | (_wdata_2_value_19_T ? data_18 : 32'h0)
        | (_wdata_2_value_20_T ? data_19 : 32'h0)
        | (_wdata_2_value_21_T ? data_20 : 32'h0)
        | (_wdata_2_value_22_T ? data_21 : 32'h0)
        | (_wdata_2_value_23_T ? data_22 : 32'h0)
        | (_wdata_2_value_24_T ? data_23 : 32'h0)
        | (_wdata_2_value_25_T ? data_24 : 32'h0)
        | (_wdata_2_value_26_T ? data_25 : 32'h0)
        | (_wdata_2_value_27_T ? data_26 : 32'h0)
        | (_wdata_2_value_28_T ? data_27 : 32'h0)
        | (_wdata_2_value_29_T ? data_28 : 32'h0)
        | (_wdata_2_value_30_T ? data_29 : 32'h0)
        | ((&io_readAddr_2_addr) ? data_30 : 32'h0)
      : rdata_2_value_5_0;
  wire        _wdata_3_value_1_T = io_readAddr_3_addr == 5'h1;
  wire        _wdata_3_value_2_T = io_readAddr_3_addr == 5'h2;
  wire        _wdata_3_value_3_T = io_readAddr_3_addr == 5'h3;
  wire        _wdata_3_value_4_T = io_readAddr_3_addr == 5'h4;
  wire        _wdata_3_value_5_T = io_readAddr_3_addr == 5'h5;
  wire        _wdata_3_value_6_T = io_readAddr_3_addr == 5'h6;
  wire        _wdata_3_value_7_T = io_readAddr_3_addr == 5'h7;
  wire        _wdata_3_value_8_T = io_readAddr_3_addr == 5'h8;
  wire        _wdata_3_value_9_T = io_readAddr_3_addr == 5'h9;
  wire        _wdata_3_value_10_T = io_readAddr_3_addr == 5'hA;
  wire        _wdata_3_value_11_T = io_readAddr_3_addr == 5'hB;
  wire        _wdata_3_value_12_T = io_readAddr_3_addr == 5'hC;
  wire        _wdata_3_value_13_T = io_readAddr_3_addr == 5'hD;
  wire        _wdata_3_value_14_T = io_readAddr_3_addr == 5'hE;
  wire        _wdata_3_value_15_T = io_readAddr_3_addr == 5'hF;
  wire        _wdata_3_value_16_T = io_readAddr_3_addr == 5'h10;
  wire        _wdata_3_value_17_T = io_readAddr_3_addr == 5'h11;
  wire        _wdata_3_value_18_T = io_readAddr_3_addr == 5'h12;
  wire        _wdata_3_value_19_T = io_readAddr_3_addr == 5'h13;
  wire        _wdata_3_value_20_T = io_readAddr_3_addr == 5'h14;
  wire        _wdata_3_value_21_T = io_readAddr_3_addr == 5'h15;
  wire        _wdata_3_value_22_T = io_readAddr_3_addr == 5'h16;
  wire        _wdata_3_value_23_T = io_readAddr_3_addr == 5'h17;
  wire        _wdata_3_value_24_T = io_readAddr_3_addr == 5'h18;
  wire        _wdata_3_value_25_T = io_readAddr_3_addr == 5'h19;
  wire        _wdata_3_value_26_T = io_readAddr_3_addr == 5'h1A;
  wire        _wdata_3_value_27_T = io_readAddr_3_addr == 5'h1B;
  wire        _wdata_3_value_28_T = io_readAddr_3_addr == 5'h1C;
  wire        _wdata_3_value_29_T = io_readAddr_3_addr == 5'h1D;
  wire        _wdata_3_value_30_T = io_readAddr_3_addr == 5'h1E;
  wire [31:0] rwdata_3 =
    io_readAddr_3_addr == 5'h0 | _wdata_3_value_1_T & (|_writeValid_1_T)
    | _wdata_3_value_2_T & (|_writeValid_2_T) | _wdata_3_value_3_T & (|_writeValid_3_T)
    | _wdata_3_value_4_T & (|_writeValid_4_T) | _wdata_3_value_5_T & (|_writeValid_5_T)
    | _wdata_3_value_6_T & (|_writeValid_6_T) | _wdata_3_value_7_T & (|_writeValid_7_T)
    | _wdata_3_value_8_T & (|_writeValid_8_T) | _wdata_3_value_9_T & (|_writeValid_9_T)
    | _wdata_3_value_10_T & (|_writeValid_10_T) | _wdata_3_value_11_T
    & (|_writeValid_11_T) | _wdata_3_value_12_T & (|_writeValid_12_T)
    | _wdata_3_value_13_T & (|_writeValid_13_T) | _wdata_3_value_14_T
    & (|_writeValid_14_T) | _wdata_3_value_15_T & (|_writeValid_15_T)
    | _wdata_3_value_16_T & (|_writeValid_16_T) | _wdata_3_value_17_T
    & (|_writeValid_17_T) | _wdata_3_value_18_T & (|_writeValid_18_T)
    | _wdata_3_value_19_T & (|_writeValid_19_T) | _wdata_3_value_20_T
    & (|_writeValid_20_T) | _wdata_3_value_21_T & (|_writeValid_21_T)
    | _wdata_3_value_22_T & (|_writeValid_22_T) | _wdata_3_value_23_T
    & (|_writeValid_23_T) | _wdata_3_value_24_T & (|_writeValid_24_T)
    | _wdata_3_value_25_T & (|_writeValid_25_T) | _wdata_3_value_26_T
    & (|_writeValid_26_T) | _wdata_3_value_27_T & (|_writeValid_27_T)
    | _wdata_3_value_28_T & (|_writeValid_28_T) | _wdata_3_value_29_T
    & (|_writeValid_29_T) | _wdata_3_value_30_T & (|_writeValid_30_T)
    | (&io_readAddr_3_addr) & (|_writeValid_31_T)
      ? (_wdata_3_value_1_T ? data : 32'h0) | (_wdata_3_value_2_T ? data_1 : 32'h0)
        | (_wdata_3_value_3_T ? data_2 : 32'h0) | (_wdata_3_value_4_T ? data_3 : 32'h0)
        | (_wdata_3_value_5_T ? data_4 : 32'h0) | (_wdata_3_value_6_T ? data_5 : 32'h0)
        | (_wdata_3_value_7_T ? data_6 : 32'h0) | (_wdata_3_value_8_T ? data_7 : 32'h0)
        | (_wdata_3_value_9_T ? data_8 : 32'h0) | (_wdata_3_value_10_T ? data_9 : 32'h0)
        | (_wdata_3_value_11_T ? data_10 : 32'h0)
        | (_wdata_3_value_12_T ? data_11 : 32'h0)
        | (_wdata_3_value_13_T ? data_12 : 32'h0)
        | (_wdata_3_value_14_T ? data_13 : 32'h0)
        | (_wdata_3_value_15_T ? data_14 : 32'h0)
        | (_wdata_3_value_16_T ? data_15 : 32'h0)
        | (_wdata_3_value_17_T ? data_16 : 32'h0)
        | (_wdata_3_value_18_T ? data_17 : 32'h0)
        | (_wdata_3_value_19_T ? data_18 : 32'h0)
        | (_wdata_3_value_20_T ? data_19 : 32'h0)
        | (_wdata_3_value_21_T ? data_20 : 32'h0)
        | (_wdata_3_value_22_T ? data_21 : 32'h0)
        | (_wdata_3_value_23_T ? data_22 : 32'h0)
        | (_wdata_3_value_24_T ? data_23 : 32'h0)
        | (_wdata_3_value_25_T ? data_24 : 32'h0)
        | (_wdata_3_value_26_T ? data_25 : 32'h0)
        | (_wdata_3_value_27_T ? data_26 : 32'h0)
        | (_wdata_3_value_28_T ? data_27 : 32'h0)
        | (_wdata_3_value_29_T ? data_28 : 32'h0)
        | (_wdata_3_value_30_T ? data_29 : 32'h0)
        | ((&io_readAddr_3_addr) ? data_30 : 32'h0)
      : (_wdata_3_value_1_T ? regfile_1 : 32'h0)
        | (_wdata_3_value_2_T ? regfile_2 : 32'h0)
        | (_wdata_3_value_3_T ? regfile_3 : 32'h0)
        | (_wdata_3_value_4_T ? regfile_4 : 32'h0)
        | (_wdata_3_value_5_T ? regfile_5 : 32'h0)
        | (_wdata_3_value_6_T ? regfile_6 : 32'h0)
        | (_wdata_3_value_7_T ? regfile_7 : 32'h0)
        | (_wdata_3_value_8_T ? regfile_8 : 32'h0)
        | (_wdata_3_value_9_T ? regfile_9 : 32'h0)
        | (_wdata_3_value_10_T ? regfile_10 : 32'h0)
        | (_wdata_3_value_11_T ? regfile_11 : 32'h0)
        | (_wdata_3_value_12_T ? regfile_12 : 32'h0)
        | (_wdata_3_value_13_T ? regfile_13 : 32'h0)
        | (_wdata_3_value_14_T ? regfile_14 : 32'h0)
        | (_wdata_3_value_15_T ? regfile_15 : 32'h0)
        | (_wdata_3_value_16_T ? regfile_16 : 32'h0)
        | (_wdata_3_value_17_T ? regfile_17 : 32'h0)
        | (_wdata_3_value_18_T ? regfile_18 : 32'h0)
        | (_wdata_3_value_19_T ? regfile_19 : 32'h0)
        | (_wdata_3_value_20_T ? regfile_20 : 32'h0)
        | (_wdata_3_value_21_T ? regfile_21 : 32'h0)
        | (_wdata_3_value_22_T ? regfile_22 : 32'h0)
        | (_wdata_3_value_23_T ? regfile_23 : 32'h0)
        | (_wdata_3_value_24_T ? regfile_24 : 32'h0)
        | (_wdata_3_value_25_T ? regfile_25 : 32'h0)
        | (_wdata_3_value_26_T ? regfile_26 : 32'h0)
        | (_wdata_3_value_27_T ? regfile_27 : 32'h0)
        | (_wdata_3_value_28_T ? regfile_28 : 32'h0)
        | (_wdata_3_value_29_T ? regfile_29 : 32'h0)
        | (_wdata_3_value_30_T ? regfile_30 : 32'h0)
        | ((&io_readAddr_3_addr) ? regfile_31 : 32'h0);
  wire [31:0] busAddr_0 =
    io_busAddr_0_bypass
      ? rwdata_0
      : io_busAddr_0_immen ? rdata_0_value_5_0 + io_busAddr_0_immed : rdata_0_value_5_0;
  wire [31:0] busAddr_1 =
    io_busAddr_1_bypass ? rwdata_2 : rdata_2_value_5_0 + io_busAddr_1_immed;
  reg         write_fail;
  reg         write_fail_1;
  reg         write_fail_2;
  reg         write_fail_3;
  reg         write_fail_4;
  reg         write_fail_5;
  reg         scoreboard_error;
  wire [31:0] scoreboard_set =
    (io_writeAddr_0_valid ? 32'h1 << io_writeAddr_0_addr : 32'h0)
    | (io_writeAddr_1_valid ? 32'h1 << io_writeAddr_1_addr : 32'h0);
  wire [31:0] scoreboard_clr = {scoreboard_clr0, 1'h0};
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      regfile_1 <= 32'h0;
      regfile_2 <= 32'h0;
      regfile_3 <= 32'h0;
      regfile_4 <= 32'h0;
      regfile_5 <= 32'h0;
      regfile_6 <= 32'h0;
      regfile_7 <= 32'h0;
      regfile_8 <= 32'h0;
      regfile_9 <= 32'h0;
      regfile_10 <= 32'h0;
      regfile_11 <= 32'h0;
      regfile_12 <= 32'h0;
      regfile_13 <= 32'h0;
      regfile_14 <= 32'h0;
      regfile_15 <= 32'h0;
      regfile_16 <= 32'h0;
      regfile_17 <= 32'h0;
      regfile_18 <= 32'h0;
      regfile_19 <= 32'h0;
      regfile_20 <= 32'h0;
      regfile_21 <= 32'h0;
      regfile_22 <= 32'h0;
      regfile_23 <= 32'h0;
      regfile_24 <= 32'h0;
      regfile_25 <= 32'h0;
      regfile_26 <= 32'h0;
      regfile_27 <= 32'h0;
      regfile_28 <= 32'h0;
      regfile_29 <= 32'h0;
      regfile_30 <= 32'h0;
      regfile_31 <= 32'h0;
      scoreboard <= 32'h0;
      readDataReady_0 <= 1'h0;
      readDataReady_1 <= 1'h0;
      readDataReady_2 <= 1'h0;
      readDataReady_3 <= 1'h0;
      readDataBits_0 <= 32'h0;
      readDataBits_1 <= 32'h0;
      readDataBits_2 <= 32'h0;
      readDataBits_3 <= 32'h0;
      write_fail <= 1'h0;
      write_fail_1 <= 1'h0;
      write_fail_2 <= 1'h0;
      write_fail_3 <= 1'h0;
      write_fail_4 <= 1'h0;
      write_fail_5 <= 1'h0;
      scoreboard_error <= 1'h0;
    end
    else begin
      if (|_writeValid_1_T)
        regfile_1 <= data;
      if (|_writeValid_2_T)
        regfile_2 <= data_1;
      if (|_writeValid_3_T)
        regfile_3 <= data_2;
      if (|_writeValid_4_T)
        regfile_4 <= data_3;
      if (|_writeValid_5_T)
        regfile_5 <= data_4;
      if (|_writeValid_6_T)
        regfile_6 <= data_5;
      if (|_writeValid_7_T)
        regfile_7 <= data_6;
      if (|_writeValid_8_T)
        regfile_8 <= data_7;
      if (|_writeValid_9_T)
        regfile_9 <= data_8;
      if (|_writeValid_10_T)
        regfile_10 <= data_9;
      if (|_writeValid_11_T)
        regfile_11 <= data_10;
      if (|_writeValid_12_T)
        regfile_12 <= data_11;
      if (|_writeValid_13_T)
        regfile_13 <= data_12;
      if (|_writeValid_14_T)
        regfile_14 <= data_13;
      if (|_writeValid_15_T)
        regfile_15 <= data_14;
      if (|_writeValid_16_T)
        regfile_16 <= data_15;
      if (|_writeValid_17_T)
        regfile_17 <= data_16;
      if (|_writeValid_18_T)
        regfile_18 <= data_17;
      if (|_writeValid_19_T)
        regfile_19 <= data_18;
      if (|_writeValid_20_T)
        regfile_20 <= data_19;
      if (|_writeValid_21_T)
        regfile_21 <= data_20;
      if (|_writeValid_22_T)
        regfile_22 <= data_21;
      if (|_writeValid_23_T)
        regfile_23 <= data_22;
      if (|_writeValid_24_T)
        regfile_24 <= data_23;
      if (|_writeValid_25_T)
        regfile_25 <= data_24;
      if (|_writeValid_26_T)
        regfile_26 <= data_25;
      if (|_writeValid_27_T)
        regfile_27 <= data_26;
      if (|_writeValid_28_T)
        regfile_28 <= data_27;
      if (|_writeValid_29_T)
        regfile_29 <= data_28;
      if (|_writeValid_30_T)
        regfile_30 <= data_29;
      if (|_writeValid_31_T)
        regfile_31 <= data_30;
      if (|{scoreboard_set, scoreboard_clr0})
        scoreboard <= {scoreboard[31:1] & ~scoreboard_clr0 | scoreboard_set[31:1], 1'h0};
      readDataReady_0 <= io_readAddr_0_valid | io_readSet_0_valid;
      readDataReady_1 <= io_readAddr_1_valid | io_readSet_1_valid;
      readDataReady_2 <= io_readAddr_2_valid | io_readSet_2_valid;
      readDataReady_3 <= io_readAddr_3_valid | io_readSet_3_valid;
      if (io_readSet_0_valid)
        readDataBits_0 <= io_readSet_0_value;
      else if (io_readAddr_0_valid)
        readDataBits_0 <= rwdata_0;
      if (io_readSet_1_valid)
        readDataBits_1 <= io_readSet_1_value;
      else if (io_readAddr_1_valid)
        readDataBits_1 <= rwdata_1;
      if (io_readSet_2_valid)
        readDataBits_2 <= io_readSet_2_value;
      else if (io_readAddr_2_valid)
        readDataBits_2 <= rwdata_2;
      if (io_readSet_3_valid)
        readDataBits_3 <= io_readSet_3_value;
      else if (io_readAddr_3_valid)
        readDataBits_3 <= rwdata_3;
      write_fail <=
        io_writeData_0_valid & io_writeData_1_valid
        & io_writeData_0_bits_addr == io_writeData_1_bits_addr
        & (|io_writeData_0_bits_addr);
      write_fail_1 <=
        io_writeData_0_valid & io_writeData_2_valid
        & io_writeData_0_bits_addr == io_writeData_2_bits_addr
        & (|io_writeData_0_bits_addr);
      write_fail_2 <=
        io_writeData_0_valid & io_writeData_3_valid
        & io_writeData_0_bits_addr == io_writeData_3_bits_addr
        & (|io_writeData_0_bits_addr);
      write_fail_3 <=
        io_writeData_1_valid & io_writeData_2_valid
        & io_writeData_1_bits_addr == io_writeData_2_bits_addr
        & (|io_writeData_1_bits_addr);
      write_fail_4 <=
        io_writeData_1_valid & io_writeData_3_valid
        & io_writeData_1_bits_addr == io_writeData_3_bits_addr
        & (|io_writeData_1_bits_addr);
      write_fail_5 <=
        io_writeData_2_valid & io_writeData_3_valid
        & io_writeData_2_bits_addr == io_writeData_3_bits_addr
        & (|io_writeData_2_bits_addr);
      scoreboard_error <= (scoreboard & scoreboard_clr) != scoreboard_clr;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:37];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [5:0] i = 6'h0; i < 6'h26; i += 6'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        regfile_1 = _RANDOM[6'h1];
        regfile_2 = _RANDOM[6'h2];
        regfile_3 = _RANDOM[6'h3];
        regfile_4 = _RANDOM[6'h4];
        regfile_5 = _RANDOM[6'h5];
        regfile_6 = _RANDOM[6'h6];
        regfile_7 = _RANDOM[6'h7];
        regfile_8 = _RANDOM[6'h8];
        regfile_9 = _RANDOM[6'h9];
        regfile_10 = _RANDOM[6'hA];
        regfile_11 = _RANDOM[6'hB];
        regfile_12 = _RANDOM[6'hC];
        regfile_13 = _RANDOM[6'hD];
        regfile_14 = _RANDOM[6'hE];
        regfile_15 = _RANDOM[6'hF];
        regfile_16 = _RANDOM[6'h10];
        regfile_17 = _RANDOM[6'h11];
        regfile_18 = _RANDOM[6'h12];
        regfile_19 = _RANDOM[6'h13];
        regfile_20 = _RANDOM[6'h14];
        regfile_21 = _RANDOM[6'h15];
        regfile_22 = _RANDOM[6'h16];
        regfile_23 = _RANDOM[6'h17];
        regfile_24 = _RANDOM[6'h18];
        regfile_25 = _RANDOM[6'h19];
        regfile_26 = _RANDOM[6'h1A];
        regfile_27 = _RANDOM[6'h1B];
        regfile_28 = _RANDOM[6'h1C];
        regfile_29 = _RANDOM[6'h1D];
        regfile_30 = _RANDOM[6'h1E];
        regfile_31 = _RANDOM[6'h1F];
        scoreboard = _RANDOM[6'h20];
        readDataReady_0 = _RANDOM[6'h21][0];
        readDataReady_1 = _RANDOM[6'h21][1];
        readDataReady_2 = _RANDOM[6'h21][2];
        readDataReady_3 = _RANDOM[6'h21][3];
        readDataBits_0 = {_RANDOM[6'h21][31:4], _RANDOM[6'h22][3:0]};
        readDataBits_1 = {_RANDOM[6'h22][31:4], _RANDOM[6'h23][3:0]};
        readDataBits_2 = {_RANDOM[6'h23][31:4], _RANDOM[6'h24][3:0]};
        readDataBits_3 = {_RANDOM[6'h24][31:4], _RANDOM[6'h25][3:0]};
        write_fail = _RANDOM[6'h25][4];
        write_fail_1 = _RANDOM[6'h25][5];
        write_fail_2 = _RANDOM[6'h25][6];
        write_fail_3 = _RANDOM[6'h25][7];
        write_fail_4 = _RANDOM[6'h25][8];
        write_fail_5 = _RANDOM[6'h25][9];
        scoreboard_error = _RANDOM[6'h25][10];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        regfile_1 = 32'h0;
        regfile_2 = 32'h0;
        regfile_3 = 32'h0;
        regfile_4 = 32'h0;
        regfile_5 = 32'h0;
        regfile_6 = 32'h0;
        regfile_7 = 32'h0;
        regfile_8 = 32'h0;
        regfile_9 = 32'h0;
        regfile_10 = 32'h0;
        regfile_11 = 32'h0;
        regfile_12 = 32'h0;
        regfile_13 = 32'h0;
        regfile_14 = 32'h0;
        regfile_15 = 32'h0;
        regfile_16 = 32'h0;
        regfile_17 = 32'h0;
        regfile_18 = 32'h0;
        regfile_19 = 32'h0;
        regfile_20 = 32'h0;
        regfile_21 = 32'h0;
        regfile_22 = 32'h0;
        regfile_23 = 32'h0;
        regfile_24 = 32'h0;
        regfile_25 = 32'h0;
        regfile_26 = 32'h0;
        regfile_27 = 32'h0;
        regfile_28 = 32'h0;
        regfile_29 = 32'h0;
        regfile_30 = 32'h0;
        regfile_31 = 32'h0;
        scoreboard = 32'h0;
        readDataReady_0 = 1'h0;
        readDataReady_1 = 1'h0;
        readDataReady_2 = 1'h0;
        readDataReady_3 = 1'h0;
        readDataBits_0 = 32'h0;
        readDataBits_1 = 32'h0;
        readDataBits_2 = 32'h0;
        readDataBits_3 = 32'h0;
        write_fail = 1'h0;
        write_fail_1 = 1'h0;
        write_fail_2 = 1'h0;
        write_fail_3 = 1'h0;
        write_fail_4 = 1'h0;
        write_fail_5 = 1'h0;
        scoreboard_error = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_target_0_data = busAddr_0;
  assign io_target_1_data = busAddr_1;
  assign io_busPort_addr_0 = busAddr_0;
  assign io_busPort_addr_1 = busAddr_1;
  assign io_busPort_data_0 = io_readSet_1_valid ? io_readSet_1_value : rwdata_1;
  assign io_busPort_data_1 = io_readSet_3_valid ? io_readSet_3_value : rwdata_3;
  assign io_readData_0_valid = readDataReady_0;
  assign io_readData_0_data = readDataBits_0;
  assign io_readData_1_valid = readDataReady_1;
  assign io_readData_1_data = readDataBits_1;
  assign io_readData_2_valid = readDataReady_2;
  assign io_readData_2_data = readDataBits_2;
  assign io_readData_3_valid = readDataReady_3;
  assign io_readData_3_data = readDataBits_3;
  assign io_scoreboard_regd = scoreboard;
  assign io_scoreboard_comb = scoreboard & {~scoreboard_clr0, 1'h1};
  assign io_rfwriteCount =
    {1'h0,
     {1'h0,
      {1'h0,
       {1'h0, {1'h0, |_writeValid_1_T} + 2'h1}
         + {1'h0, {1'h0, |_writeValid_2_T} + {1'h0, |_writeValid_3_T}}}
        + {1'h0,
           {1'h0, {1'h0, |_writeValid_4_T} + {1'h0, |_writeValid_5_T}}
             + {1'h0, {1'h0, |_writeValid_6_T} + {1'h0, |_writeValid_7_T}}}}
       + {1'h0,
          {1'h0,
           {1'h0, {1'h0, |_writeValid_8_T} + {1'h0, |_writeValid_9_T}}
             + {1'h0, {1'h0, |_writeValid_10_T} + {1'h0, |_writeValid_11_T}}}
            + {1'h0,
               {1'h0, {1'h0, |_writeValid_12_T} + {1'h0, |_writeValid_13_T}}
                 + {1'h0, {1'h0, |_writeValid_14_T} + {1'h0, |_writeValid_15_T}}}}}
    + {1'h0,
       {1'h0,
        {1'h0,
         {1'h0, {1'h0, |_writeValid_16_T} + {1'h0, |_writeValid_17_T}}
           + {1'h0, {1'h0, |_writeValid_18_T} + {1'h0, |_writeValid_19_T}}}
          + {1'h0,
             {1'h0, {1'h0, |_writeValid_20_T} + {1'h0, |_writeValid_21_T}}
               + {1'h0, {1'h0, |_writeValid_22_T} + {1'h0, |_writeValid_23_T}}}}
         + {1'h0,
            {1'h0,
             {1'h0, {1'h0, |_writeValid_24_T} + {1'h0, |_writeValid_25_T}}
               + {1'h0, {1'h0, |_writeValid_26_T} + {1'h0, |_writeValid_27_T}}}
              + {1'h0,
                 {1'h0, {1'h0, |_writeValid_28_T} + {1'h0, |_writeValid_29_T}}
                   + {1'h0, {1'h0, |_writeValid_30_T} + {1'h0, |_writeValid_31_T}}}}}
    + {4'h0,
       {1'h0, io_writeData_0_valid & io_writeData_0_bits_addr == 5'h0}
         + {1'h0,
            io_writeData_1_valid & io_writeData_1_bits_addr == 5'h0
              & ~io_writeMask_1_valid}} - 6'h1;
endmodule

module FetchControl(
  input         clock,
                reset,
  output        io_fetchFault,
  input  [31:0] io_csr_value_0,
  input         io_iflush_valid,
  input  [31:0] io_iflush_bits,
  input         io_branch_valid,
  input  [31:0] io_branch_bits,
  input         io_fetchData_valid,
  input  [31:0] io_fetchData_bits_addr,
                io_fetchData_bits_inst_0,
                io_fetchData_bits_inst_1,
                io_fetchData_bits_inst_2,
                io_fetchData_bits_inst_3,
  input         io_fetchData_bits_fault,
  output        io_fetchAddr_valid,
  output [31:0] io_fetchAddr_bits,
  output [2:0]  io_bufferRequest_nValid,
  output [31:0] io_bufferRequest_bits_0_addr,
                io_bufferRequest_bits_0_inst,
  output        io_bufferRequest_bits_0_brchFwd,
  output [31:0] io_bufferRequest_bits_1_addr,
                io_bufferRequest_bits_1_inst,
  output        io_bufferRequest_bits_1_brchFwd,
  output [31:0] io_bufferRequest_bits_2_addr,
                io_bufferRequest_bits_2_inst,
  output        io_bufferRequest_bits_2_brchFwd,
  output [31:0] io_bufferRequest_bits_3_addr,
                io_bufferRequest_bits_3_inst,
  output        io_bufferRequest_bits_3_brchFwd,
  input  [3:0]  io_bufferSpaces
);

  wire [31:0] _GEN = {io_fetchData_bits_addr[31:4], 4'h0};
  wire        jumped_3 =
    io_fetchData_bits_inst_3[6:0] == 7'h6F | io_fetchData_bits_inst_3[6:0] == 7'h63
    & io_fetchData_bits_inst_3[31] & io_fetchData_bits_inst_3[14:13] != 2'h1;
  wire        jumped_0 =
    io_fetchData_bits_addr[3:2] == 2'h0
    & (io_fetchData_bits_inst_0[6:0] == 7'h6F | io_fetchData_bits_inst_0[6:0] == 7'h63
       & io_fetchData_bits_inst_0[31] & io_fetchData_bits_inst_0[14:13] != 2'h1);
  wire        jumped_1 =
    ~(io_fetchData_bits_addr[3])
    & (io_fetchData_bits_inst_1[6:0] == 7'h6F | io_fetchData_bits_inst_1[6:0] == 7'h63
       & io_fetchData_bits_inst_1[31] & io_fetchData_bits_inst_1[14:13] != 2'h1);
  wire        jumped_2 =
    io_fetchData_bits_addr[3:2] != 2'h3
    & (io_fetchData_bits_inst_2[6:0] == 7'h6F | io_fetchData_bits_inst_2[6:0] == 7'h63
       & io_fetchData_bits_inst_2[31] & io_fetchData_bits_inst_2[14:13] != 2'h1);
  wire [2:0]  lastInstIdx =
    jumped_0 ? 3'h0 : jumped_1 ? 3'h1 : jumped_2 ? 3'h2 : jumped_3 ? 3'h3 : 3'h4;
  wire [31:0] nextFetchPc =
    jumped_0
      ? _GEN
        + {{12{io_fetchData_bits_inst_0[31]}},
           io_fetchData_bits_inst_0[2]
             ? {io_fetchData_bits_inst_0[19:12],
                io_fetchData_bits_inst_0[20],
                io_fetchData_bits_inst_0[30:21]}
             : {{8{io_fetchData_bits_inst_0[31]}},
                io_fetchData_bits_inst_0[7],
                io_fetchData_bits_inst_0[30:25],
                io_fetchData_bits_inst_0[11:8]},
           1'h0}
      : jumped_1
          ? {io_fetchData_bits_addr[31:4], 4'h4}
            + {{12{io_fetchData_bits_inst_1[31]}},
               io_fetchData_bits_inst_1[2]
                 ? {io_fetchData_bits_inst_1[19:12],
                    io_fetchData_bits_inst_1[20],
                    io_fetchData_bits_inst_1[30:21]}
                 : {{8{io_fetchData_bits_inst_1[31]}},
                    io_fetchData_bits_inst_1[7],
                    io_fetchData_bits_inst_1[30:25],
                    io_fetchData_bits_inst_1[11:8]},
               1'h0}
          : jumped_2
              ? {io_fetchData_bits_addr[31:4], 4'h8}
                + {{12{io_fetchData_bits_inst_2[31]}},
                   io_fetchData_bits_inst_2[2]
                     ? {io_fetchData_bits_inst_2[19:12],
                        io_fetchData_bits_inst_2[20],
                        io_fetchData_bits_inst_2[30:21]}
                     : {{8{io_fetchData_bits_inst_2[31]}},
                        io_fetchData_bits_inst_2[7],
                        io_fetchData_bits_inst_2[30:25],
                        io_fetchData_bits_inst_2[11:8]},
                   1'h0}
              : jumped_3
                  ? {io_fetchData_bits_addr[31:4], 4'hC}
                    + {{12{io_fetchData_bits_inst_3[31]}},
                       io_fetchData_bits_inst_3[2]
                         ? {io_fetchData_bits_inst_3[19:12],
                            io_fetchData_bits_inst_3[20],
                            io_fetchData_bits_inst_3[30:21]}
                         : {{8{io_fetchData_bits_inst_3[31]}},
                            io_fetchData_bits_inst_3[7],
                            io_fetchData_bits_inst_3[30:25],
                            io_fetchData_bits_inst_3[11:8]},
                       1'h0}
                  : {io_fetchData_bits_addr[31:4] + 28'h1, 4'h0};
  wire [2:0]  predecode_startIdx = {1'h0, io_fetchData_bits_addr[3:2]};
  wire [2:0]  _GEN_0 = {1'h0, io_fetchData_bits_addr[3:2]};
  wire [2:0]  _result_count_T_7 =
    lastInstIdx == 3'h4 ? lastInstIdx - _GEN_0 : lastInstIdx + 3'h1 - _GEN_0;
  wire [4:0]  _predecodeValids_T_10 =
    {3'h0, io_fetchData_bits_addr[3:2]} + {2'h0, _result_count_T_7};
  wire        selectHot_0 =
    io_fetchData_bits_addr[3:2] == 2'h0 & (|_predecodeValids_T_10);
  wire        predecodeValids_1 =
    predecode_startIdx < 3'h2 & (|(_predecodeValids_T_10[4:1]));
  wire        predecodeValids_2 =
    predecode_startIdx < 3'h3 & _predecodeValids_T_10 > 5'h2;
  wire        selectHot_seenValid_2 = selectHot_0 | predecodeValids_1;
  wire        selectHot_1 = predecodeValids_1 & ~selectHot_0;
  wire        selectHot_2 = predecodeValids_2 & ~selectHot_seenValid_2;
  wire        selectHot_3 =
    (|(_predecodeValids_T_10[4:2])) & ~(selectHot_seenValid_2 | predecodeValids_2);
  wire [31:0] _io_bufferRequest_bits_3_addr_T_2 = _GEN + 32'h4;
  wire [31:0] _io_bufferRequest_bits_3_addr_T_4 = _GEN + 32'h8;
  wire [31:0] _io_bufferRequest_bits_3_addr_T_6 = _GEN + 32'hC;
  wire        selectHot_1_1 = predecodeValids_1 & ~selectHot_1;
  wire        _GEN_1 = predecodeValids_2 & ~selectHot_2;
  wire        _GEN_2 = (|(_predecodeValids_T_10[4:2])) & ~selectHot_3;
  wire        selectHot_1_2 = _GEN_1 & ~selectHot_1_1;
  wire        selectHot_1_3 = _GEN_2 & ~(selectHot_1_1 | _GEN_1);
  wire        selectHot_2_2 = _GEN_1 & ~selectHot_1_2;
  wire        _GEN_3 = _GEN_2 & ~selectHot_1_3;
  wire        selectHot_2_3 = _GEN_3 & ~selectHot_2_2;
  wire        selectHot_3_3 = _GEN_3 & ~selectHot_2_3;
  reg         pastBranchOrFlush;
  wire        currentBranchOrFlush = io_iflush_valid | io_branch_valid;
  wire        ongoingBranchOrFlush = pastBranchOrFlush | currentBranchOrFlush;
  reg         faulted;
  wire        fetchFault =
    (faulted | io_fetchData_valid & io_fetchData_bits_fault) & ~io_branch_valid;
  wire        writeToBuffer = io_fetchData_valid & ~fetchFault & ~ongoingBranchOrFlush;
  wire [3:0]  nValid = writeToBuffer ? {1'h0, _result_count_T_7} : 4'h0;
  reg         pc_valid;
  reg  [31:0] pc_bits;
  wire [31:0] _pcNext_T_2 = {io_csr_value_0[31:2], 2'h0};
  wire        blockNewFetch =
    ~pc_valid | currentBranchOrFlush | {1'h0, io_bufferSpaces} < {1'h0, nValid} + 5'h4
    | fetchFault;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      pastBranchOrFlush <= 1'h0;
      faulted <= 1'h0;
      pc_valid <= 1'h0;
      pc_bits <= 32'h0;
    end
    else begin
      pastBranchOrFlush <= ongoingBranchOrFlush & blockNewFetch;
      faulted <= fetchFault;
      pc_valid <= 1'h1;
      if (pc_valid) begin
        if (io_iflush_valid)
          pc_bits <= io_iflush_bits;
        else if (io_branch_valid)
          pc_bits <= io_branch_bits;
        else if (writeToBuffer)
          pc_bits <= nextFetchPc;
      end
      else
        pc_bits <= _pcNext_T_2;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:1];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          _RANDOM[i[0]] = `RANDOM;
        end
        pastBranchOrFlush = _RANDOM[1'h0][0];
        faulted = _RANDOM[1'h0][1];
        pc_valid = _RANDOM[1'h0][2];
        pc_bits = {_RANDOM[1'h0][31:3], _RANDOM[1'h1][2:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        pastBranchOrFlush = 1'h0;
        faulted = 1'h0;
        pc_valid = 1'h0;
        pc_bits = 32'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_fetchFault = fetchFault;
  assign io_fetchAddr_valid = ~blockNewFetch;
  assign io_fetchAddr_bits =
    blockNewFetch
      ? 32'h0
      : pc_valid
          ? (io_iflush_valid
               ? io_iflush_bits
               : io_branch_valid ? io_branch_bits : writeToBuffer ? nextFetchPc : pc_bits)
          : _pcNext_T_2;
  assign io_bufferRequest_nValid = nValid[2:0];
  assign io_bufferRequest_bits_0_addr =
    selectHot_0
      ? {io_fetchData_bits_addr[31:4], 4'h0}
      : selectHot_1
          ? _io_bufferRequest_bits_3_addr_T_2
          : selectHot_2
              ? _io_bufferRequest_bits_3_addr_T_4
              : selectHot_3 ? _io_bufferRequest_bits_3_addr_T_6 : 32'h0;
  assign io_bufferRequest_bits_0_inst =
    selectHot_0
      ? io_fetchData_bits_inst_0
      : selectHot_1
          ? io_fetchData_bits_inst_1
          : selectHot_2
              ? io_fetchData_bits_inst_2
              : selectHot_3 ? io_fetchData_bits_inst_3 : 32'h0;
  assign io_bufferRequest_bits_0_brchFwd =
    selectHot_0
      ? jumped_0
      : selectHot_1 ? jumped_1 : selectHot_2 ? jumped_2 : selectHot_3 & jumped_3;
  assign io_bufferRequest_bits_1_addr =
    selectHot_1_1
      ? _io_bufferRequest_bits_3_addr_T_2
      : selectHot_1_2
          ? _io_bufferRequest_bits_3_addr_T_4
          : selectHot_1_3 ? _io_bufferRequest_bits_3_addr_T_6 : 32'h0;
  assign io_bufferRequest_bits_1_inst =
    selectHot_1_1
      ? io_fetchData_bits_inst_1
      : selectHot_1_2
          ? io_fetchData_bits_inst_2
          : selectHot_1_3 ? io_fetchData_bits_inst_3 : 32'h0;
  assign io_bufferRequest_bits_1_brchFwd =
    selectHot_1_1 ? jumped_1 : selectHot_1_2 ? jumped_2 : selectHot_1_3 & jumped_3;
  assign io_bufferRequest_bits_2_addr =
    selectHot_2_2
      ? _io_bufferRequest_bits_3_addr_T_4
      : selectHot_2_3 ? _io_bufferRequest_bits_3_addr_T_6 : 32'h0;
  assign io_bufferRequest_bits_2_inst =
    selectHot_2_2
      ? io_fetchData_bits_inst_2
      : selectHot_2_3 ? io_fetchData_bits_inst_3 : 32'h0;
  assign io_bufferRequest_bits_2_brchFwd =
    selectHot_2_2 ? jumped_2 : selectHot_2_3 & jumped_3;
  assign io_bufferRequest_bits_3_addr =
    selectHot_3_3 ? _io_bufferRequest_bits_3_addr_T_6 : 32'h0;
  assign io_bufferRequest_bits_3_inst = selectHot_3_3 ? io_fetchData_bits_inst_3 : 32'h0;
  assign io_bufferRequest_bits_3_brchFwd = selectHot_3_3 & jumped_3;
endmodule

module Fetcher(
  input          clock,
                 reset,
                 io_ctrl_valid,
  input  [31:0]  io_ctrl_bits,
  output         io_fetch_valid,
  output [31:0]  io_fetch_bits_addr,
                 io_fetch_bits_inst_0,
                 io_fetch_bits_inst_1,
                 io_fetch_bits_inst_2,
                 io_fetch_bits_inst_3,
  output         io_fetch_bits_fault,
                 io_ibus_valid,
  input          io_ibus_ready,
  output [31:0]  io_ibus_addr,
  input  [127:0] io_ibus_rdata,
  input          io_ibus_fault_valid
);

  reg         ibusCmd_valid;
  reg  [31:0] ibusCmd_bits;
  reg         fault;
  wire        ibusFired = io_ctrl_valid & io_ibus_ready;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      ibusCmd_valid <= 1'h0;
      ibusCmd_bits <= 32'h0;
      fault <= 1'h0;
    end
    else begin
      ibusCmd_valid <= ibusFired;
      ibusCmd_bits <= ibusFired ? io_ctrl_bits : 32'h0;
      fault <= io_ibus_fault_valid;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:1];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          _RANDOM[i[0]] = `RANDOM;
        end
        ibusCmd_valid = _RANDOM[1'h0][0];
        ibusCmd_bits = {_RANDOM[1'h0][31:1], _RANDOM[1'h1][0]};
        fault = _RANDOM[1'h1][1];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        ibusCmd_valid = 1'h0;
        ibusCmd_bits = 32'h0;
        fault = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_fetch_valid = ibusCmd_valid;
  assign io_fetch_bits_addr = ibusCmd_bits;
  assign io_fetch_bits_inst_0 = io_ibus_rdata[31:0];
  assign io_fetch_bits_inst_1 = io_ibus_rdata[63:32];
  assign io_fetch_bits_inst_2 = io_ibus_rdata[95:64];
  assign io_fetch_bits_inst_3 = io_ibus_rdata[127:96];
  assign io_fetch_bits_fault = fault;
  assign io_ibus_valid = io_ctrl_valid;
  assign io_ibus_addr = {io_ctrl_bits[31:4], 4'h0};
endmodule

module CircularBufferMulti(
  input         clock,
                reset,
  input  [2:0]  io_enqValid,
  input  [31:0] io_enqData_0_addr,
                io_enqData_0_inst,
  input         io_enqData_0_brchFwd,
  input  [31:0] io_enqData_1_addr,
                io_enqData_1_inst,
  input         io_enqData_1_brchFwd,
  input  [31:0] io_enqData_2_addr,
                io_enqData_2_inst,
  input         io_enqData_2_brchFwd,
  input  [31:0] io_enqData_3_addr,
                io_enqData_3_inst,
  input         io_enqData_3_brchFwd,
  output [3:0]  io_nEnqueued,
                io_nSpace,
  output [31:0] io_dataOut_0_addr,
                io_dataOut_0_inst,
  output        io_dataOut_0_brchFwd,
  output [31:0] io_dataOut_1_addr,
                io_dataOut_1_inst,
  output        io_dataOut_1_brchFwd,
  output [31:0] io_dataOut_2_addr,
                io_dataOut_2_inst,
  output        io_dataOut_2_brchFwd,
  output [31:0] io_dataOut_3_addr,
                io_dataOut_3_inst,
  output        io_dataOut_3_brchFwd,
  input  [2:0]  io_deqReady,
  input         io_flush
);

  reg  [31:0]  buffer_0_addr;
  reg  [31:0]  buffer_0_inst;
  reg          buffer_0_brchFwd;
  reg  [31:0]  buffer_1_addr;
  reg  [31:0]  buffer_1_inst;
  reg          buffer_1_brchFwd;
  reg  [31:0]  buffer_2_addr;
  reg  [31:0]  buffer_2_inst;
  reg          buffer_2_brchFwd;
  reg  [31:0]  buffer_3_addr;
  reg  [31:0]  buffer_3_inst;
  reg          buffer_3_brchFwd;
  reg  [31:0]  buffer_4_addr;
  reg  [31:0]  buffer_4_inst;
  reg          buffer_4_brchFwd;
  reg  [31:0]  buffer_5_addr;
  reg  [31:0]  buffer_5_inst;
  reg          buffer_5_brchFwd;
  reg  [31:0]  buffer_6_addr;
  reg  [31:0]  buffer_6_inst;
  reg          buffer_6_brchFwd;
  reg  [31:0]  buffer_7_addr;
  reg  [31:0]  buffer_7_inst;
  reg          buffer_7_brchFwd;
  reg  [2:0]   enqPtr;
  reg  [2:0]   deqPtr;
  reg  [3:0]   nEnqueued;
  wire [9:0]   _outputBufferView_rotated_T_9 = {7'h0, deqPtr} * 10'h41;
  wire [519:0] _outputBufferView_rotated_T_23 =
    _outputBufferView_rotated_T_9[0]
      ? {buffer_0_brchFwd,
         buffer_7_addr,
         buffer_7_inst,
         buffer_7_brchFwd,
         buffer_6_addr,
         buffer_6_inst,
         buffer_6_brchFwd,
         buffer_5_addr,
         buffer_5_inst,
         buffer_5_brchFwd,
         buffer_4_addr,
         buffer_4_inst,
         buffer_4_brchFwd,
         buffer_3_addr,
         buffer_3_inst,
         buffer_3_brchFwd,
         buffer_2_addr,
         buffer_2_inst,
         buffer_2_brchFwd,
         buffer_1_addr,
         buffer_1_inst,
         buffer_1_brchFwd,
         buffer_0_addr,
         buffer_0_inst}
      : {buffer_7_addr,
         buffer_7_inst,
         buffer_7_brchFwd,
         buffer_6_addr,
         buffer_6_inst,
         buffer_6_brchFwd,
         buffer_5_addr,
         buffer_5_inst,
         buffer_5_brchFwd,
         buffer_4_addr,
         buffer_4_inst,
         buffer_4_brchFwd,
         buffer_3_addr,
         buffer_3_inst,
         buffer_3_brchFwd,
         buffer_2_addr,
         buffer_2_inst,
         buffer_2_brchFwd,
         buffer_1_addr,
         buffer_1_inst,
         buffer_1_brchFwd,
         buffer_0_addr,
         buffer_0_inst,
         buffer_0_brchFwd};
  wire [519:0] _outputBufferView_rotated_T_27 =
    _outputBufferView_rotated_T_9[1]
      ? {_outputBufferView_rotated_T_23[1:0], _outputBufferView_rotated_T_23[519:2]}
      : _outputBufferView_rotated_T_23;
  wire [519:0] _outputBufferView_rotated_T_31 =
    _outputBufferView_rotated_T_9[2]
      ? {_outputBufferView_rotated_T_27[3:0], _outputBufferView_rotated_T_27[519:4]}
      : _outputBufferView_rotated_T_27;
  wire [519:0] _outputBufferView_rotated_T_35 =
    _outputBufferView_rotated_T_9[3]
      ? {_outputBufferView_rotated_T_31[7:0], _outputBufferView_rotated_T_31[519:8]}
      : _outputBufferView_rotated_T_31;
  wire [519:0] _outputBufferView_rotated_T_39 =
    _outputBufferView_rotated_T_9[4]
      ? {_outputBufferView_rotated_T_35[15:0], _outputBufferView_rotated_T_35[519:16]}
      : _outputBufferView_rotated_T_35;
  wire [519:0] _outputBufferView_rotated_T_43 =
    _outputBufferView_rotated_T_9[5]
      ? {_outputBufferView_rotated_T_39[31:0], _outputBufferView_rotated_T_39[519:32]}
      : _outputBufferView_rotated_T_39;
  wire [519:0] _outputBufferView_rotated_T_47 =
    _outputBufferView_rotated_T_9[6]
      ? {_outputBufferView_rotated_T_43[63:0], _outputBufferView_rotated_T_43[519:64]}
      : _outputBufferView_rotated_T_43;
  wire [519:0] _outputBufferView_rotated_T_51 =
    _outputBufferView_rotated_T_9[7]
      ? {_outputBufferView_rotated_T_47[127:0], _outputBufferView_rotated_T_47[519:128]}
      : _outputBufferView_rotated_T_47;
  wire [519:0] _outputBufferView_rotated_T_55 =
    _outputBufferView_rotated_T_9[8]
      ? {_outputBufferView_rotated_T_51[255:0], _outputBufferView_rotated_T_51[519:256]}
      : _outputBufferView_rotated_T_51;
  wire [259:0] outputBufferView_rotated =
    _outputBufferView_rotated_T_9[9]
      ? {_outputBufferView_rotated_T_55[251:0], _outputBufferView_rotated_T_55[519:512]}
      : _outputBufferView_rotated_T_55[259:0];
  wire         expandedInput_2_ret_valid = io_enqValid > 3'h2;
  wire [9:0]   _rotatedInput_rotated_T_17 = {7'h0, enqPtr} * 10'h42;
  wire [527:0] _rotatedInput_rotated_T_31 =
    _rotatedInput_rotated_T_17[0]
      ? {263'h0,
         io_enqValid[2],
         io_enqData_3_addr,
         io_enqData_3_inst,
         io_enqData_3_brchFwd,
         expandedInput_2_ret_valid,
         io_enqData_2_addr,
         io_enqData_2_inst,
         io_enqData_2_brchFwd,
         |(io_enqValid[2:1]),
         io_enqData_1_addr,
         io_enqData_1_inst,
         io_enqData_1_brchFwd,
         |io_enqValid,
         io_enqData_0_addr,
         io_enqData_0_inst,
         io_enqData_0_brchFwd,
         1'h0}
      : {264'h0,
         io_enqValid[2],
         io_enqData_3_addr,
         io_enqData_3_inst,
         io_enqData_3_brchFwd,
         expandedInput_2_ret_valid,
         io_enqData_2_addr,
         io_enqData_2_inst,
         io_enqData_2_brchFwd,
         |(io_enqValid[2:1]),
         io_enqData_1_addr,
         io_enqData_1_inst,
         io_enqData_1_brchFwd,
         |io_enqValid,
         io_enqData_0_addr,
         io_enqData_0_inst,
         io_enqData_0_brchFwd};
  wire [527:0] _rotatedInput_rotated_T_35 =
    _rotatedInput_rotated_T_17[1]
      ? {_rotatedInput_rotated_T_31[525:0], _rotatedInput_rotated_T_31[527:526]}
      : _rotatedInput_rotated_T_31;
  wire [527:0] _rotatedInput_rotated_T_39 =
    _rotatedInput_rotated_T_17[2]
      ? {_rotatedInput_rotated_T_35[523:0], _rotatedInput_rotated_T_35[527:524]}
      : _rotatedInput_rotated_T_35;
  wire [527:0] _rotatedInput_rotated_T_43 =
    _rotatedInput_rotated_T_17[3]
      ? {_rotatedInput_rotated_T_39[519:0], _rotatedInput_rotated_T_39[527:520]}
      : _rotatedInput_rotated_T_39;
  wire [527:0] _rotatedInput_rotated_T_47 =
    _rotatedInput_rotated_T_17[4]
      ? {_rotatedInput_rotated_T_43[511:0], _rotatedInput_rotated_T_43[527:512]}
      : _rotatedInput_rotated_T_43;
  wire [527:0] _rotatedInput_rotated_T_51 =
    _rotatedInput_rotated_T_17[5]
      ? {_rotatedInput_rotated_T_47[495:0], _rotatedInput_rotated_T_47[527:496]}
      : _rotatedInput_rotated_T_47;
  wire [527:0] _rotatedInput_rotated_T_55 =
    _rotatedInput_rotated_T_17[6]
      ? {_rotatedInput_rotated_T_51[463:0], _rotatedInput_rotated_T_51[527:464]}
      : _rotatedInput_rotated_T_51;
  wire [527:0] _rotatedInput_rotated_T_59 =
    _rotatedInput_rotated_T_17[7]
      ? {_rotatedInput_rotated_T_55[399:0], _rotatedInput_rotated_T_55[527:400]}
      : _rotatedInput_rotated_T_55;
  wire [527:0] _rotatedInput_rotated_T_63 =
    _rotatedInput_rotated_T_17[8]
      ? {_rotatedInput_rotated_T_59[271:0], _rotatedInput_rotated_T_59[527:272]}
      : _rotatedInput_rotated_T_59;
  wire [527:0] rotatedInput_rotated =
    _rotatedInput_rotated_T_17[9]
      ? {_rotatedInput_rotated_T_63[15:0], _rotatedInput_rotated_T_63[527:16]}
      : _rotatedInput_rotated_T_63;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      buffer_0_addr <= 32'h0;
      buffer_0_inst <= 32'h0;
      buffer_0_brchFwd <= 1'h0;
      buffer_1_addr <= 32'h0;
      buffer_1_inst <= 32'h0;
      buffer_1_brchFwd <= 1'h0;
      buffer_2_addr <= 32'h0;
      buffer_2_inst <= 32'h0;
      buffer_2_brchFwd <= 1'h0;
      buffer_3_addr <= 32'h0;
      buffer_3_inst <= 32'h0;
      buffer_3_brchFwd <= 1'h0;
      buffer_4_addr <= 32'h0;
      buffer_4_inst <= 32'h0;
      buffer_4_brchFwd <= 1'h0;
      buffer_5_addr <= 32'h0;
      buffer_5_inst <= 32'h0;
      buffer_5_brchFwd <= 1'h0;
      buffer_6_addr <= 32'h0;
      buffer_6_inst <= 32'h0;
      buffer_6_brchFwd <= 1'h0;
      buffer_7_addr <= 32'h0;
      buffer_7_inst <= 32'h0;
      buffer_7_brchFwd <= 1'h0;
      enqPtr <= 3'h0;
      deqPtr <= 3'h0;
      nEnqueued <= 4'h0;
    end
    else begin
      if (rotatedInput_rotated[65]) begin
        buffer_0_addr <= rotatedInput_rotated[64:33];
        buffer_0_inst <= rotatedInput_rotated[32:1];
        buffer_0_brchFwd <= rotatedInput_rotated[0];
      end
      if (rotatedInput_rotated[131]) begin
        buffer_1_addr <= rotatedInput_rotated[130:99];
        buffer_1_inst <= rotatedInput_rotated[98:67];
        buffer_1_brchFwd <= rotatedInput_rotated[66];
      end
      if (rotatedInput_rotated[197]) begin
        buffer_2_addr <= rotatedInput_rotated[196:165];
        buffer_2_inst <= rotatedInput_rotated[164:133];
        buffer_2_brchFwd <= rotatedInput_rotated[132];
      end
      if (rotatedInput_rotated[263]) begin
        buffer_3_addr <= rotatedInput_rotated[262:231];
        buffer_3_inst <= rotatedInput_rotated[230:199];
        buffer_3_brchFwd <= rotatedInput_rotated[198];
      end
      if (rotatedInput_rotated[329]) begin
        buffer_4_addr <= rotatedInput_rotated[328:297];
        buffer_4_inst <= rotatedInput_rotated[296:265];
        buffer_4_brchFwd <= rotatedInput_rotated[264];
      end
      if (rotatedInput_rotated[395]) begin
        buffer_5_addr <= rotatedInput_rotated[394:363];
        buffer_5_inst <= rotatedInput_rotated[362:331];
        buffer_5_brchFwd <= rotatedInput_rotated[330];
      end
      if (rotatedInput_rotated[461]) begin
        buffer_6_addr <= rotatedInput_rotated[460:429];
        buffer_6_inst <= rotatedInput_rotated[428:397];
        buffer_6_brchFwd <= rotatedInput_rotated[396];
      end
      if (rotatedInput_rotated[527]) begin
        buffer_7_addr <= rotatedInput_rotated[526:495];
        buffer_7_inst <= rotatedInput_rotated[494:463];
        buffer_7_brchFwd <= rotatedInput_rotated[462];
      end
      enqPtr <= io_flush ? 3'h0 : enqPtr + io_enqValid;
      deqPtr <= io_flush ? 3'h0 : deqPtr + io_deqReady;
      nEnqueued <=
        io_flush ? 4'h0 : nEnqueued + {1'h0, io_enqValid} - {1'h0, io_deqReady};
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:16];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [4:0] i = 5'h0; i < 5'h11; i += 5'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        buffer_0_addr = _RANDOM[5'h0];
        buffer_0_inst = _RANDOM[5'h1];
        buffer_0_brchFwd = _RANDOM[5'h2][0];
        buffer_1_addr = {_RANDOM[5'h2][31:1], _RANDOM[5'h3][0]};
        buffer_1_inst = {_RANDOM[5'h3][31:1], _RANDOM[5'h4][0]};
        buffer_1_brchFwd = _RANDOM[5'h4][1];
        buffer_2_addr = {_RANDOM[5'h4][31:2], _RANDOM[5'h5][1:0]};
        buffer_2_inst = {_RANDOM[5'h5][31:2], _RANDOM[5'h6][1:0]};
        buffer_2_brchFwd = _RANDOM[5'h6][2];
        buffer_3_addr = {_RANDOM[5'h6][31:3], _RANDOM[5'h7][2:0]};
        buffer_3_inst = {_RANDOM[5'h7][31:3], _RANDOM[5'h8][2:0]};
        buffer_3_brchFwd = _RANDOM[5'h8][3];
        buffer_4_addr = {_RANDOM[5'h8][31:4], _RANDOM[5'h9][3:0]};
        buffer_4_inst = {_RANDOM[5'h9][31:4], _RANDOM[5'hA][3:0]};
        buffer_4_brchFwd = _RANDOM[5'hA][4];
        buffer_5_addr = {_RANDOM[5'hA][31:5], _RANDOM[5'hB][4:0]};
        buffer_5_inst = {_RANDOM[5'hB][31:5], _RANDOM[5'hC][4:0]};
        buffer_5_brchFwd = _RANDOM[5'hC][5];
        buffer_6_addr = {_RANDOM[5'hC][31:6], _RANDOM[5'hD][5:0]};
        buffer_6_inst = {_RANDOM[5'hD][31:6], _RANDOM[5'hE][5:0]};
        buffer_6_brchFwd = _RANDOM[5'hE][6];
        buffer_7_addr = {_RANDOM[5'hE][31:7], _RANDOM[5'hF][6:0]};
        buffer_7_inst = {_RANDOM[5'hF][31:7], _RANDOM[5'h10][6:0]};
        buffer_7_brchFwd = _RANDOM[5'h10][7];
        enqPtr = _RANDOM[5'h10][10:8];
        deqPtr = _RANDOM[5'h10][13:11];
        nEnqueued = _RANDOM[5'h10][17:14];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        buffer_0_addr = 32'h0;
        buffer_0_inst = 32'h0;
        buffer_0_brchFwd = 1'h0;
        buffer_1_addr = 32'h0;
        buffer_1_inst = 32'h0;
        buffer_1_brchFwd = 1'h0;
        buffer_2_addr = 32'h0;
        buffer_2_inst = 32'h0;
        buffer_2_brchFwd = 1'h0;
        buffer_3_addr = 32'h0;
        buffer_3_inst = 32'h0;
        buffer_3_brchFwd = 1'h0;
        buffer_4_addr = 32'h0;
        buffer_4_inst = 32'h0;
        buffer_4_brchFwd = 1'h0;
        buffer_5_addr = 32'h0;
        buffer_5_inst = 32'h0;
        buffer_5_brchFwd = 1'h0;
        buffer_6_addr = 32'h0;
        buffer_6_inst = 32'h0;
        buffer_6_brchFwd = 1'h0;
        buffer_7_addr = 32'h0;
        buffer_7_inst = 32'h0;
        buffer_7_brchFwd = 1'h0;
        enqPtr = 3'h0;
        deqPtr = 3'h0;
        nEnqueued = 4'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_nEnqueued = nEnqueued;
  assign io_nSpace = 4'h8 - nEnqueued;
  assign io_dataOut_0_addr = outputBufferView_rotated[64:33];
  assign io_dataOut_0_inst = outputBufferView_rotated[32:1];
  assign io_dataOut_0_brchFwd = outputBufferView_rotated[0];
  assign io_dataOut_1_addr = outputBufferView_rotated[129:98];
  assign io_dataOut_1_inst = outputBufferView_rotated[97:66];
  assign io_dataOut_1_brchFwd = outputBufferView_rotated[65];
  assign io_dataOut_2_addr = outputBufferView_rotated[194:163];
  assign io_dataOut_2_inst = outputBufferView_rotated[162:131];
  assign io_dataOut_2_brchFwd = outputBufferView_rotated[130];
  assign io_dataOut_3_addr = outputBufferView_rotated[259:228];
  assign io_dataOut_3_inst = outputBufferView_rotated[227:196];
  assign io_dataOut_3_brchFwd = outputBufferView_rotated[195];
endmodule

module InstructionBuffer(
  input         clock,
                reset,
  output [2:0]  io_feedIn_nReady,
  input  [2:0]  io_feedIn_nValid,
  input  [31:0] io_feedIn_bits_0_addr,
                io_feedIn_bits_0_inst,
  input         io_feedIn_bits_0_brchFwd,
  input  [31:0] io_feedIn_bits_1_addr,
                io_feedIn_bits_1_inst,
  input         io_feedIn_bits_1_brchFwd,
  input  [31:0] io_feedIn_bits_2_addr,
                io_feedIn_bits_2_inst,
  input         io_feedIn_bits_2_brchFwd,
  input  [31:0] io_feedIn_bits_3_addr,
                io_feedIn_bits_3_inst,
  input         io_feedIn_bits_3_brchFwd,
                io_out_0_ready,
  output        io_out_0_valid,
  output [31:0] io_out_0_bits_addr,
                io_out_0_bits_inst,
  output        io_out_0_bits_brchFwd,
  input         io_out_1_ready,
  output        io_out_1_valid,
  output [31:0] io_out_1_bits_addr,
                io_out_1_bits_inst,
  output        io_out_1_bits_brchFwd,
  input         io_out_2_ready,
  output        io_out_2_valid,
  output [31:0] io_out_2_bits_addr,
                io_out_2_bits_inst,
  output        io_out_2_bits_brchFwd,
  input         io_out_3_ready,
  output        io_out_3_valid,
  output [31:0] io_out_3_bits_addr,
                io_out_3_bits_inst,
  output        io_out_3_bits_brchFwd,
  input         io_flush,
  output [3:0]  io_nEnqueued,
                io_nSpace
);

  wire [3:0] _circularBuffer_io_nEnqueued;
  wire [3:0] _circularBuffer_io_nSpace;
  wire       io_out_0_valid_0 = (|_circularBuffer_io_nEnqueued) & ~io_flush;
  wire       io_out_1_valid_0 = (|(_circularBuffer_io_nEnqueued[3:1])) & ~io_flush;
  wire       io_out_2_valid_0 = _circularBuffer_io_nEnqueued > 4'h2 & ~io_flush;
  wire       io_out_3_valid_0 = (|(_circularBuffer_io_nEnqueued[3:2])) & ~io_flush;
  wire       _nReady_T = io_out_0_ready & io_out_0_valid_0;
  wire       _nReady_T_1 = io_out_1_ready & io_out_1_valid_0;
  wire       _nReady_T_2 = io_out_2_ready & io_out_2_valid_0;
  wire       _nReady_T_3 = io_out_3_ready & io_out_3_valid_0;
  CircularBufferMulti circularBuffer (
    .clock                (clock),
    .reset                (reset),
    .io_enqValid          (io_feedIn_nValid),
    .io_enqData_0_addr    (io_feedIn_bits_0_addr),
    .io_enqData_0_inst    (io_feedIn_bits_0_inst),
    .io_enqData_0_brchFwd (io_feedIn_bits_0_brchFwd),
    .io_enqData_1_addr    (io_feedIn_bits_1_addr),
    .io_enqData_1_inst    (io_feedIn_bits_1_inst),
    .io_enqData_1_brchFwd (io_feedIn_bits_1_brchFwd),
    .io_enqData_2_addr    (io_feedIn_bits_2_addr),
    .io_enqData_2_inst    (io_feedIn_bits_2_inst),
    .io_enqData_2_brchFwd (io_feedIn_bits_2_brchFwd),
    .io_enqData_3_addr    (io_feedIn_bits_3_addr),
    .io_enqData_3_inst    (io_feedIn_bits_3_inst),
    .io_enqData_3_brchFwd (io_feedIn_bits_3_brchFwd),
    .io_nEnqueued         (_circularBuffer_io_nEnqueued),
    .io_nSpace            (_circularBuffer_io_nSpace),
    .io_dataOut_0_addr    (io_out_0_bits_addr),
    .io_dataOut_0_inst    (io_out_0_bits_inst),
    .io_dataOut_0_brchFwd (io_out_0_bits_brchFwd),
    .io_dataOut_1_addr    (io_out_1_bits_addr),
    .io_dataOut_1_inst    (io_out_1_bits_inst),
    .io_dataOut_1_brchFwd (io_out_1_bits_brchFwd),
    .io_dataOut_2_addr    (io_out_2_bits_addr),
    .io_dataOut_2_inst    (io_out_2_bits_inst),
    .io_dataOut_2_brchFwd (io_out_2_bits_brchFwd),
    .io_dataOut_3_addr    (io_out_3_bits_addr),
    .io_dataOut_3_inst    (io_out_3_bits_inst),
    .io_dataOut_3_brchFwd (io_out_3_bits_brchFwd),
    .io_deqReady
      ({1'h0, {1'h0, _nReady_T} + {1'h0, _nReady_T_1}}
       + {1'h0, {1'h0, _nReady_T_2} + {1'h0, _nReady_T_3}}),
    .io_flush             (io_flush)
  );
  assign io_feedIn_nReady =
    _circularBuffer_io_nSpace < 4'h4 ? _circularBuffer_io_nSpace[2:0] : 3'h4;
  assign io_out_0_valid = io_out_0_valid_0;
  assign io_out_1_valid = io_out_1_valid_0;
  assign io_out_2_valid = io_out_2_valid_0;
  assign io_out_3_valid = io_out_3_valid_0;
  assign io_nEnqueued = _circularBuffer_io_nEnqueued;
  assign io_nSpace = _circularBuffer_io_nSpace;
endmodule

module UncachedFetch(
  input          clock,
                 reset,
  input  [31:0]  io_csr_value_0,
  output         io_ibus_valid,
  input          io_ibus_ready,
  output [31:0]  io_ibus_addr,
  input  [127:0] io_ibus_rdata,
  input          io_ibus_fault_valid,
                 io_inst_lanes_0_ready,
  output         io_inst_lanes_0_valid,
  output [31:0]  io_inst_lanes_0_bits_addr,
                 io_inst_lanes_0_bits_inst,
  output         io_inst_lanes_0_bits_brchFwd,
  input          io_inst_lanes_1_ready,
  output         io_inst_lanes_1_valid,
  output [31:0]  io_inst_lanes_1_bits_addr,
                 io_inst_lanes_1_bits_inst,
  output         io_inst_lanes_1_bits_brchFwd,
  input          io_branch_0_valid,
  input  [31:0]  io_branch_0_value,
  input          io_branch_1_valid,
  input  [31:0]  io_branch_1_value,
  input          io_iflush_valid,
  input  [31:0]  io_iflush_pcNext,
  output [31:0]  io_pc,
  output         io_fault
);

  wire        _instructionBuffer_io_out_0_valid;
  wire [31:0] _instructionBuffer_io_out_0_bits_addr;
  wire [3:0]  _instructionBuffer_io_nSpace;
  wire        _fetcher_io_fetch_valid;
  wire [31:0] _fetcher_io_fetch_bits_addr;
  wire [31:0] _fetcher_io_fetch_bits_inst_0;
  wire [31:0] _fetcher_io_fetch_bits_inst_1;
  wire [31:0] _fetcher_io_fetch_bits_inst_2;
  wire [31:0] _fetcher_io_fetch_bits_inst_3;
  wire        _fetcher_io_fetch_bits_fault;
  wire        _ctrl_io_fetchAddr_valid;
  wire [31:0] _ctrl_io_fetchAddr_bits;
  wire [2:0]  _ctrl_io_bufferRequest_nValid;
  wire [31:0] _ctrl_io_bufferRequest_bits_0_addr;
  wire [31:0] _ctrl_io_bufferRequest_bits_0_inst;
  wire        _ctrl_io_bufferRequest_bits_0_brchFwd;
  wire [31:0] _ctrl_io_bufferRequest_bits_1_addr;
  wire [31:0] _ctrl_io_bufferRequest_bits_1_inst;
  wire        _ctrl_io_bufferRequest_bits_1_brchFwd;
  wire [31:0] _ctrl_io_bufferRequest_bits_2_addr;
  wire [31:0] _ctrl_io_bufferRequest_bits_2_inst;
  wire        _ctrl_io_bufferRequest_bits_2_brchFwd;
  wire [31:0] _ctrl_io_bufferRequest_bits_3_addr;
  wire [31:0] _ctrl_io_bufferRequest_bits_3_inst;
  wire        _ctrl_io_bufferRequest_bits_3_brchFwd;
  wire        branch_valid = io_branch_0_valid | io_branch_1_valid;
  reg  [31:0] pc;
  always @(posedge clock or posedge reset) begin
    if (reset)
      pc <= 32'h0;
    else if (_instructionBuffer_io_out_0_valid)
      pc <= _instructionBuffer_io_out_0_bits_addr;
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        pc = _RANDOM[/*Zero width*/ 1'b0];
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        pc = 32'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  FetchControl ctrl (
    .clock                           (clock),
    .reset                           (reset),
    .io_fetchFault                   (io_fault),
    .io_csr_value_0                  (io_csr_value_0),
    .io_iflush_valid                 (io_iflush_valid),
    .io_iflush_bits                  (io_iflush_pcNext),
    .io_branch_valid                 (branch_valid),
    .io_branch_bits
      (io_branch_0_valid
         ? io_branch_0_value
         : io_branch_1_valid ? io_branch_1_value : 32'h0),
    .io_fetchData_valid              (_fetcher_io_fetch_valid),
    .io_fetchData_bits_addr          (_fetcher_io_fetch_bits_addr),
    .io_fetchData_bits_inst_0        (_fetcher_io_fetch_bits_inst_0),
    .io_fetchData_bits_inst_1        (_fetcher_io_fetch_bits_inst_1),
    .io_fetchData_bits_inst_2        (_fetcher_io_fetch_bits_inst_2),
    .io_fetchData_bits_inst_3        (_fetcher_io_fetch_bits_inst_3),
    .io_fetchData_bits_fault         (_fetcher_io_fetch_bits_fault),
    .io_fetchAddr_valid              (_ctrl_io_fetchAddr_valid),
    .io_fetchAddr_bits               (_ctrl_io_fetchAddr_bits),
    .io_bufferRequest_nValid         (_ctrl_io_bufferRequest_nValid),
    .io_bufferRequest_bits_0_addr    (_ctrl_io_bufferRequest_bits_0_addr),
    .io_bufferRequest_bits_0_inst    (_ctrl_io_bufferRequest_bits_0_inst),
    .io_bufferRequest_bits_0_brchFwd (_ctrl_io_bufferRequest_bits_0_brchFwd),
    .io_bufferRequest_bits_1_addr    (_ctrl_io_bufferRequest_bits_1_addr),
    .io_bufferRequest_bits_1_inst    (_ctrl_io_bufferRequest_bits_1_inst),
    .io_bufferRequest_bits_1_brchFwd (_ctrl_io_bufferRequest_bits_1_brchFwd),
    .io_bufferRequest_bits_2_addr    (_ctrl_io_bufferRequest_bits_2_addr),
    .io_bufferRequest_bits_2_inst    (_ctrl_io_bufferRequest_bits_2_inst),
    .io_bufferRequest_bits_2_brchFwd (_ctrl_io_bufferRequest_bits_2_brchFwd),
    .io_bufferRequest_bits_3_addr    (_ctrl_io_bufferRequest_bits_3_addr),
    .io_bufferRequest_bits_3_inst    (_ctrl_io_bufferRequest_bits_3_inst),
    .io_bufferRequest_bits_3_brchFwd (_ctrl_io_bufferRequest_bits_3_brchFwd),
    .io_bufferSpaces                 (_instructionBuffer_io_nSpace)
  );
  Fetcher fetcher (
    .clock                (clock),
    .reset                (reset),
    .io_ctrl_valid        (_ctrl_io_fetchAddr_valid),
    .io_ctrl_bits         (_ctrl_io_fetchAddr_bits),
    .io_fetch_valid       (_fetcher_io_fetch_valid),
    .io_fetch_bits_addr   (_fetcher_io_fetch_bits_addr),
    .io_fetch_bits_inst_0 (_fetcher_io_fetch_bits_inst_0),
    .io_fetch_bits_inst_1 (_fetcher_io_fetch_bits_inst_1),
    .io_fetch_bits_inst_2 (_fetcher_io_fetch_bits_inst_2),
    .io_fetch_bits_inst_3 (_fetcher_io_fetch_bits_inst_3),
    .io_fetch_bits_fault  (_fetcher_io_fetch_bits_fault),
    .io_ibus_valid        (io_ibus_valid),
    .io_ibus_ready        (io_ibus_ready),
    .io_ibus_addr         (io_ibus_addr),
    .io_ibus_rdata        (io_ibus_rdata),
    .io_ibus_fault_valid  (io_ibus_fault_valid)
  );
  InstructionBuffer instructionBuffer (
    .clock                    (clock),
    .reset                    (reset),
    .io_feedIn_nReady         (/* unused */),
    .io_feedIn_nValid         (_ctrl_io_bufferRequest_nValid),
    .io_feedIn_bits_0_addr    (_ctrl_io_bufferRequest_bits_0_addr),
    .io_feedIn_bits_0_inst    (_ctrl_io_bufferRequest_bits_0_inst),
    .io_feedIn_bits_0_brchFwd (_ctrl_io_bufferRequest_bits_0_brchFwd),
    .io_feedIn_bits_1_addr    (_ctrl_io_bufferRequest_bits_1_addr),
    .io_feedIn_bits_1_inst    (_ctrl_io_bufferRequest_bits_1_inst),
    .io_feedIn_bits_1_brchFwd (_ctrl_io_bufferRequest_bits_1_brchFwd),
    .io_feedIn_bits_2_addr    (_ctrl_io_bufferRequest_bits_2_addr),
    .io_feedIn_bits_2_inst    (_ctrl_io_bufferRequest_bits_2_inst),
    .io_feedIn_bits_2_brchFwd (_ctrl_io_bufferRequest_bits_2_brchFwd),
    .io_feedIn_bits_3_addr    (_ctrl_io_bufferRequest_bits_3_addr),
    .io_feedIn_bits_3_inst    (_ctrl_io_bufferRequest_bits_3_inst),
    .io_feedIn_bits_3_brchFwd (_ctrl_io_bufferRequest_bits_3_brchFwd),
    .io_out_0_ready           (io_inst_lanes_0_ready),
    .io_out_0_valid           (_instructionBuffer_io_out_0_valid),
    .io_out_0_bits_addr       (_instructionBuffer_io_out_0_bits_addr),
    .io_out_0_bits_inst       (io_inst_lanes_0_bits_inst),
    .io_out_0_bits_brchFwd    (io_inst_lanes_0_bits_brchFwd),
    .io_out_1_ready           (io_inst_lanes_1_ready),
    .io_out_1_valid           (io_inst_lanes_1_valid),
    .io_out_1_bits_addr       (io_inst_lanes_1_bits_addr),
    .io_out_1_bits_inst       (io_inst_lanes_1_bits_inst),
    .io_out_1_bits_brchFwd    (io_inst_lanes_1_bits_brchFwd),
    .io_out_2_ready           (1'h0),
    .io_out_2_valid           (/* unused */),
    .io_out_2_bits_addr       (/* unused */),
    .io_out_2_bits_inst       (/* unused */),
    .io_out_2_bits_brchFwd    (/* unused */),
    .io_out_3_ready           (1'h0),
    .io_out_3_valid           (/* unused */),
    .io_out_3_bits_addr       (/* unused */),
    .io_out_3_bits_inst       (/* unused */),
    .io_out_3_bits_brchFwd    (/* unused */),
    .io_flush                 (io_iflush_valid | branch_valid),
    .io_nEnqueued             (/* unused */),
    .io_nSpace                (_instructionBuffer_io_nSpace)
  );
  assign io_inst_lanes_0_valid = _instructionBuffer_io_out_0_valid;
  assign io_inst_lanes_0_bits_addr = _instructionBuffer_io_out_0_bits_addr;
  assign io_pc = pc;
endmodule

module Csr(
  input         clock,
                reset,
  input  [31:0] io_csr_in_value_12,
  output [31:0] io_csr_out_value_0,
                io_csr_out_value_1,
                io_csr_out_value_2,
                io_csr_out_value_3,
                io_csr_out_value_4,
                io_csr_out_value_5,
                io_csr_out_value_6,
                io_csr_out_value_7,
                io_csr_out_value_8,
  input         io_req_valid,
  input  [4:0]  io_req_bits_addr,
  input  [11:0] io_req_bits_index,
  input  [1:0]  io_req_bits_op,
  input         io_rs1_valid,
  input  [31:0] io_rs1_data,
  output        io_rd_valid,
  output [4:0]  io_rd_bits_addr,
  output [31:0] io_rd_bits_data,
  input         io_bru_in_mode_valid,
  input  [1:0]  io_bru_in_mode_bits,
  input         io_bru_in_mcause_valid,
  input  [31:0] io_bru_in_mcause_bits,
  input         io_bru_in_mepc_valid,
  input  [31:0] io_bru_in_mepc_bits,
  input         io_bru_in_mtval_valid,
  input  [31:0] io_bru_in_mtval_bits,
  input         io_bru_in_halt,
                io_bru_in_fault,
                io_bru_in_wfi,
  output [1:0]  io_bru_out_mode,
  output [31:0] io_bru_out_mepc,
                io_bru_out_mtvec,
  input         io_float_in_fflags_valid,
  input  [4:0]  io_float_in_fflags_bits,
  output [2:0]  io_float_out_frm,
  input  [2:0]  io_counters_rfwriteCount,
  input         io_counters_branchCount,
  output        io_halted,
                io_fault,
                io_wfi,
  input         io_irq
);

  reg              req_pipe_v;
  reg  [4:0]       req_pipe_b_addr;
  reg  [11:0]      req_pipe_b_index;
  reg  [1:0]       req_pipe_b_op;
  reg              halted;
  reg              fault;
  reg              wfi;
  reg  [1:0]       mode;
  reg  [31:0]      mpc;
  reg  [31:0]      msp;
  reg  [31:0]      mcause;
  reg  [31:0]      mtval;
  reg  [31:0]      mcontext0;
  reg  [31:0]      mcontext1;
  reg  [31:0]      mcontext2;
  reg  [31:0]      mcontext3;
  reg  [31:0]      mcontext4;
  reg  [31:0]      mcontext5;
  reg  [31:0]      mcontext6;
  reg  [31:0]      mcontext7;
  reg  [4:0]       fflags;
  reg  [2:0]       frm;
  reg              mie;
  reg  [31:0]      mtvec;
  reg  [31:0]      mscratch;
  reg  [31:0]      mepc;
  reg  [1:0]       mpp;
  reg  [63:0]      mcycle;
  reg  [63:0]      minstret;
  wire             fflagsEn = req_pipe_b_index == 12'h1;
  wire             frmEn = req_pipe_b_index == 12'h2;
  wire             fcsrEn = req_pipe_b_index == 12'h3;
  wire             mstatusEn = req_pipe_b_index == 12'h300;
  wire             misaEn = req_pipe_b_index == 12'h301;
  wire             mieEn = req_pipe_b_index == 12'h304;
  wire             mtvecEn = req_pipe_b_index == 12'h305;
  wire             mscratchEn = req_pipe_b_index == 12'h340;
  wire             mepcEn = req_pipe_b_index == 12'h341;
  wire             mcauseEn = req_pipe_b_index == 12'h342;
  wire             mtvalEn = req_pipe_b_index == 12'h343;
  wire             mcontext0En = req_pipe_b_index == 12'h7C0;
  wire             mcontext1En = req_pipe_b_index == 12'h7C1;
  wire             mcontext2En = req_pipe_b_index == 12'h7C2;
  wire             mcontext3En = req_pipe_b_index == 12'h7C3;
  wire             mcontext4En = req_pipe_b_index == 12'h7C4;
  wire             mcontext5En = req_pipe_b_index == 12'h7C5;
  wire             mcontext6En = req_pipe_b_index == 12'h7C6;
  wire             mcontext7En = req_pipe_b_index == 12'h7C7;
  wire             mpcEn = req_pipe_b_index == 12'h7E0;
  wire             mspEn = req_pipe_b_index == 12'h7E1;
  wire             mcycleEn = req_pipe_b_index == 12'hB00;
  wire             minstretEn = req_pipe_b_index == 12'hB02;
  wire             mcyclehEn = req_pipe_b_index == 12'hB80;
  wire             minstrethEn = req_pipe_b_index == 12'hB82;
  wire             mvendoridEn = req_pipe_b_index == 12'hF11;
  wire             marchidEn = req_pipe_b_index == 12'hF12;
  wire             mimpidEn = req_pipe_b_index == 12'hF13;
  wire             mhartidEn = req_pipe_b_index == 12'hF14;
  wire             kisaEn = req_pipe_b_index == 12'hFC0;
  wire             kscm0En = req_pipe_b_index == 12'hFC4;
  wire             kscm1En = req_pipe_b_index == 12'hFC8;
  wire             kscm2En = req_pipe_b_index == 12'hFCC;
  wire             kscm3En = req_pipe_b_index == 12'hFD0;
  wire             kscm4En = req_pipe_b_index == 12'hFD4;
  wire [31:0]      rdata =
    fflagsEn
      ? {27'h0, fflags}
      : frmEn
          ? {29'h0, frm}
          : fcsrEn
              ? {24'h0, frm, fflags}
              : mstatusEn
                  ? {19'h1, mpp, 11'h0}
                  : misaEn
                      ? 32'h40001120
                      : mieEn
                          ? {31'h0, mie}
                          : mtvecEn
                              ? mtvec
                              : mscratchEn
                                  ? mscratch
                                  : mepcEn
                                      ? mepc
                                      : mcauseEn
                                          ? mcause
                                          : mtvalEn
                                              ? mtval
                                              : mcontext0En
                                                  ? mcontext0
                                                  : mcontext1En
                                                      ? mcontext1
                                                      : mcontext2En
                                                          ? mcontext2
                                                          : mcontext3En
                                                              ? mcontext3
                                                              : mcontext4En
                                                                  ? mcontext4
                                                                  : mcontext5En
                                                                      ? mcontext5
                                                                      : mcontext6En
                                                                          ? mcontext6
                                                                          : mcontext7En
                                                                              ? mcontext7
                                                                              : mpcEn
                                                                                  ? mpc
                                                                                  : mspEn
                                                                                      ? msp
                                                                                      : mcycleEn
                                                                                          ? mcycle[31:0]
                                                                                          : mcyclehEn
                                                                                              ? mcycle[63:32]
                                                                                              : minstretEn
                                                                                                  ? minstret[31:0]
                                                                                                  : minstrethEn
                                                                                                      ? minstret[63:32]
                                                                                                      : mvendoridEn
                                                                                                          ? 32'h426
                                                                                                          : marchidEn
                                                                                                            | mimpidEn
                                                                                                            | mhartidEn
                                                                                                            | kisaEn
                                                                                                              ? 32'h0
                                                                                                              : kscm0En
                                                                                                                  ? 32'hB310F546
                                                                                                                  : kscm1En
                                                                                                                      ? 32'h18E07B4
                                                                                                                      : kscm2En
                                                                                                                          ? 32'hDEA31934
                                                                                                                          : kscm3En
                                                                                                                              ? 32'h587A8764
                                                                                                                              : kscm4En
                                                                                                                                  ? 32'hFA89CD7B
                                                                                                                                  : 32'h0;
  wire [3:0][31:0] _GEN =
    {{32'h0}, {rdata & ~io_rs1_data}, {rdata | io_rs1_data}, {io_rs1_data}};
  wire [31:0]      wdata = _GEN[req_pipe_b_op];
  wire [2:0]       _minstretThisCycle_T_2 =
    io_counters_rfwriteCount + {2'h0, io_counters_branchCount};
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      req_pipe_v <= 1'h0;
      halted <= 1'h0;
      fault <= 1'h0;
      wfi <= 1'h0;
      mode <= 2'h0;
      mpc <= 32'h0;
      msp <= 32'h0;
      mcause <= 32'h0;
      mtval <= 32'h0;
      mcontext0 <= 32'h0;
      mcontext1 <= 32'h0;
      mcontext2 <= 32'h0;
      mcontext3 <= 32'h0;
      mcontext4 <= 32'h0;
      mcontext5 <= 32'h0;
      mcontext6 <= 32'h0;
      mcontext7 <= 32'h0;
      fflags <= 5'h0;
      frm <= 3'h0;
      mie <= 1'h0;
      mtvec <= 32'h0;
      mscratch <= 32'h0;
      mepc <= 32'h0;
      mpp <= 2'h0;
      mcycle <= 64'h0;
      minstret <= 64'h0;
    end
    else begin
      req_pipe_v <= io_req_valid;
      halted <= io_bru_in_halt | halted;
      fault <= io_bru_in_fault | fault;
      if (wfi)
        wfi <= ~io_irq;
      else
        wfi <= io_bru_in_wfi;
      if (io_bru_in_mode_valid)
        mode <= io_bru_in_mode_bits;
      if (req_pipe_v & mpcEn)
        mpc <= wdata;
      if (req_pipe_v & mspEn)
        msp <= wdata;
      if (io_bru_in_mcause_valid)
        mcause <= io_bru_in_mcause_bits;
      else if (req_pipe_v & mcauseEn)
        mcause <= wdata;
      if (io_bru_in_mtval_valid)
        mtval <= io_bru_in_mtval_bits;
      else if (req_pipe_v & mtvalEn)
        mtval <= wdata;
      if (req_pipe_v & mcontext0En)
        mcontext0 <= wdata;
      if (req_pipe_v & mcontext1En)
        mcontext1 <= wdata;
      if (req_pipe_v & mcontext2En)
        mcontext2 <= wdata;
      if (req_pipe_v & mcontext3En)
        mcontext3 <= wdata;
      if (req_pipe_v & mcontext4En)
        mcontext4 <= wdata;
      if (req_pipe_v & mcontext5En)
        mcontext5 <= wdata;
      if (req_pipe_v & mcontext6En)
        mcontext6 <= wdata;
      if (req_pipe_v & mcontext7En)
        mcontext7 <= wdata;
      if (io_float_in_fflags_valid)
        fflags <= io_float_in_fflags_bits | fflags;
      else if (req_pipe_v) begin
        if (fcsrEn)
          fflags <= wdata[4:0];
        else if (fflagsEn)
          fflags <= wdata[4:0];
      end
      if (req_pipe_v) begin
        if (fcsrEn)
          frm <= wdata[7:5];
        else if (frmEn)
          frm <= wdata[2:0];
        minstret <=
          {minstrethEn ? wdata : minstret[63:32], minstretEn ? wdata : minstret[31:0]};
      end
      else if (|_minstretThisCycle_T_2)
        minstret <= minstret + {61'h0, _minstretThisCycle_T_2};
      if (req_pipe_v & mieEn)
        mie <= wdata[0];
      if (req_pipe_v & mtvecEn)
        mtvec <= wdata;
      if (req_pipe_v & mscratchEn)
        mscratch <= wdata;
      if (io_bru_in_mepc_valid)
        mepc <= io_bru_in_mepc_bits;
      else if (req_pipe_v & mepcEn)
        mepc <= wdata;
      if (req_pipe_v & mstatusEn)
        mpp <= wdata[12:11];
      mcycle <=
        (req_pipe_v
           ? {mcyclehEn ? wdata : mcycle[63:32], mcycleEn ? wdata : mcycle[31:0]}
           : mcycle) + 64'h1;
    end
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (io_req_valid) begin
      req_pipe_b_addr <= io_req_bits_addr;
      req_pipe_b_index <= io_req_bits_index;
      req_pipe_b_op <= io_req_bits_op;
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:21];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [4:0] i = 5'h0; i < 5'h16; i += 5'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        req_pipe_v = _RANDOM[5'h0][0];
        req_pipe_b_addr = _RANDOM[5'h0][5:1];
        req_pipe_b_index = _RANDOM[5'h0][17:6];
        req_pipe_b_op = _RANDOM[5'h0][19:18];
        halted = _RANDOM[5'h0][20];
        fault = _RANDOM[5'h0][21];
        wfi = _RANDOM[5'h0][22];
        mode = _RANDOM[5'h0][24:23];
        mpc = {_RANDOM[5'h0][31:25], _RANDOM[5'h1][24:0]};
        msp = {_RANDOM[5'h1][31:25], _RANDOM[5'h2][24:0]};
        mcause = {_RANDOM[5'h2][31:25], _RANDOM[5'h3][24:0]};
        mtval = {_RANDOM[5'h3][31:25], _RANDOM[5'h4][24:0]};
        mcontext0 = {_RANDOM[5'h4][31:25], _RANDOM[5'h5][24:0]};
        mcontext1 = {_RANDOM[5'h5][31:25], _RANDOM[5'h6][24:0]};
        mcontext2 = {_RANDOM[5'h6][31:25], _RANDOM[5'h7][24:0]};
        mcontext3 = {_RANDOM[5'h7][31:25], _RANDOM[5'h8][24:0]};
        mcontext4 = {_RANDOM[5'h8][31:25], _RANDOM[5'h9][24:0]};
        mcontext5 = {_RANDOM[5'h9][31:25], _RANDOM[5'hA][24:0]};
        mcontext6 = {_RANDOM[5'hA][31:25], _RANDOM[5'hB][24:0]};
        mcontext7 = {_RANDOM[5'hB][31:25], _RANDOM[5'hC][24:0]};
        fflags = _RANDOM[5'hC][29:25];
        frm = {_RANDOM[5'hC][31:30], _RANDOM[5'hD][0]};
        mie = _RANDOM[5'hD][1];
        mtvec = {_RANDOM[5'hD][31:2], _RANDOM[5'hE][1:0]};
        mscratch = {_RANDOM[5'hE][31:2], _RANDOM[5'hF][1:0]};
        mepc = {_RANDOM[5'hF][31:2], _RANDOM[5'h10][1:0]};
        mpp = _RANDOM[5'h10][3:2];
        mcycle = {_RANDOM[5'h11][31:4], _RANDOM[5'h12], _RANDOM[5'h13][3:0]};
        minstret = {_RANDOM[5'h13][31:4], _RANDOM[5'h14], _RANDOM[5'h15][3:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        req_pipe_v = 1'h0;
        halted = 1'h0;
        fault = 1'h0;
        wfi = 1'h0;
        mode = 2'h0;
        mpc = 32'h0;
        msp = 32'h0;
        mcause = 32'h0;
        mtval = 32'h0;
        mcontext0 = 32'h0;
        mcontext1 = 32'h0;
        mcontext2 = 32'h0;
        mcontext3 = 32'h0;
        mcontext4 = 32'h0;
        mcontext5 = 32'h0;
        mcontext6 = 32'h0;
        mcontext7 = 32'h0;
        fflags = 5'h0;
        frm = 3'h0;
        mie = 1'h0;
        mtvec = 32'h0;
        mscratch = 32'h0;
        mepc = 32'h0;
        mpp = 2'h0;
        mcycle = 64'h0;
        minstret = 64'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_csr_out_value_0 = io_csr_in_value_12;
  assign io_csr_out_value_1 = mepc;
  assign io_csr_out_value_2 = mtval;
  assign io_csr_out_value_3 = mcause;
  assign io_csr_out_value_4 = mcycle[31:0];
  assign io_csr_out_value_5 = mcycle[63:32];
  assign io_csr_out_value_6 = minstret[31:0];
  assign io_csr_out_value_7 = minstret[63:32];
  assign io_csr_out_value_8 = mcontext0;
  assign io_rd_valid = req_pipe_v;
  assign io_rd_bits_addr = req_pipe_b_addr;
  assign io_rd_bits_data = rdata;
  assign io_bru_out_mode = mode;
  assign io_bru_out_mepc = mepcEn & req_pipe_v ? wdata : mepc;
  assign io_bru_out_mtvec = mtvecEn & req_pipe_v ? wdata : mtvec;
  assign io_float_out_frm = frmEn & req_pipe_v ? wdata[2:0] : frm;
  assign io_halted = halted;
  assign io_fault = fault;
  assign io_wfi = wfi;
endmodule

module DispatchV2(
  input         io_halted,
                io_lsuActive,
  input  [31:0] io_scoreboard_regd,
                io_scoreboard_comb,
                io_fscoreboard,
  input         io_branchTaken,
  output        io_csrFault_0,
                io_jalFault_0,
                io_jalFault_1,
                io_jalrFault_0,
                io_jalrFault_1,
                io_bxxFault_0,
                io_bxxFault_1,
                io_undefFault_0,
  output [31:0] io_bruTarget_0,
                io_bruTarget_1,
  input  [31:0] io_jalrTarget_0_data,
                io_jalrTarget_1_data,
  input         io_interlock,
  output        io_inst_0_ready,
  input         io_inst_0_valid,
  input  [31:0] io_inst_0_bits_addr,
                io_inst_0_bits_inst,
  input         io_inst_0_bits_brchFwd,
  output        io_inst_1_ready,
  input         io_inst_1_valid,
  input  [31:0] io_inst_1_bits_addr,
                io_inst_1_bits_inst,
  input         io_inst_1_bits_brchFwd,
  output        io_rs1Read_0_valid,
  output [4:0]  io_rs1Read_0_addr,
  output        io_rs1Read_1_valid,
  output [4:0]  io_rs1Read_1_addr,
  output        io_rs1Set_0_valid,
  output [31:0] io_rs1Set_0_value,
  output        io_rs1Set_1_valid,
  output [31:0] io_rs1Set_1_value,
  output        io_rs2Read_0_valid,
  output [4:0]  io_rs2Read_0_addr,
  output        io_rs2Read_1_valid,
  output [4:0]  io_rs2Read_1_addr,
  output        io_rs2Set_0_valid,
  output [31:0] io_rs2Set_0_value,
  output        io_rs2Set_1_valid,
  output [31:0] io_rs2Set_1_value,
  output        io_rdMark_0_valid,
  output [4:0]  io_rdMark_0_addr,
  output        io_rdMark_1_valid,
  output [4:0]  io_rdMark_1_addr,
  output        io_busRead_0_bypass,
                io_busRead_0_immen,
  output [31:0] io_busRead_0_immed,
  output        io_busRead_1_bypass,
  output [31:0] io_busRead_1_immed,
  output        io_rdMark_flt_valid,
  output [4:0]  io_rdMark_flt_addr,
  output        io_alu_0_valid,
  output [4:0]  io_alu_0_bits_addr,
                io_alu_0_bits_op,
  output        io_alu_1_valid,
  output [4:0]  io_alu_1_bits_addr,
                io_alu_1_bits_op,
  output        io_bru_0_valid,
                io_bru_0_bits_fwd,
  output [3:0]  io_bru_0_bits_op,
  output [31:0] io_bru_0_bits_pc,
                io_bru_0_bits_target,
  output [4:0]  io_bru_0_bits_link,
  output        io_bru_1_valid,
                io_bru_1_bits_fwd,
  output [3:0]  io_bru_1_bits_op,
  output [31:0] io_bru_1_bits_pc,
                io_bru_1_bits_target,
  output [4:0]  io_bru_1_bits_link,
  output        io_csr_valid,
  output [4:0]  io_csr_bits_addr,
  output [11:0] io_csr_bits_index,
  output [1:0]  io_csr_bits_op,
  input         io_lsu_0_ready,
  output        io_lsu_0_valid,
                io_lsu_0_bits_store,
  output [4:0]  io_lsu_0_bits_addr,
                io_lsu_0_bits_op,
  output [31:0] io_lsu_0_bits_pc,
  input         io_lsu_1_ready,
  output        io_lsu_1_valid,
                io_lsu_1_bits_store,
  output [4:0]  io_lsu_1_bits_addr,
                io_lsu_1_bits_op,
  output [31:0] io_lsu_1_bits_pc,
  input  [2:0]  io_lsuQueueCapacity,
  output        io_mlu_0_valid,
  output [4:0]  io_mlu_0_bits_addr,
  output [2:0]  io_mlu_0_bits_op,
  input         io_mlu_1_ready,
  output        io_mlu_1_valid,
  output [4:0]  io_mlu_1_bits_addr,
  output [2:0]  io_mlu_1_bits_op,
  input         io_dvu_0_ready,
  output        io_dvu_0_valid,
  output [4:0]  io_dvu_0_bits_addr,
  output [1:0]  io_dvu_0_bits_op,
  input         io_float_ready,
  output        io_float_valid,
  output [2:0]  io_float_bits_opcode,
  output [4:0]  io_float_bits_funct5,
                io_float_bits_rs3,
                io_float_bits_rs2,
                io_float_bits_rs1,
  output [2:0]  io_float_bits_rm,
  output [31:0] io_float_bits_inst,
                io_float_bits_pc,
  output        io_float_bits_scalar_rd,
                io_float_bits_scalar_rs1,
  output [4:0]  io_float_bits_rd,
  output        io_float_bits_uses_rs3,
                io_float_bits_uses_rs2,
  output [4:0]  io_fbusPortAddr,
  output        io_slog
);

  wire [19:0] _decodedInsts_d_imm12_T_1 = {20{io_inst_0_bits_inst[31]}};
  wire [31:0] decodedInsts_0_immcsr = {27'h0, io_inst_0_bits_inst[19:15]};
  wire        decodedInsts_0_lui = io_inst_0_bits_inst[6:0] == 7'h37;
  wire        decodedInsts_0_auipc = io_inst_0_bits_inst[6:0] == 7'h17;
  wire        decodedInsts_0_jal = io_inst_0_bits_inst[6:0] == 7'h6F;
  wire [9:0]  _GEN = {io_inst_0_bits_inst[14:12], io_inst_0_bits_inst[6:0]};
  wire        decodedInsts_0_jalr = _GEN == 10'h67;
  wire        decodedInsts_0_beq = _GEN == 10'h63;
  wire        decodedInsts_0_bne = _GEN == 10'hE3;
  wire        decodedInsts_0_blt = _GEN == 10'h263;
  wire        decodedInsts_0_bge = _GEN == 10'h2E3;
  wire        decodedInsts_0_bltu = _GEN == 10'h363;
  wire        decodedInsts_0_bgeu = _GEN == 10'h3E3;
  wire [8:0]  _GEN_0 = {io_inst_0_bits_inst[13:12], io_inst_0_bits_inst[6:0]};
  wire        decodedInsts_0_csrrw = _GEN_0 == 9'hF3;
  wire        decodedInsts_0_csrrs = _GEN_0 == 9'h173;
  wire        decodedInsts_0_csrrc = _GEN_0 == 9'h1F3;
  wire        decodedInsts_0_lb = _GEN == 10'h3;
  wire        decodedInsts_0_lh = _GEN == 10'h83;
  wire        decodedInsts_0_lw = _GEN == 10'h103;
  wire        decodedInsts_0_lbu = _GEN == 10'h203;
  wire        decodedInsts_0_lhu = _GEN == 10'h283;
  wire        decodedInsts_0_sb = _GEN == 10'h23;
  wire        decodedInsts_0_sh = _GEN == 10'hA3;
  wire        decodedInsts_0_sw = _GEN == 10'h123;
  wire        decodedInsts_0_fence =
    {io_inst_0_bits_inst[31:28], io_inst_0_bits_inst[19:0]} == 24'hF;
  wire        decodedInsts_0_addi = _GEN == 10'h13;
  wire        decodedInsts_0_slti = _GEN == 10'h113;
  wire        decodedInsts_0_sltiu = _GEN == 10'h193;
  wire        decodedInsts_0_xori = _GEN == 10'h213;
  wire        decodedInsts_0_ori = _GEN == 10'h313;
  wire        decodedInsts_0_andi = _GEN == 10'h393;
  wire [16:0] _GEN_1 =
    {io_inst_0_bits_inst[31:25], io_inst_0_bits_inst[14:12], io_inst_0_bits_inst[6:0]};
  wire        decodedInsts_0_slli = _GEN_1 == 17'h93;
  wire        decodedInsts_0_srli = _GEN_1 == 17'h293;
  wire        decodedInsts_0_srai = _GEN_1 == 17'h8293;
  wire        decodedInsts_0_add = _GEN_1 == 17'h33;
  wire        decodedInsts_0_sub = _GEN_1 == 17'h8033;
  wire        decodedInsts_0_slt = _GEN_1 == 17'h133;
  wire        decodedInsts_0_sltu = _GEN_1 == 17'h1B3;
  wire        decodedInsts_0_xor = _GEN_1 == 17'h233;
  wire        decodedInsts_0_or = _GEN_1 == 17'h333;
  wire        decodedInsts_0_and = _GEN_1 == 17'h3B3;
  wire        decodedInsts_0_sll = _GEN_1 == 17'hB3;
  wire        decodedInsts_0_srl = _GEN_1 == 17'h2B3;
  wire        decodedInsts_0_sra = _GEN_1 == 17'h82B3;
  wire        decodedInsts_0_mul = _GEN_1 == 17'h433;
  wire        decodedInsts_0_mulh = _GEN_1 == 17'h4B3;
  wire        decodedInsts_0_mulhsu = _GEN_1 == 17'h533;
  wire        decodedInsts_0_mulhu = _GEN_1 == 17'h5B3;
  wire        decodedInsts_0_div = _GEN_1 == 17'h633;
  wire        decodedInsts_0_divu = _GEN_1 == 17'h6B3;
  wire        decodedInsts_0_rem = _GEN_1 == 17'h733;
  wire        decodedInsts_0_remu = _GEN_1 == 17'h7B3;
  wire        decodedInsts_0_andn = _GEN_1 == 17'h83B3;
  wire        decodedInsts_0_orn = _GEN_1 == 17'h8333;
  wire        decodedInsts_0_xnor = _GEN_1 == 17'h8233;
  wire [21:0] _GEN_2 =
    {io_inst_0_bits_inst[31:20], io_inst_0_bits_inst[14:12], io_inst_0_bits_inst[6:0]};
  wire        decodedInsts_0_clz = _GEN_2 == 22'h180093;
  wire        decodedInsts_0_ctz = _GEN_2 == 22'h180493;
  wire        decodedInsts_0_cpop = _GEN_2 == 22'h180893;
  wire        decodedInsts_0_max = _GEN_1 == 17'h1733;
  wire        decodedInsts_0_maxu = _GEN_1 == 17'h17B3;
  wire        decodedInsts_0_min = _GEN_1 == 17'h1633;
  wire        decodedInsts_0_minu = _GEN_1 == 17'h16B3;
  wire        decodedInsts_0_sextb = _GEN_2 == 22'h181093;
  wire        decodedInsts_0_sexth = _GEN_2 == 22'h181493;
  wire        decodedInsts_0_rol = _GEN_1 == 17'hC0B3;
  wire        decodedInsts_0_ror = _GEN_1 == 17'hC2B3;
  wire        decodedInsts_0_orcb = _GEN_2 == 22'hA1E93;
  wire        decodedInsts_0_rev8 = _GEN_2 == 22'h1A6293;
  wire        decodedInsts_0_zexth = _GEN_2 == 22'h20233;
  wire        decodedInsts_0_rori = _GEN_1 == 17'hC293;
  wire        decodedInsts_slog =
    {io_inst_0_bits_inst[31:20],
     io_inst_0_bits_inst[14],
     io_inst_0_bits_inst[11:0]} == 25'hF00077;
  wire        decodedInsts_0_ebreak = io_inst_0_bits_inst == 32'h100073;
  wire        decodedInsts_0_ecall = io_inst_0_bits_inst == 32'h73;
  wire        decodedInsts_0_mpause = io_inst_0_bits_inst == 32'h8000073;
  wire        decodedInsts_0_mret = io_inst_0_bits_inst == 32'h30200073;
  wire        decodedInsts_0_wfi = io_inst_0_bits_inst == 32'h10500073;
  wire        decodedInsts_0_fencei = io_inst_0_bits_inst == 32'h100F;
  wire        decodedInsts_0_flushat =
    {io_inst_0_bits_inst[31:28],
     io_inst_0_bits_inst[24:20],
     io_inst_0_bits_inst[14:0]} == 24'h200077 & (|(io_inst_0_bits_inst[19:15]));
  wire        decodedInsts_0_flushall =
    {io_inst_0_bits_inst[31:28], io_inst_0_bits_inst[24:0]} == 29'h4000077;
  wire        decodedInsts_d_float_load_store_rm_valid =
    io_inst_0_bits_inst[14:12] == 3'h1 | io_inst_0_bits_inst[14:12] == 3'h2;
  wire        _decodedInsts_d_float_opcode_T_4 = io_inst_0_bits_inst[6:2] == 5'h9;
  wire        _decodedInsts_d_float_opcode_T_6 = io_inst_0_bits_inst[6:2] == 5'h14;
  wire        _decodedInsts_d_float_opcode_T_8 = io_inst_0_bits_inst[6:2] == 5'h10;
  wire        _decodedInsts_d_float_opcode_T_10 = io_inst_0_bits_inst[6:2] == 5'h11;
  wire        _decodedInsts_d_float_opcode_T_12 = io_inst_0_bits_inst[6:2] == 5'h12;
  wire        _decodedInsts_d_float_opcode_T_14 = io_inst_0_bits_inst[6:2] == 5'h13;
  wire [2:0]  decodedInsts_d_float_opcode_bits =
    _decodedInsts_d_float_opcode_T_14
      ? 3'h5
      : _decodedInsts_d_float_opcode_T_12
          ? 3'h6
          : _decodedInsts_d_float_opcode_T_10
              ? 3'h4
              : _decodedInsts_d_float_opcode_T_8
                  ? 3'h3
                  : _decodedInsts_d_float_opcode_T_6
                      ? 3'h2
                      : {2'h0,
                         _decodedInsts_d_float_opcode_T_4
                           & decodedInsts_d_float_load_store_rm_valid};
  wire        _decodedInsts_d_float_uses_rs2_T_5 = io_inst_0_bits_inst[31:27] == 5'h1C;
  wire        _decodedInsts_d_float_uses_rs2_T_7 = io_inst_0_bits_inst[31:27] == 5'h18;
  wire        _decodedInsts_d_float_uses_rs2_T_2 =
    decodedInsts_d_float_opcode_bits == 3'h2;
  wire        decodedInsts_d_float_scalar_rd =
    (_decodedInsts_d_float_uses_rs2_T_7 | _decodedInsts_d_float_uses_rs2_T_5
     | io_inst_0_bits_inst[31:27] == 5'h14) & _decodedInsts_d_float_uses_rs2_T_2;
  wire        _decodedInsts_d_float_uses_rs2_T_9 = io_inst_0_bits_inst[31:27] == 5'h1E;
  wire        _decodedInsts_d_float_uses_rs2_T_11 = io_inst_0_bits_inst[31:27] == 5'h1A;
  wire        decodedInsts_d_float_scalar_rs1 =
    _decodedInsts_d_float_uses_rs2_T_11 | _decodedInsts_d_float_uses_rs2_T_9;
  wire [3:0]  _decodedInsts_d_float_uses_rs3_T_4 =
    {decodedInsts_d_float_opcode_bits == 3'h6,
     decodedInsts_d_float_opcode_bits == 3'h5,
     decodedInsts_d_float_opcode_bits == 3'h4,
     decodedInsts_d_float_opcode_bits == 3'h3};
  wire        _decodedInsts_d_float_T_1 = decodedInsts_d_float_opcode_bits == 3'h1;
  wire        decodedInsts_d_float_uses_rs2 =
    _decodedInsts_d_float_T_1 | _decodedInsts_d_float_uses_rs2_T_2
    & ~(io_inst_0_bits_inst[31:27] == 5'hB | _decodedInsts_d_float_uses_rs2_T_11
        | _decodedInsts_d_float_uses_rs2_T_9 | _decodedInsts_d_float_uses_rs2_T_7
        | _decodedInsts_d_float_uses_rs2_T_5) & io_inst_0_bits_inst[31:27] != 5'h1C;
  wire        decodedInsts_d_float_y =
    (_decodedInsts_d_float_opcode_T_14 | _decodedInsts_d_float_opcode_T_12
     | _decodedInsts_d_float_opcode_T_10 | _decodedInsts_d_float_opcode_T_8
     | _decodedInsts_d_float_opcode_T_6
     | (_decodedInsts_d_float_opcode_T_4 | io_inst_0_bits_inst[6:2] == 5'h1)
     & decodedInsts_d_float_load_store_rm_valid)
    & (decodedInsts_d_float_opcode_bits == 3'h0 | _decodedInsts_d_float_T_1
       | io_inst_0_bits_inst[26:25] == 2'h0);
  wire [19:0] _decodedInsts_d_imm12_T_5 = {20{io_inst_1_bits_inst[31]}};
  wire        decodedInsts_1_lui = io_inst_1_bits_inst[6:0] == 7'h37;
  wire        decodedInsts_1_auipc = io_inst_1_bits_inst[6:0] == 7'h17;
  wire        decodedInsts_1_jal = io_inst_1_bits_inst[6:0] == 7'h6F;
  wire [9:0]  _GEN_3 = {io_inst_1_bits_inst[14:12], io_inst_1_bits_inst[6:0]};
  wire        decodedInsts_1_jalr = _GEN_3 == 10'h67;
  wire        decodedInsts_1_beq = _GEN_3 == 10'h63;
  wire        decodedInsts_1_bne = _GEN_3 == 10'hE3;
  wire        decodedInsts_1_blt = _GEN_3 == 10'h263;
  wire        decodedInsts_1_bge = _GEN_3 == 10'h2E3;
  wire        decodedInsts_1_bltu = _GEN_3 == 10'h363;
  wire        decodedInsts_1_bgeu = _GEN_3 == 10'h3E3;
  wire        decodedInsts_1_lb = _GEN_3 == 10'h3;
  wire        decodedInsts_1_lh = _GEN_3 == 10'h83;
  wire        decodedInsts_1_lw = _GEN_3 == 10'h103;
  wire        decodedInsts_1_lbu = _GEN_3 == 10'h203;
  wire        decodedInsts_1_lhu = _GEN_3 == 10'h283;
  wire        decodedInsts_1_sb = _GEN_3 == 10'h23;
  wire        decodedInsts_1_sh = _GEN_3 == 10'hA3;
  wire        decodedInsts_1_sw = _GEN_3 == 10'h123;
  wire        decodedInsts_1_addi = _GEN_3 == 10'h13;
  wire        decodedInsts_1_slti = _GEN_3 == 10'h113;
  wire        decodedInsts_1_sltiu = _GEN_3 == 10'h193;
  wire        decodedInsts_1_xori = _GEN_3 == 10'h213;
  wire        decodedInsts_1_ori = _GEN_3 == 10'h313;
  wire        decodedInsts_1_andi = _GEN_3 == 10'h393;
  wire [16:0] _GEN_4 =
    {io_inst_1_bits_inst[31:25], io_inst_1_bits_inst[14:12], io_inst_1_bits_inst[6:0]};
  wire        decodedInsts_1_slli = _GEN_4 == 17'h93;
  wire        decodedInsts_1_srli = _GEN_4 == 17'h293;
  wire        decodedInsts_1_srai = _GEN_4 == 17'h8293;
  wire        decodedInsts_1_add = _GEN_4 == 17'h33;
  wire        decodedInsts_1_sub = _GEN_4 == 17'h8033;
  wire        decodedInsts_1_slt = _GEN_4 == 17'h133;
  wire        decodedInsts_1_sltu = _GEN_4 == 17'h1B3;
  wire        decodedInsts_1_xor = _GEN_4 == 17'h233;
  wire        decodedInsts_1_or = _GEN_4 == 17'h333;
  wire        decodedInsts_1_and = _GEN_4 == 17'h3B3;
  wire        decodedInsts_1_sll = _GEN_4 == 17'hB3;
  wire        decodedInsts_1_srl = _GEN_4 == 17'h2B3;
  wire        decodedInsts_1_sra = _GEN_4 == 17'h82B3;
  wire        decodedInsts_1_mul = _GEN_4 == 17'h433;
  wire        decodedInsts_1_mulh = _GEN_4 == 17'h4B3;
  wire        decodedInsts_1_mulhsu = _GEN_4 == 17'h533;
  wire        decodedInsts_1_mulhu = _GEN_4 == 17'h5B3;
  wire        decodedInsts_1_andn = _GEN_4 == 17'h83B3;
  wire        decodedInsts_1_orn = _GEN_4 == 17'h8333;
  wire        decodedInsts_1_xnor = _GEN_4 == 17'h8233;
  wire [21:0] _GEN_5 =
    {io_inst_1_bits_inst[31:20], io_inst_1_bits_inst[14:12], io_inst_1_bits_inst[6:0]};
  wire        decodedInsts_1_clz = _GEN_5 == 22'h180093;
  wire        decodedInsts_1_ctz = _GEN_5 == 22'h180493;
  wire        decodedInsts_1_cpop = _GEN_5 == 22'h180893;
  wire        decodedInsts_1_max = _GEN_4 == 17'h1733;
  wire        decodedInsts_1_maxu = _GEN_4 == 17'h17B3;
  wire        decodedInsts_1_min = _GEN_4 == 17'h1633;
  wire        decodedInsts_1_minu = _GEN_4 == 17'h16B3;
  wire        decodedInsts_1_sextb = _GEN_5 == 22'h181093;
  wire        decodedInsts_1_sexth = _GEN_5 == 22'h181493;
  wire        decodedInsts_1_rol = _GEN_4 == 17'hC0B3;
  wire        decodedInsts_1_ror = _GEN_4 == 17'hC2B3;
  wire        decodedInsts_1_orcb = _GEN_5 == 22'hA1E93;
  wire        decodedInsts_1_rev8 = _GEN_5 == 22'h1A6293;
  wire        decodedInsts_1_zexth = _GEN_5 == 22'h20233;
  wire        decodedInsts_1_rori = _GEN_4 == 17'hC293;
  wire        _slot0Interlock_T = decodedInsts_0_fencei | decodedInsts_0_ebreak;
  wire        _io_rs2Read_0_valid_T_1 = decodedInsts_0_beq | decodedInsts_0_bne;
  wire        _io_rs2Read_1_valid_T_1 = decodedInsts_1_beq | decodedInsts_1_bne;
  wire        _io_rs2Read_0_valid_T_25 = decodedInsts_0_sb | decodedInsts_0_sh;
  wire        _writesFloatRd_T = decodedInsts_d_float_y & decodedInsts_d_float_scalar_rd;
  wire        _io_rs2Read_1_valid_T_25 = decodedInsts_1_sb | decodedInsts_1_sh;
  wire [31:0] _GEN_6 = {27'h0, io_inst_0_bits_inst[11:7]};
  wire [31:0] rdScoreboard_0 =
    ~(_io_rs2Read_0_valid_T_25 | decodedInsts_0_sw)
    & ~(_io_rs2Read_0_valid_T_1 | decodedInsts_0_blt | decodedInsts_0_bge
        | decodedInsts_0_bltu | decodedInsts_0_bgeu) | _writesFloatRd_T
      ? 32'h1 << _GEN_6
      : 32'h0;
  wire [31:0] comb_1 = rdScoreboard_0 | io_scoreboard_comb;
  wire        _rdMark_valid_T_5 = decodedInsts_0_lb | decodedInsts_0_lh;
  wire        _rdMark_flt_valid_T_4 = decodedInsts_d_float_opcode_bits == 3'h0;
  wire        _io_float_valid_T_3 = decodedInsts_d_float_opcode_bits == 3'h1;
  wire        _rdMark_valid_T_28 = decodedInsts_1_lb | decodedInsts_1_lh;
  wire [31:0] _GEN_7 = {27'h0, io_inst_0_bits_inst[24:20]};
  wire [31:0] _GEN_8 = {27'h0, io_inst_1_bits_inst[19:15]};
  wire [31:0] _GEN_9 = {27'h0, io_inst_1_bits_inst[24:20]};
  wire        _io_rs2Read_0_valid_T_6 = decodedInsts_0_add | decodedInsts_0_sub;
  wire        _io_rs2Set_0_valid_T_6 = decodedInsts_0_addi | decodedInsts_0_slti;
  wire        _io_rs2Set_0_valid_T_16 = decodedInsts_0_clz | decodedInsts_0_ctz;
  wire        _io_rs2Read_0_valid_T_19 = decodedInsts_0_min | decodedInsts_0_minu;
  wire        _io_rs2Set_0_valid_T_1 = decodedInsts_0_csrrw | decodedInsts_0_csrrs;
  wire        _io_rs2Read_0_valid_T_34 = decodedInsts_0_mul | decodedInsts_0_mulh;
  wire        _io_rs2Read_0_valid_T_38 = decodedInsts_0_div | decodedInsts_0_divu;
  wire        _io_rs1Read_0_valid_T_56 =
    decodedInsts_d_float_y & decodedInsts_d_float_scalar_rs1;
  wire        _io_rs2Read_1_valid_T_6 = decodedInsts_1_add | decodedInsts_1_sub;
  wire        _io_rs2Set_1_valid_T_6 = decodedInsts_1_addi | decodedInsts_1_slti;
  wire        _io_rs2Set_1_valid_T_16 = decodedInsts_1_clz | decodedInsts_1_ctz;
  wire        _io_rs2Read_1_valid_T_19 = decodedInsts_1_min | decodedInsts_1_minu;
  wire        _io_rs2Read_1_valid_T_34 = decodedInsts_1_mul | decodedInsts_1_mulh;
  wire        tryDispatch =
    ~io_halted & ~io_interlock & io_inst_0_valid
    & {((decodedInsts_0_jalr | _rdMark_valid_T_5 | decodedInsts_0_lw | decodedInsts_0_lbu
         | decodedInsts_0_lhu | _io_rs2Read_0_valid_T_25 | decodedInsts_0_sw
         | decodedInsts_0_flushat | decodedInsts_0_flushall | decodedInsts_d_float_y
         & _rdMark_flt_valid_T_4 | decodedInsts_d_float_y & _io_float_valid_T_3
           ? 32'h1 << decodedInsts_0_immcsr
           : 32'h0)
        | (_io_rs2Read_0_valid_T_25 | decodedInsts_0_sw ? 32'h1 << _GEN_7 : 32'h0))
         & io_scoreboard_regd,
       ((_io_rs2Read_0_valid_T_1 | decodedInsts_0_blt | decodedInsts_0_bge
         | decodedInsts_0_bltu | decodedInsts_0_bgeu | _io_rs2Read_0_valid_T_6
         | decodedInsts_0_slt | decodedInsts_0_sltu | decodedInsts_0_xor
         | decodedInsts_0_or | decodedInsts_0_and | decodedInsts_0_xnor
         | decodedInsts_0_orn | decodedInsts_0_andn | decodedInsts_0_sll
         | decodedInsts_0_srl | decodedInsts_0_sra | _io_rs2Set_0_valid_T_6
         | decodedInsts_0_sltiu | decodedInsts_0_xori | decodedInsts_0_ori
         | decodedInsts_0_andi | decodedInsts_0_slli | decodedInsts_0_srli
         | decodedInsts_0_srai | decodedInsts_0_rori | _io_rs2Set_0_valid_T_16
         | decodedInsts_0_cpop | decodedInsts_0_sextb | decodedInsts_0_sexth
         | decodedInsts_0_zexth | decodedInsts_0_orcb | decodedInsts_0_rev8
         | _io_rs2Read_0_valid_T_19 | decodedInsts_0_max | decodedInsts_0_maxu
         | decodedInsts_0_rol | decodedInsts_0_ror | _io_rs2Set_0_valid_T_1
         | decodedInsts_0_csrrc | _io_rs2Read_0_valid_T_34 | decodedInsts_0_mulhsu
         | decodedInsts_0_mulhu | _io_rs2Read_0_valid_T_38 | decodedInsts_0_rem
         | decodedInsts_0_remu | decodedInsts_slog | decodedInsts_0_jalr
         | _io_rs1Read_0_valid_T_56
           ? 32'h1 << decodedInsts_0_immcsr
           : 32'h0)
        | (_io_rs2Read_0_valid_T_1 | decodedInsts_0_blt | decodedInsts_0_bge
           | decodedInsts_0_bltu | decodedInsts_0_bgeu | _io_rs2Read_0_valid_T_6
           | decodedInsts_0_slt | decodedInsts_0_sltu | decodedInsts_0_xor
           | decodedInsts_0_or | decodedInsts_0_and | decodedInsts_0_xnor
           | decodedInsts_0_orn | decodedInsts_0_andn | decodedInsts_0_sll
           | decodedInsts_0_srl | decodedInsts_0_sra | _io_rs2Read_0_valid_T_19
           | decodedInsts_0_max | decodedInsts_0_maxu | decodedInsts_0_rol
           | decodedInsts_0_ror | _io_rs2Read_0_valid_T_25 | decodedInsts_0_sw
           | (_io_rs2Set_0_valid_T_1 | decodedInsts_0_csrrc) & ~(io_inst_0_bits_inst[14])
           | _io_rs2Read_0_valid_T_34 | decodedInsts_0_mulhsu | decodedInsts_0_mulhu
           | _io_rs2Read_0_valid_T_38 | decodedInsts_0_rem | decodedInsts_0_remu
           | decodedInsts_slog
             ? 32'h1 << _GEN_7
             : 32'h0)) & io_scoreboard_comb} == 64'h0
    & (rdScoreboard_0 & io_scoreboard_comb) == 32'h0
    & (((_io_rs1Read_0_valid_T_56 ? 32'h1 << decodedInsts_0_immcsr : 32'h0)
        | (decodedInsts_d_float_y & decodedInsts_d_float_uses_rs2
             ? 32'h1 << _GEN_7
             : 32'h0)
        | (decodedInsts_d_float_y & (|_decodedInsts_d_float_uses_rs3_T_4)
             ? 32'h1 << io_inst_0_bits_inst[31:27]
             : 32'h0)) & io_fscoreboard) == 32'h0
    & ((decodedInsts_d_float_y & ~_writesFloatRd_T ? 32'h1 << _GEN_6 : 32'h0)
       & io_fscoreboard) == 32'h0
    & ~((_slot0Interlock_T | decodedInsts_0_wfi | decodedInsts_0_mpause
         | decodedInsts_0_flushat | decodedInsts_0_flushall) & io_lsuActive)
    & (|io_lsuQueueCapacity)
    & (~decodedInsts_0_mpause | io_scoreboard_regd == 32'h0 & io_fscoreboard == 32'h0
       & ~io_lsuActive);
  wire        _alu_T_1 = decodedInsts_0_auipc | decodedInsts_0_addi | decodedInsts_0_add;
  wire        _alu_T_2 = decodedInsts_0_slti | decodedInsts_0_slt;
  wire        _alu_T_3 = decodedInsts_0_sltiu | decodedInsts_0_sltu;
  wire        _alu_T_4 = decodedInsts_0_xori | decodedInsts_0_xor;
  wire        _alu_T_5 = decodedInsts_0_ori | decodedInsts_0_or;
  wire        _alu_T_6 = decodedInsts_0_andi | decodedInsts_0_and;
  wire        _alu_T_7 = decodedInsts_0_slli | decodedInsts_0_sll;
  wire        _alu_T_8 = decodedInsts_0_srli | decodedInsts_0_srl;
  wire        _alu_T_9 = decodedInsts_0_srai | decodedInsts_0_sra;
  wire        io_alu_0_valid_0 =
    tryDispatch
    & (_alu_T_1 | decodedInsts_0_sub | _alu_T_2 | _alu_T_3 | _alu_T_4 | _alu_T_5
       | _alu_T_6 | _alu_T_7 | _alu_T_8 | _alu_T_9 | decodedInsts_0_lui
       | decodedInsts_0_andn | decodedInsts_0_orn | decodedInsts_0_xnor
       | decodedInsts_0_clz | decodedInsts_0_ctz | decodedInsts_0_cpop
       | decodedInsts_0_max | decodedInsts_0_maxu | decodedInsts_0_min
       | decodedInsts_0_minu | decodedInsts_0_sextb | decodedInsts_0_sexth
       | decodedInsts_0_rol | decodedInsts_0_ror | decodedInsts_0_orcb
       | decodedInsts_0_rev8 | decodedInsts_0_zexth | decodedInsts_0_rori);
  wire [3:0]  bru_bits =
    decodedInsts_0_jal
      ? 4'h0
      : decodedInsts_0_jalr
          ? 4'h1
          : decodedInsts_0_beq
              ? 4'h2
              : decodedInsts_0_bne
                  ? 4'h3
                  : decodedInsts_0_blt
                      ? 4'h4
                      : decodedInsts_0_bge
                          ? 4'h5
                          : decodedInsts_0_bltu
                              ? 4'h6
                              : decodedInsts_0_bgeu
                                  ? 4'h7
                                  : decodedInsts_0_ebreak
                                      ? 4'h8
                                      : decodedInsts_0_ecall
                                          ? 4'h9
                                          : decodedInsts_0_mpause
                                              ? 4'hA
                                              : decodedInsts_0_mret
                                                  ? 4'hB
                                                  : decodedInsts_0_wfi ? 4'hC : 4'h0;
  wire [31:0] _bru_target_T_2 =
    io_inst_0_bits_addr
    + {{12{io_inst_0_bits_inst[31]}},
       io_inst_0_bits_inst[2]
         ? {io_inst_0_bits_inst[19:12],
            io_inst_0_bits_inst[20],
            io_inst_0_bits_inst[30:21]}
         : {{8{io_inst_0_bits_inst[31]}},
            io_inst_0_bits_inst[7],
            io_inst_0_bits_inst[30:25],
            io_inst_0_bits_inst[11:8]},
       1'h0};
  wire        _io_bru_0_valid_T =
    tryDispatch
    & (decodedInsts_0_jal | decodedInsts_0_jalr | decodedInsts_0_beq | decodedInsts_0_bne
       | decodedInsts_0_blt | decodedInsts_0_bge | decodedInsts_0_bltu
       | decodedInsts_0_bgeu | decodedInsts_0_ebreak | decodedInsts_0_ecall
       | decodedInsts_0_mpause | decodedInsts_0_mret | decodedInsts_0_wfi);
  wire        jalFault =
    _io_bru_0_valid_T & bru_bits == 4'h0 & (|(_bru_target_T_2[1:0])) & ~io_branchTaken;
  wire        jalrFault =
    _io_bru_0_valid_T & bru_bits == 4'h1 & io_jalrTarget_0_data[1] & ~io_branchTaken;
  wire        bxxFault =
    _io_bru_0_valid_T
    & (|{bru_bits == 4'h7,
         bru_bits == 4'h6,
         bru_bits == 4'h5,
         bru_bits == 4'h4,
         bru_bits == 4'h3,
         bru_bits == 4'h2}) & (|(_bru_target_T_2[1:0])) & ~io_branchTaken;
  wire        io_bru_0_valid_0 = _io_bru_0_valid_T & ~(jalFault | jalrFault | bxxFault);
  wire        io_mlu_0_valid_0 =
    tryDispatch
    & (decodedInsts_0_mul | decodedInsts_0_mulh | decodedInsts_0_mulhsu
       | decodedInsts_0_mulhu);
  wire        io_dvu_0_valid_0 =
    tryDispatch
    & (decodedInsts_0_div | decodedInsts_0_divu | decodedInsts_0_rem
       | decodedInsts_0_remu);
  wire        _lsu_T_5_valid =
    decodedInsts_d_float_y & _rdMark_flt_valid_T_4 | decodedInsts_d_float_y
    & _io_float_valid_T_3;
  wire        io_lsu_0_valid_0 =
    tryDispatch
    & (decodedInsts_0_lb | decodedInsts_0_lh | decodedInsts_0_lw | decodedInsts_0_lbu
       | decodedInsts_0_lhu | decodedInsts_0_sb | decodedInsts_0_sh | decodedInsts_0_sw
       | decodedInsts_0_wfi | decodedInsts_0_fencei | decodedInsts_0_flushat
       | decodedInsts_0_flushall | _lsu_T_5_valid);
  wire        csr_valid =
    decodedInsts_0_csrrw | decodedInsts_0_csrrs | decodedInsts_0_csrrc;
  wire        csr_address_valid =
    io_inst_0_bits_inst[31:20] == 12'h1 | io_inst_0_bits_inst[31:20] == 12'h2
    | io_inst_0_bits_inst[31:20] == 12'h3 | io_inst_0_bits_inst[31:20] == 12'h8
    | io_inst_0_bits_inst[31:20] == 12'h9 | io_inst_0_bits_inst[31:20] == 12'hA
    | io_inst_0_bits_inst[31:20] == 12'h300 | io_inst_0_bits_inst[31:20] == 12'h301
    | io_inst_0_bits_inst[31:20] == 12'h304 | io_inst_0_bits_inst[31:20] == 12'h305
    | io_inst_0_bits_inst[31:20] == 12'h340 | io_inst_0_bits_inst[31:20] == 12'h341
    | io_inst_0_bits_inst[31:20] == 12'h342 | io_inst_0_bits_inst[31:20] == 12'h343
    | io_inst_0_bits_inst[31:20] == 12'h7A0 | io_inst_0_bits_inst[31:20] == 12'h7A1
    | io_inst_0_bits_inst[31:20] == 12'h7A2 | io_inst_0_bits_inst[31:20] == 12'h7A4
    | io_inst_0_bits_inst[31:20] == 12'h7B0 | io_inst_0_bits_inst[31:20] == 12'h7B1
    | io_inst_0_bits_inst[31:20] == 12'h7B2 | io_inst_0_bits_inst[31:20] == 12'h7B3
    | io_inst_0_bits_inst[31:20] == 12'h7C0 | io_inst_0_bits_inst[31:20] == 12'h7C1
    | io_inst_0_bits_inst[31:20] == 12'h7C2 | io_inst_0_bits_inst[31:20] == 12'h7C3
    | io_inst_0_bits_inst[31:20] == 12'h7C4 | io_inst_0_bits_inst[31:20] == 12'h7C5
    | io_inst_0_bits_inst[31:20] == 12'h7C6 | io_inst_0_bits_inst[31:20] == 12'h7C7
    | io_inst_0_bits_inst[31:20] == 12'h7E0 | io_inst_0_bits_inst[31:20] == 12'h7E1
    | io_inst_0_bits_inst[31:20] == 12'hB00 | io_inst_0_bits_inst[31:20] == 12'hB02
    | io_inst_0_bits_inst[31:20] == 12'hB80 | io_inst_0_bits_inst[31:20] == 12'hB82
    | io_inst_0_bits_inst[31:20] == 12'hC20 | io_inst_0_bits_inst[31:20] == 12'hC21
    | io_inst_0_bits_inst[31:20] == 12'hC22 | io_inst_0_bits_inst[31:20] == 12'hF11
    | io_inst_0_bits_inst[31:20] == 12'hF12 | io_inst_0_bits_inst[31:20] == 12'hF13
    | io_inst_0_bits_inst[31:20] == 12'hF14 | io_inst_0_bits_inst[31:20] == 12'hFC0
    | io_inst_0_bits_inst[31:20] == 12'hFC4 | io_inst_0_bits_inst[31:20] == 12'hFC8
    | io_inst_0_bits_inst[31:20] == 12'hFCC | io_inst_0_bits_inst[31:20] == 12'hFD0
    | io_inst_0_bits_inst[31:20] == 12'hFD4;
  wire        io_csr_valid_0 =
    tryDispatch & csr_valid & csr_address_valid & io_float_ready;
  wire        io_slog_0 = tryDispatch & decodedInsts_slog;
  wire        io_float_valid_0 =
    tryDispatch & decodedInsts_d_float_y
    & ~(decodedInsts_d_float_y & _rdMark_flt_valid_T_4 | decodedInsts_d_float_y
        & _io_float_valid_T_3);
  wire        dispatched_3 = io_dvu_0_ready & io_dvu_0_valid_0;
  wire        dispatched_4 = io_lsu_0_ready & io_lsu_0_valid_0;
  wire        dispatched_8 = io_float_ready & io_float_valid_0;
  wire        lastReady_1 =
    io_alu_0_valid_0 | io_bru_0_valid_0 | io_mlu_0_valid_0 | dispatched_3 | dispatched_4
    | io_csr_valid_0 | io_slog_0 | tryDispatch & decodedInsts_0_fence | dispatched_8;
  wire        tryDispatch_1 =
    lastReady_1 & ~io_halted & ~io_interlock & io_inst_1_valid
    & ~(decodedInsts_0_jal | decodedInsts_0_jalr | decodedInsts_0_ecall
        | decodedInsts_0_mpause | decodedInsts_0_mret | _slot0Interlock_T
        | decodedInsts_0_wfi | decodedInsts_0_flushat | decodedInsts_0_flushall)
    & {((decodedInsts_1_jalr | _rdMark_valid_T_28 | decodedInsts_1_lw | decodedInsts_1_lbu
         | decodedInsts_1_lhu | _io_rs2Read_1_valid_T_25 | decodedInsts_1_sw
           ? 32'h1 << _GEN_8
           : 32'h0)
        | (_io_rs2Read_1_valid_T_25 | decodedInsts_1_sw ? 32'h1 << _GEN_9 : 32'h0))
         & (rdScoreboard_0 | io_scoreboard_regd),
       ((_io_rs2Read_1_valid_T_1 | decodedInsts_1_blt | decodedInsts_1_bge
         | decodedInsts_1_bltu | decodedInsts_1_bgeu | _io_rs2Read_1_valid_T_6
         | decodedInsts_1_slt | decodedInsts_1_sltu | decodedInsts_1_xor
         | decodedInsts_1_or | decodedInsts_1_and | decodedInsts_1_xnor
         | decodedInsts_1_orn | decodedInsts_1_andn | decodedInsts_1_sll
         | decodedInsts_1_srl | decodedInsts_1_sra | _io_rs2Set_1_valid_T_6
         | decodedInsts_1_sltiu | decodedInsts_1_xori | decodedInsts_1_ori
         | decodedInsts_1_andi | decodedInsts_1_slli | decodedInsts_1_srli
         | decodedInsts_1_srai | decodedInsts_1_rori | _io_rs2Set_1_valid_T_16
         | decodedInsts_1_cpop | decodedInsts_1_sextb | decodedInsts_1_sexth
         | decodedInsts_1_zexth | decodedInsts_1_orcb | decodedInsts_1_rev8
         | _io_rs2Read_1_valid_T_19 | decodedInsts_1_max | decodedInsts_1_maxu
         | decodedInsts_1_rol | decodedInsts_1_ror | _io_rs2Read_1_valid_T_34
         | decodedInsts_1_mulhsu | decodedInsts_1_mulhu | decodedInsts_1_jalr
           ? 32'h1 << _GEN_8
           : 32'h0)
        | (_io_rs2Read_1_valid_T_1 | decodedInsts_1_blt | decodedInsts_1_bge
           | decodedInsts_1_bltu | decodedInsts_1_bgeu | _io_rs2Read_1_valid_T_6
           | decodedInsts_1_slt | decodedInsts_1_sltu | decodedInsts_1_xor
           | decodedInsts_1_or | decodedInsts_1_and | decodedInsts_1_xnor
           | decodedInsts_1_orn | decodedInsts_1_andn | decodedInsts_1_sll
           | decodedInsts_1_srl | decodedInsts_1_sra | _io_rs2Read_1_valid_T_19
           | decodedInsts_1_max | decodedInsts_1_maxu | decodedInsts_1_rol
           | decodedInsts_1_ror | _io_rs2Read_1_valid_T_25 | decodedInsts_1_sw
           | _io_rs2Read_1_valid_T_34 | decodedInsts_1_mulhsu | decodedInsts_1_mulhu
             ? 32'h1 << _GEN_9
             : 32'h0)) & comb_1} == 64'h0
    & ((_io_rs2Read_1_valid_T_25 | decodedInsts_1_sw | _io_rs2Read_1_valid_T_1
        | decodedInsts_1_blt | decodedInsts_1_bge | decodedInsts_1_bltu
        | decodedInsts_1_bgeu
          ? 32'h0
          : 32'h1 << io_inst_1_bits_inst[11:7]) & comb_1) == 32'h0
    & ~(_io_rs2Read_0_valid_T_1 | decodedInsts_0_blt | decodedInsts_0_bge
        | decodedInsts_0_bltu | decodedInsts_0_bgeu)
    & ~(_slot0Interlock_T | decodedInsts_0_wfi | decodedInsts_0_mpause
        | decodedInsts_0_flushat | decodedInsts_0_flushall | _io_rs2Set_0_valid_T_1
        | decodedInsts_0_csrrc)
    & {3'h0,
       _rdMark_valid_T_5 | decodedInsts_0_lw | decodedInsts_0_lbu | decodedInsts_0_lhu
         | _io_rs2Read_0_valid_T_25 | decodedInsts_0_sw | decodedInsts_0_flushat
         | decodedInsts_0_flushall | decodedInsts_d_float_y & _rdMark_flt_valid_T_4
         | decodedInsts_d_float_y & _io_float_valid_T_3} < {1'h0, io_lsuQueueCapacity}
    & (|{decodedInsts_1_lui,
         decodedInsts_1_auipc,
         decodedInsts_1_jal,
         decodedInsts_1_jalr,
         decodedInsts_1_beq,
         decodedInsts_1_bne,
         decodedInsts_1_blt,
         decodedInsts_1_bge,
         decodedInsts_1_bltu,
         decodedInsts_1_bgeu,
         decodedInsts_1_lb,
         decodedInsts_1_lh,
         decodedInsts_1_lw,
         decodedInsts_1_lbu,
         decodedInsts_1_lhu,
         decodedInsts_1_sb,
         decodedInsts_1_sh,
         decodedInsts_1_sw,
         decodedInsts_1_addi,
         decodedInsts_1_slti,
         decodedInsts_1_sltiu,
         decodedInsts_1_xori,
         decodedInsts_1_ori,
         decodedInsts_1_andi,
         decodedInsts_1_add,
         decodedInsts_1_sub,
         decodedInsts_1_slt,
         decodedInsts_1_sltu,
         decodedInsts_1_xor,
         decodedInsts_1_or,
         decodedInsts_1_and,
         decodedInsts_1_xnor,
         decodedInsts_1_orn,
         decodedInsts_1_andn,
         decodedInsts_1_slli,
         decodedInsts_1_srli,
         decodedInsts_1_srai,
         decodedInsts_1_sll,
         decodedInsts_1_srl,
         decodedInsts_1_sra,
         decodedInsts_1_mul,
         decodedInsts_1_mulh,
         decodedInsts_1_mulhsu,
         decodedInsts_1_mulhu,
         decodedInsts_1_clz,
         decodedInsts_1_ctz,
         decodedInsts_1_cpop,
         decodedInsts_1_min,
         decodedInsts_1_minu,
         decodedInsts_1_max,
         decodedInsts_1_maxu,
         decodedInsts_1_sextb,
         decodedInsts_1_sexth,
         decodedInsts_1_zexth,
         decodedInsts_1_rol,
         decodedInsts_1_ror,
         decodedInsts_1_orcb,
         decodedInsts_1_rev8,
         decodedInsts_1_rori});
  wire        _alu_T_39 = decodedInsts_1_auipc | decodedInsts_1_addi | decodedInsts_1_add;
  wire        _alu_T_40 = decodedInsts_1_slti | decodedInsts_1_slt;
  wire        _alu_T_41 = decodedInsts_1_sltiu | decodedInsts_1_sltu;
  wire        _alu_T_42 = decodedInsts_1_xori | decodedInsts_1_xor;
  wire        _alu_T_43 = decodedInsts_1_ori | decodedInsts_1_or;
  wire        _alu_T_44 = decodedInsts_1_andi | decodedInsts_1_and;
  wire        _alu_T_45 = decodedInsts_1_slli | decodedInsts_1_sll;
  wire        _alu_T_46 = decodedInsts_1_srli | decodedInsts_1_srl;
  wire        _alu_T_47 = decodedInsts_1_srai | decodedInsts_1_sra;
  wire        io_alu_1_valid_0 =
    tryDispatch_1
    & (_alu_T_39 | decodedInsts_1_sub | _alu_T_40 | _alu_T_41 | _alu_T_42 | _alu_T_43
       | _alu_T_44 | _alu_T_45 | _alu_T_46 | _alu_T_47 | decodedInsts_1_lui
       | decodedInsts_1_andn | decodedInsts_1_orn | decodedInsts_1_xnor
       | decodedInsts_1_clz | decodedInsts_1_ctz | decodedInsts_1_cpop
       | decodedInsts_1_max | decodedInsts_1_maxu | decodedInsts_1_min
       | decodedInsts_1_minu | decodedInsts_1_sextb | decodedInsts_1_sexth
       | decodedInsts_1_rol | decodedInsts_1_ror | decodedInsts_1_orcb
       | decodedInsts_1_rev8 | decodedInsts_1_zexth | decodedInsts_1_rori);
  wire [3:0]  bru_1_bits =
    decodedInsts_1_jal
      ? 4'h0
      : decodedInsts_1_jalr
          ? 4'h1
          : decodedInsts_1_beq
              ? 4'h2
              : decodedInsts_1_bne
                  ? 4'h3
                  : decodedInsts_1_blt
                      ? 4'h4
                      : decodedInsts_1_bge
                          ? 4'h5
                          : decodedInsts_1_bltu
                              ? 4'h6
                              : decodedInsts_1_bgeu ? 4'h7 : 4'h0;
  wire [31:0] _bru_target_T_5 =
    io_inst_1_bits_addr
    + {{12{io_inst_1_bits_inst[31]}},
       io_inst_1_bits_inst[2]
         ? {io_inst_1_bits_inst[19:12],
            io_inst_1_bits_inst[20],
            io_inst_1_bits_inst[30:21]}
         : {{8{io_inst_1_bits_inst[31]}},
            io_inst_1_bits_inst[7],
            io_inst_1_bits_inst[30:25],
            io_inst_1_bits_inst[11:8]},
       1'h0};
  wire        _io_bru_1_valid_T =
    tryDispatch_1
    & (decodedInsts_1_jal | decodedInsts_1_jalr | decodedInsts_1_beq | decodedInsts_1_bne
       | decodedInsts_1_blt | decodedInsts_1_bge | decodedInsts_1_bltu
       | decodedInsts_1_bgeu);
  wire        jalFault_1 =
    _io_bru_1_valid_T & bru_1_bits == 4'h0 & (|(_bru_target_T_5[1:0])) & ~io_branchTaken;
  wire        jalrFault_1 =
    _io_bru_1_valid_T & bru_1_bits == 4'h1 & io_jalrTarget_1_data[1] & ~io_branchTaken;
  wire        bxxFault_1 =
    _io_bru_1_valid_T
    & (|{bru_1_bits == 4'h7,
         bru_1_bits == 4'h6,
         bru_1_bits == 4'h5,
         bru_1_bits == 4'h4,
         bru_1_bits == 4'h3,
         bru_1_bits == 4'h2}) & (|(_bru_target_T_5[1:0])) & ~io_branchTaken;
  wire        io_bru_1_valid_0 =
    _io_bru_1_valid_T & ~(jalFault_1 | jalrFault_1 | bxxFault_1);
  wire        io_mlu_1_valid_0 =
    tryDispatch_1
    & (decodedInsts_1_mul | decodedInsts_1_mulh | decodedInsts_1_mulhsu
       | decodedInsts_1_mulhu);
  wire        io_lsu_1_valid_0 =
    tryDispatch_1
    & (decodedInsts_1_lb | decodedInsts_1_lh | decodedInsts_1_lw | decodedInsts_1_lbu
       | decodedInsts_1_lhu | decodedInsts_1_sb | decodedInsts_1_sh | decodedInsts_1_sw);
  wire        dispatched_2_1 = io_mlu_1_ready & io_mlu_1_valid_0;
  wire        dispatched_4_1 = io_lsu_1_ready & io_lsu_1_valid_0;
  wire        lastReady_2 =
    io_alu_1_valid_0 | io_bru_1_valid_0 | dispatched_2_1 | dispatched_4_1;
  wire        _io_rs2Set_0_valid_T = lastReady_1 & io_inst_0_valid;
  wire        _io_rs2Set_1_valid_T = lastReady_2 & io_inst_1_valid;
  assign io_csrFault_0 = csr_valid & ~csr_address_valid & tryDispatch;
  assign io_jalFault_0 = jalFault;
  assign io_jalFault_1 = jalFault_1;
  assign io_jalrFault_0 = jalrFault;
  assign io_jalrFault_1 = jalrFault_1;
  assign io_bxxFault_0 = bxxFault;
  assign io_bxxFault_1 = bxxFault_1;
  assign io_undefFault_0 =
    io_inst_0_valid
    & {decodedInsts_0_lui,
       decodedInsts_0_auipc,
       decodedInsts_0_jal,
       decodedInsts_0_jalr,
       decodedInsts_0_beq,
       decodedInsts_0_bne,
       decodedInsts_0_blt,
       decodedInsts_0_bge,
       decodedInsts_0_bltu,
       decodedInsts_0_bgeu,
       decodedInsts_0_csrrw,
       decodedInsts_0_csrrs,
       decodedInsts_0_csrrc,
       decodedInsts_0_lb,
       decodedInsts_0_lh,
       decodedInsts_0_lw,
       decodedInsts_0_lbu,
       decodedInsts_0_lhu,
       decodedInsts_0_sb,
       decodedInsts_0_sh,
       decodedInsts_0_sw,
       decodedInsts_0_fence,
       decodedInsts_0_addi,
       decodedInsts_0_slti,
       decodedInsts_0_sltiu,
       decodedInsts_0_xori,
       decodedInsts_0_ori,
       decodedInsts_0_andi,
       decodedInsts_0_add,
       decodedInsts_0_sub,
       decodedInsts_0_slt,
       decodedInsts_0_sltu,
       decodedInsts_0_xor,
       decodedInsts_0_or,
       decodedInsts_0_and,
       decodedInsts_0_xnor,
       decodedInsts_0_orn,
       decodedInsts_0_andn,
       decodedInsts_0_slli,
       decodedInsts_0_srli,
       decodedInsts_0_srai,
       decodedInsts_0_sll,
       decodedInsts_0_srl,
       decodedInsts_0_sra,
       decodedInsts_0_mul,
       decodedInsts_0_mulh,
       decodedInsts_0_mulhsu,
       decodedInsts_0_mulhu,
       decodedInsts_0_div,
       decodedInsts_0_divu,
       decodedInsts_0_rem,
       decodedInsts_0_remu,
       decodedInsts_0_clz,
       decodedInsts_0_ctz,
       decodedInsts_0_cpop,
       decodedInsts_0_min,
       decodedInsts_0_minu,
       decodedInsts_0_max,
       decodedInsts_0_maxu,
       decodedInsts_0_sextb,
       decodedInsts_0_sexth,
       decodedInsts_0_zexth,
       decodedInsts_0_rol,
       decodedInsts_0_ror,
       decodedInsts_0_orcb,
       decodedInsts_0_rev8,
       decodedInsts_0_rori,
       decodedInsts_0_ebreak,
       decodedInsts_0_ecall,
       decodedInsts_0_wfi,
       decodedInsts_0_mpause,
       decodedInsts_0_mret,
       decodedInsts_0_fencei,
       decodedInsts_0_flushat,
       decodedInsts_0_flushall,
       decodedInsts_slog,
       decodedInsts_d_float_y} == 77'h0;
  assign io_bruTarget_0 = _bru_target_T_2;
  assign io_bruTarget_1 = _bru_target_T_5;
  assign io_inst_0_ready = lastReady_1;
  assign io_inst_1_ready = lastReady_2;
  assign io_rs1Read_0_valid =
    _io_rs2Set_0_valid_T
    & (_io_rs2Read_0_valid_T_1 | decodedInsts_0_blt | decodedInsts_0_bge
       | decodedInsts_0_bltu | decodedInsts_0_bgeu | _io_rs2Read_0_valid_T_6
       | decodedInsts_0_slt | decodedInsts_0_sltu | decodedInsts_0_xor | decodedInsts_0_or
       | decodedInsts_0_and | decodedInsts_0_xnor | decodedInsts_0_orn
       | decodedInsts_0_andn | decodedInsts_0_sll | decodedInsts_0_srl
       | decodedInsts_0_sra | _io_rs2Set_0_valid_T_6 | decodedInsts_0_sltiu
       | decodedInsts_0_xori | decodedInsts_0_ori | decodedInsts_0_andi
       | decodedInsts_0_slli | decodedInsts_0_srli | decodedInsts_0_srai
       | decodedInsts_0_rori | _io_rs2Set_0_valid_T_16 | decodedInsts_0_cpop
       | decodedInsts_0_sextb | decodedInsts_0_sexth | decodedInsts_0_zexth
       | decodedInsts_0_orcb | decodedInsts_0_rev8 | _io_rs2Read_0_valid_T_19
       | decodedInsts_0_max | decodedInsts_0_maxu | decodedInsts_0_rol
       | decodedInsts_0_ror | _io_rs2Set_0_valid_T_1 | decodedInsts_0_csrrc
       | _io_rs2Read_0_valid_T_34 | decodedInsts_0_mulhsu | decodedInsts_0_mulhu
       | _io_rs2Read_0_valid_T_38 | decodedInsts_0_rem | decodedInsts_0_remu
       | decodedInsts_slog | decodedInsts_0_jalr | _io_rs1Read_0_valid_T_56);
  assign io_rs1Read_0_addr =
    io_inst_0_bits_inst[0] ? io_inst_0_bits_inst[19:15] : {4'h0, io_inst_0_bits_inst[27]};
  assign io_rs1Read_1_valid =
    _io_rs2Set_1_valid_T
    & (_io_rs2Read_1_valid_T_1 | decodedInsts_1_blt | decodedInsts_1_bge
       | decodedInsts_1_bltu | decodedInsts_1_bgeu | _io_rs2Read_1_valid_T_6
       | decodedInsts_1_slt | decodedInsts_1_sltu | decodedInsts_1_xor | decodedInsts_1_or
       | decodedInsts_1_and | decodedInsts_1_xnor | decodedInsts_1_orn
       | decodedInsts_1_andn | decodedInsts_1_sll | decodedInsts_1_srl
       | decodedInsts_1_sra | _io_rs2Set_1_valid_T_6 | decodedInsts_1_sltiu
       | decodedInsts_1_xori | decodedInsts_1_ori | decodedInsts_1_andi
       | decodedInsts_1_slli | decodedInsts_1_srli | decodedInsts_1_srai
       | decodedInsts_1_rori | _io_rs2Set_1_valid_T_16 | decodedInsts_1_cpop
       | decodedInsts_1_sextb | decodedInsts_1_sexth | decodedInsts_1_zexth
       | decodedInsts_1_orcb | decodedInsts_1_rev8 | _io_rs2Read_1_valid_T_19
       | decodedInsts_1_max | decodedInsts_1_maxu | decodedInsts_1_rol
       | decodedInsts_1_ror | _io_rs2Read_1_valid_T_34 | decodedInsts_1_mulhsu
       | decodedInsts_1_mulhu | decodedInsts_1_jalr);
  assign io_rs1Read_1_addr =
    io_inst_1_bits_inst[0] ? io_inst_1_bits_inst[19:15] : {4'h0, io_inst_1_bits_inst[28]};
  assign io_rs1Set_0_valid =
    _io_rs2Set_0_valid_T
    & (decodedInsts_0_auipc | (_io_rs2Set_0_valid_T_1 | decodedInsts_0_csrrc)
       & io_inst_0_bits_inst[14]);
  assign io_rs1Set_0_value =
    _io_rs2Set_0_valid_T_1 | decodedInsts_0_csrrc
      ? decodedInsts_0_immcsr
      : io_inst_0_bits_addr;
  assign io_rs1Set_1_valid = _io_rs2Set_1_valid_T & decodedInsts_1_auipc;
  assign io_rs1Set_1_value = io_inst_1_bits_addr;
  assign io_rs2Read_0_valid =
    _io_rs2Set_0_valid_T
    & (_io_rs2Read_0_valid_T_1 | decodedInsts_0_blt | decodedInsts_0_bge
       | decodedInsts_0_bltu | decodedInsts_0_bgeu | _io_rs2Read_0_valid_T_6
       | decodedInsts_0_slt | decodedInsts_0_sltu | decodedInsts_0_xor | decodedInsts_0_or
       | decodedInsts_0_and | decodedInsts_0_xnor | decodedInsts_0_orn
       | decodedInsts_0_andn | decodedInsts_0_sll | decodedInsts_0_srl
       | decodedInsts_0_sra | _io_rs2Read_0_valid_T_19 | decodedInsts_0_max
       | decodedInsts_0_maxu | decodedInsts_0_rol | decodedInsts_0_ror
       | _io_rs2Read_0_valid_T_25 | decodedInsts_0_sw
       | (_io_rs2Set_0_valid_T_1 | decodedInsts_0_csrrc) & ~(io_inst_0_bits_inst[14])
       | _io_rs2Read_0_valid_T_34 | decodedInsts_0_mulhsu | decodedInsts_0_mulhu
       | _io_rs2Read_0_valid_T_38 | decodedInsts_0_rem | decodedInsts_0_remu
       | decodedInsts_slog);
  assign io_rs2Read_0_addr = io_inst_0_bits_inst[24:20];
  assign io_rs2Read_1_valid =
    _io_rs2Set_1_valid_T
    & (_io_rs2Read_1_valid_T_1 | decodedInsts_1_blt | decodedInsts_1_bge
       | decodedInsts_1_bltu | decodedInsts_1_bgeu | _io_rs2Read_1_valid_T_6
       | decodedInsts_1_slt | decodedInsts_1_sltu | decodedInsts_1_xor | decodedInsts_1_or
       | decodedInsts_1_and | decodedInsts_1_xnor | decodedInsts_1_orn
       | decodedInsts_1_andn | decodedInsts_1_sll | decodedInsts_1_srl
       | decodedInsts_1_sra | _io_rs2Read_1_valid_T_19 | decodedInsts_1_max
       | decodedInsts_1_maxu | decodedInsts_1_rol | decodedInsts_1_ror
       | _io_rs2Read_1_valid_T_25 | decodedInsts_1_sw | _io_rs2Read_1_valid_T_34
       | decodedInsts_1_mulhsu | decodedInsts_1_mulhu);
  assign io_rs2Read_1_addr = io_inst_1_bits_inst[24:20];
  assign io_rs2Set_0_valid =
    _io_rs2Set_0_valid_T
    & (decodedInsts_0_auipc | (_io_rs2Set_0_valid_T_1 | decodedInsts_0_csrrc)
       & io_inst_0_bits_inst[14] | _io_rs2Set_0_valid_T_6 | decodedInsts_0_sltiu
       | decodedInsts_0_xori | decodedInsts_0_ori | decodedInsts_0_andi
       | decodedInsts_0_slli | decodedInsts_0_srli | decodedInsts_0_srai
       | decodedInsts_0_rori | _io_rs2Set_0_valid_T_16 | decodedInsts_0_cpop
       | decodedInsts_0_sextb | decodedInsts_0_sexth | decodedInsts_0_zexth
       | decodedInsts_0_orcb | decodedInsts_0_rev8 | decodedInsts_0_lui);
  assign io_rs2Set_0_value =
    decodedInsts_0_auipc | decodedInsts_0_lui
      ? {io_inst_0_bits_inst[31:12], 12'h0}
      : {_decodedInsts_d_imm12_T_1, io_inst_0_bits_inst[31:20]};
  assign io_rs2Set_1_valid =
    _io_rs2Set_1_valid_T
    & (decodedInsts_1_auipc | _io_rs2Set_1_valid_T_6 | decodedInsts_1_sltiu
       | decodedInsts_1_xori | decodedInsts_1_ori | decodedInsts_1_andi
       | decodedInsts_1_slli | decodedInsts_1_srli | decodedInsts_1_srai
       | decodedInsts_1_rori | _io_rs2Set_1_valid_T_16 | decodedInsts_1_cpop
       | decodedInsts_1_sextb | decodedInsts_1_sexth | decodedInsts_1_zexth
       | decodedInsts_1_orcb | decodedInsts_1_rev8 | decodedInsts_1_lui);
  assign io_rs2Set_1_value =
    decodedInsts_1_auipc | decodedInsts_1_lui
      ? {io_inst_1_bits_inst[31:12], 12'h0}
      : {_decodedInsts_d_imm12_T_5, io_inst_1_bits_inst[31:20]};
  assign io_rdMark_0_valid =
    io_alu_0_valid_0 | io_mlu_0_valid_0 | dispatched_3 | dispatched_4
    & (_rdMark_valid_T_5 | decodedInsts_0_lw | decodedInsts_0_lbu | decodedInsts_0_lhu)
    | io_csr_valid_0 | dispatched_8 & decodedInsts_d_float_scalar_rd | io_bru_0_valid_0
    & (|{bru_bits == 4'h1, bru_bits == 4'h0}) & (|(io_inst_0_bits_inst[11:7]));
  assign io_rdMark_0_addr = io_inst_0_bits_inst[11:7];
  assign io_rdMark_1_valid =
    io_alu_1_valid_0 | dispatched_2_1 | dispatched_4_1
    & (_rdMark_valid_T_28 | decodedInsts_1_lw | decodedInsts_1_lbu | decodedInsts_1_lhu)
    | io_bru_1_valid_0 & (|{bru_1_bits == 4'h1, bru_1_bits == 4'h0})
    & (|(io_inst_1_bits_inst[11:7]));
  assign io_rdMark_1_addr = io_inst_1_bits_inst[11:7];
  assign io_busRead_0_bypass =
    io_inst_0_bits_inst[31:25] == 7'h0
    & (~(io_inst_0_bits_inst[5]) | io_inst_0_bits_inst[6]
         ? io_inst_0_bits_inst[24:20] == 5'h0
         : io_inst_0_bits_inst[11:7] == 5'h0);
  assign io_busRead_0_immen = ~decodedInsts_0_flushat;
  assign io_busRead_0_immed =
    {_decodedInsts_d_imm12_T_1,
     io_inst_0_bits_inst[31:25],
     io_inst_0_bits_inst[6:3] == 4'h4 & (&(io_inst_0_bits_inst[1:0]))
       ? io_inst_0_bits_inst[11:7]
       : io_inst_0_bits_inst[24:20]};
  assign io_busRead_1_bypass =
    io_inst_1_bits_inst[31:25] == 7'h0
    & (~(io_inst_1_bits_inst[5]) | io_inst_1_bits_inst[6]
         ? io_inst_1_bits_inst[24:20] == 5'h0
         : io_inst_1_bits_inst[11:7] == 5'h0);
  assign io_busRead_1_immed =
    {_decodedInsts_d_imm12_T_5,
     io_inst_1_bits_inst[31:25],
     io_inst_1_bits_inst[6:3] == 4'h4 & (&(io_inst_1_bits_inst[1:0]))
       ? io_inst_1_bits_inst[11:7]
       : io_inst_1_bits_inst[24:20]};
  assign io_rdMark_flt_valid =
    dispatched_8 & ~decodedInsts_d_float_scalar_rd | dispatched_4 & decodedInsts_d_float_y
    & _rdMark_flt_valid_T_4;
  assign io_rdMark_flt_addr = io_inst_0_bits_inst[11:7];
  assign io_alu_0_valid = io_alu_0_valid_0;
  assign io_alu_0_bits_addr = io_inst_0_bits_inst[11:7];
  assign io_alu_0_bits_op =
    _alu_T_1
      ? 5'h0
      : decodedInsts_0_sub
          ? 5'h1
          : _alu_T_2
              ? 5'h2
              : _alu_T_3
                  ? 5'h3
                  : _alu_T_4
                      ? 5'h4
                      : _alu_T_5
                          ? 5'h5
                          : _alu_T_6
                              ? 5'h6
                              : _alu_T_7
                                  ? 5'h7
                                  : _alu_T_8
                                      ? 5'h8
                                      : _alu_T_9
                                          ? 5'h9
                                          : decodedInsts_0_lui
                                              ? 5'hA
                                              : decodedInsts_0_andn
                                                  ? 5'hB
                                                  : decodedInsts_0_orn
                                                      ? 5'hC
                                                      : decodedInsts_0_xnor
                                                          ? 5'hD
                                                          : decodedInsts_0_clz
                                                              ? 5'hE
                                                              : decodedInsts_0_ctz
                                                                  ? 5'hF
                                                                  : decodedInsts_0_cpop
                                                                      ? 5'h10
                                                                      : decodedInsts_0_max
                                                                          ? 5'h11
                                                                          : decodedInsts_0_maxu
                                                                              ? 5'h12
                                                                              : decodedInsts_0_min
                                                                                  ? 5'h13
                                                                                  : decodedInsts_0_minu
                                                                                      ? 5'h14
                                                                                      : decodedInsts_0_sextb
                                                                                          ? 5'h15
                                                                                          : decodedInsts_0_sexth
                                                                                              ? 5'h16
                                                                                              : decodedInsts_0_rol
                                                                                                  ? 5'h17
                                                                                                  : decodedInsts_0_ror
                                                                                                      ? 5'h18
                                                                                                      : decodedInsts_0_orcb
                                                                                                          ? 5'h19
                                                                                                          : decodedInsts_0_rev8
                                                                                                              ? 5'h1A
                                                                                                              : decodedInsts_0_zexth
                                                                                                                  ? 5'h1B
                                                                                                                  : decodedInsts_0_rori
                                                                                                                      ? 5'h18
                                                                                                                      : 5'h0;
  assign io_alu_1_valid = io_alu_1_valid_0;
  assign io_alu_1_bits_addr = io_inst_1_bits_inst[11:7];
  assign io_alu_1_bits_op =
    _alu_T_39
      ? 5'h0
      : decodedInsts_1_sub
          ? 5'h1
          : _alu_T_40
              ? 5'h2
              : _alu_T_41
                  ? 5'h3
                  : _alu_T_42
                      ? 5'h4
                      : _alu_T_43
                          ? 5'h5
                          : _alu_T_44
                              ? 5'h6
                              : _alu_T_45
                                  ? 5'h7
                                  : _alu_T_46
                                      ? 5'h8
                                      : _alu_T_47
                                          ? 5'h9
                                          : decodedInsts_1_lui
                                              ? 5'hA
                                              : decodedInsts_1_andn
                                                  ? 5'hB
                                                  : decodedInsts_1_orn
                                                      ? 5'hC
                                                      : decodedInsts_1_xnor
                                                          ? 5'hD
                                                          : decodedInsts_1_clz
                                                              ? 5'hE
                                                              : decodedInsts_1_ctz
                                                                  ? 5'hF
                                                                  : decodedInsts_1_cpop
                                                                      ? 5'h10
                                                                      : decodedInsts_1_max
                                                                          ? 5'h11
                                                                          : decodedInsts_1_maxu
                                                                              ? 5'h12
                                                                              : decodedInsts_1_min
                                                                                  ? 5'h13
                                                                                  : decodedInsts_1_minu
                                                                                      ? 5'h14
                                                                                      : decodedInsts_1_sextb
                                                                                          ? 5'h15
                                                                                          : decodedInsts_1_sexth
                                                                                              ? 5'h16
                                                                                              : decodedInsts_1_rol
                                                                                                  ? 5'h17
                                                                                                  : decodedInsts_1_ror
                                                                                                      ? 5'h18
                                                                                                      : decodedInsts_1_orcb
                                                                                                          ? 5'h19
                                                                                                          : decodedInsts_1_rev8
                                                                                                              ? 5'h1A
                                                                                                              : decodedInsts_1_zexth
                                                                                                                  ? 5'h1B
                                                                                                                  : decodedInsts_1_rori
                                                                                                                      ? 5'h18
                                                                                                                      : 5'h0;
  assign io_bru_0_valid = io_bru_0_valid_0;
  assign io_bru_0_bits_fwd = io_inst_0_bits_brchFwd;
  assign io_bru_0_bits_op = bru_bits;
  assign io_bru_0_bits_pc = io_inst_0_bits_addr;
  assign io_bru_0_bits_target = _bru_target_T_2;
  assign io_bru_0_bits_link = io_inst_0_bits_inst[11:7];
  assign io_bru_1_valid = io_bru_1_valid_0;
  assign io_bru_1_bits_fwd = io_inst_1_bits_brchFwd;
  assign io_bru_1_bits_op = bru_1_bits;
  assign io_bru_1_bits_pc = io_inst_1_bits_addr;
  assign io_bru_1_bits_target = _bru_target_T_5;
  assign io_bru_1_bits_link = io_inst_1_bits_inst[11:7];
  assign io_csr_valid = io_csr_valid_0;
  assign io_csr_bits_addr = io_inst_0_bits_inst[11:7];
  assign io_csr_bits_index = io_inst_0_bits_inst[31:20];
  assign io_csr_bits_op =
    decodedInsts_0_csrrw
      ? 2'h0
      : decodedInsts_0_csrrs ? 2'h1 : {decodedInsts_0_csrrc, 1'h0};
  assign io_lsu_0_valid = io_lsu_0_valid_0;
  assign io_lsu_0_bits_store = io_inst_0_bits_inst[5];
  assign io_lsu_0_bits_addr = io_inst_0_bits_inst[11:7];
  assign io_lsu_0_bits_op =
    decodedInsts_0_lb
      ? 5'h0
      : decodedInsts_0_lh
          ? 5'h1
          : decodedInsts_0_lw
              ? 5'h2
              : decodedInsts_0_lbu
                  ? 5'h3
                  : decodedInsts_0_lhu
                      ? 5'h4
                      : decodedInsts_0_sb
                          ? 5'h5
                          : decodedInsts_0_sh
                              ? 5'h6
                              : decodedInsts_0_sw
                                  ? 5'h7
                                  : decodedInsts_0_wfi | decodedInsts_0_fencei
                                      ? 5'h8
                                      : decodedInsts_0_flushat
                                          ? 5'h9
                                          : decodedInsts_0_flushall
                                              ? 5'hA
                                              : _lsu_T_5_valid ? 5'hC : 5'h0;
  assign io_lsu_0_bits_pc = io_inst_0_bits_addr;
  assign io_lsu_1_valid = io_lsu_1_valid_0;
  assign io_lsu_1_bits_store = io_inst_1_bits_inst[5];
  assign io_lsu_1_bits_addr = io_inst_1_bits_inst[11:7];
  assign io_lsu_1_bits_op =
    decodedInsts_1_lb
      ? 5'h0
      : decodedInsts_1_lh
          ? 5'h1
          : decodedInsts_1_lw
              ? 5'h2
              : decodedInsts_1_lbu
                  ? 5'h3
                  : decodedInsts_1_lhu
                      ? 5'h4
                      : decodedInsts_1_sb
                          ? 5'h5
                          : decodedInsts_1_sh ? 5'h6 : decodedInsts_1_sw ? 5'h7 : 5'h0;
  assign io_lsu_1_bits_pc = io_inst_1_bits_addr;
  assign io_mlu_0_valid = io_mlu_0_valid_0;
  assign io_mlu_0_bits_addr = io_inst_0_bits_inst[11:7];
  assign io_mlu_0_bits_op =
    decodedInsts_0_mul
      ? 3'h0
      : decodedInsts_0_mulh
          ? 3'h1
          : decodedInsts_0_mulhsu ? 3'h2 : decodedInsts_0_mulhu ? 3'h3 : 3'h0;
  assign io_mlu_1_valid = io_mlu_1_valid_0;
  assign io_mlu_1_bits_addr = io_inst_1_bits_inst[11:7];
  assign io_mlu_1_bits_op =
    decodedInsts_1_mul
      ? 3'h0
      : decodedInsts_1_mulh
          ? 3'h1
          : decodedInsts_1_mulhsu ? 3'h2 : decodedInsts_1_mulhu ? 3'h3 : 3'h0;
  assign io_dvu_0_valid = io_dvu_0_valid_0;
  assign io_dvu_0_bits_addr = io_inst_0_bits_inst[11:7];
  assign io_dvu_0_bits_op =
    decodedInsts_0_div
      ? 2'h0
      : decodedInsts_0_divu ? 2'h1 : decodedInsts_0_rem ? 2'h2 : {2{decodedInsts_0_remu}};
  assign io_float_valid = io_float_valid_0;
  assign io_float_bits_opcode = decodedInsts_d_float_opcode_bits;
  assign io_float_bits_funct5 = io_inst_0_bits_inst[31:27];
  assign io_float_bits_rs3 = io_inst_0_bits_inst[31:27];
  assign io_float_bits_rs2 = io_inst_0_bits_inst[24:20];
  assign io_float_bits_rs1 = io_inst_0_bits_inst[19:15];
  assign io_float_bits_rm = io_inst_0_bits_inst[14:12];
  assign io_float_bits_inst = io_inst_0_bits_inst;
  assign io_float_bits_pc = io_inst_0_bits_addr;
  assign io_float_bits_scalar_rd = decodedInsts_d_float_scalar_rd;
  assign io_float_bits_scalar_rs1 = decodedInsts_d_float_scalar_rs1;
  assign io_float_bits_rd = io_inst_0_bits_inst[11:7];
  assign io_float_bits_uses_rs3 = |_decodedInsts_d_float_uses_rs3_T_4;
  assign io_float_bits_uses_rs2 = decodedInsts_d_float_uses_rs2;
  assign io_fbusPortAddr = io_inst_0_bits_inst[24:20];
  assign io_slog = io_slog_0;
endmodule

module Alu(
  input         clock,
                reset,
                io_req_valid,
  input  [4:0]  io_req_bits_addr,
                io_req_bits_op,
  input         io_rs1_valid,
  input  [31:0] io_rs1_data,
  input         io_rs2_valid,
  input  [31:0] io_rs2_data,
  output        io_rd_valid,
  output [4:0]  io_rd_bits_addr,
  output [31:0] io_rd_bits_data
);

  reg               valid;
  reg  [4:0]        addr;
  reg  [4:0]        op;
  wire              r2IsGreater = $signed(io_rs1_data) < $signed(io_rs2_data);
  wire              r2IsGreaterU = io_rs1_data < io_rs2_data;
  wire [31:0]       _io_rd_bits_data_T_19 = io_rs1_data ^ io_rs2_data;
  wire [62:0]       _io_rd_bits_data_T_7 = {31'h0, io_rs1_data} << io_rs2_data[4:0];
  wire [31:0]       _GEN = {27'h0, io_rs2_data[4:0]};
  wire [31:0]       _io_rd_bits_data_T_29 =
    {16'h0, io_rs1_data[31:16]} | {io_rs1_data[15:0], 16'h0};
  wire [31:0]       _io_rd_bits_data_T_39 =
    {8'h0, _io_rd_bits_data_T_29[31:8] & 24'hFF00FF}
    | {_io_rd_bits_data_T_29[23:0] & 24'hFF00FF, 8'h0};
  wire [31:0]       _io_rd_bits_data_T_49 =
    {4'h0, _io_rd_bits_data_T_39[31:4] & 28'hF0F0F0F}
    | {_io_rd_bits_data_T_39[27:0] & 28'hF0F0F0F, 4'h0};
  wire [31:0]       _io_rd_bits_data_T_59 =
    {2'h0, _io_rd_bits_data_T_49[31:2] & 30'h33333333}
    | {_io_rd_bits_data_T_49[29:0] & 30'h33333333, 2'h0};
  wire [31:0]       _io_rd_bits_data_T_69 =
    {1'h0, _io_rd_bits_data_T_59[31:1] & 31'h55555555}
    | {_io_rd_bits_data_T_59[30:0] & 31'h55555555, 1'h0};
  wire [31:0]       _io_rd_bits_data_T_312 =
    io_rs2_data[0] ? {io_rs1_data[30:0], io_rs1_data[31]} : io_rs1_data;
  wire [31:0]       _io_rd_bits_data_T_316 =
    io_rs2_data[1]
      ? {_io_rd_bits_data_T_312[29:0], _io_rd_bits_data_T_312[31:30]}
      : _io_rd_bits_data_T_312;
  wire [31:0]       _io_rd_bits_data_T_320 =
    io_rs2_data[2]
      ? {_io_rd_bits_data_T_316[27:0], _io_rd_bits_data_T_316[31:28]}
      : _io_rd_bits_data_T_316;
  wire [31:0]       _io_rd_bits_data_T_324 =
    io_rs2_data[3]
      ? {_io_rd_bits_data_T_320[23:0], _io_rd_bits_data_T_320[31:24]}
      : _io_rd_bits_data_T_320;
  wire [31:0]       _io_rd_bits_data_T_337 =
    io_rs2_data[0] ? {io_rs1_data[0], io_rs1_data[31:1]} : io_rs1_data;
  wire [31:0]       _io_rd_bits_data_T_341 =
    io_rs2_data[1]
      ? {_io_rd_bits_data_T_337[1:0], _io_rd_bits_data_T_337[31:2]}
      : _io_rd_bits_data_T_337;
  wire [31:0]       _io_rd_bits_data_T_345 =
    io_rs2_data[2]
      ? {_io_rd_bits_data_T_341[3:0], _io_rd_bits_data_T_341[31:4]}
      : _io_rd_bits_data_T_341;
  wire [31:0]       _io_rd_bits_data_T_349 =
    io_rs2_data[3]
      ? {_io_rd_bits_data_T_345[7:0], _io_rd_bits_data_T_345[31:8]}
      : _io_rd_bits_data_T_345;
  wire [31:0][31:0] _GEN_0 =
    {{32'h0},
     {32'h0},
     {32'h0},
     {32'h0},
     {{16'h0, io_rs1_data[15:0]}},
     {{io_rs1_data[7:0], io_rs1_data[15:8], io_rs1_data[23:16], io_rs1_data[31:24]}},
     {{io_rs1_data[31:24] == 8'h0 ? 8'h0 : 8'hFF,
       io_rs1_data[23:16] == 8'h0 ? 8'h0 : 8'hFF,
       io_rs1_data[15:8] == 8'h0 ? 8'h0 : 8'hFF,
       io_rs1_data[7:0] == 8'h0 ? 8'h0 : 8'hFF}},
     {io_rs2_data[4]
        ? {_io_rd_bits_data_T_349[15:0], _io_rd_bits_data_T_349[31:16]}
        : _io_rd_bits_data_T_349},
     {io_rs2_data[4]
        ? {_io_rd_bits_data_T_324[15:0], _io_rd_bits_data_T_324[31:16]}
        : _io_rd_bits_data_T_324},
     {{{16{io_rs1_data[15]}}, io_rs1_data[15:0]}},
     {{{24{io_rs1_data[7]}}, io_rs1_data[7:0]}},
     {r2IsGreaterU ? io_rs1_data : io_rs2_data},
     {r2IsGreater ? io_rs1_data : io_rs2_data},
     {r2IsGreaterU ? io_rs2_data : io_rs1_data},
     {r2IsGreater ? io_rs2_data : io_rs1_data},
     {{26'h0,
       {1'h0,
        {1'h0,
         {1'h0,
          {1'h0, {1'h0, io_rs1_data[0]} + {1'h0, io_rs1_data[1]}}
            + {1'h0, {1'h0, io_rs1_data[2]} + {1'h0, io_rs1_data[3]}}}
           + {1'h0,
              {1'h0, {1'h0, io_rs1_data[4]} + {1'h0, io_rs1_data[5]}}
                + {1'h0, {1'h0, io_rs1_data[6]} + {1'h0, io_rs1_data[7]}}}}
          + {1'h0,
             {1'h0,
              {1'h0, {1'h0, io_rs1_data[8]} + {1'h0, io_rs1_data[9]}}
                + {1'h0, {1'h0, io_rs1_data[10]} + {1'h0, io_rs1_data[11]}}}
               + {1'h0,
                  {1'h0, {1'h0, io_rs1_data[12]} + {1'h0, io_rs1_data[13]}}
                    + {1'h0, {1'h0, io_rs1_data[14]} + {1'h0, io_rs1_data[15]}}}}}
         + {1'h0,
            {1'h0,
             {1'h0,
              {1'h0, {1'h0, io_rs1_data[16]} + {1'h0, io_rs1_data[17]}}
                + {1'h0, {1'h0, io_rs1_data[18]} + {1'h0, io_rs1_data[19]}}}
               + {1'h0,
                  {1'h0, {1'h0, io_rs1_data[20]} + {1'h0, io_rs1_data[21]}}
                    + {1'h0, {1'h0, io_rs1_data[22]} + {1'h0, io_rs1_data[23]}}}}
              + {1'h0,
                 {1'h0,
                  {1'h0, {1'h0, io_rs1_data[24]} + {1'h0, io_rs1_data[25]}}
                    + {1'h0, {1'h0, io_rs1_data[26]} + {1'h0, io_rs1_data[27]}}}
                   + {1'h0,
                      {1'h0, {1'h0, io_rs1_data[28]} + {1'h0, io_rs1_data[29]}}
                        + {1'h0, {1'h0, io_rs1_data[30]} + {1'h0, io_rs1_data[31]}}}}}}},
     {{26'h0,
       io_rs1_data[0]
         ? 6'h0
         : io_rs1_data[1]
             ? 6'h1
             : io_rs1_data[2]
                 ? 6'h2
                 : io_rs1_data[3]
                     ? 6'h3
                     : io_rs1_data[4]
                         ? 6'h4
                         : io_rs1_data[5]
                             ? 6'h5
                             : io_rs1_data[6]
                                 ? 6'h6
                                 : io_rs1_data[7]
                                     ? 6'h7
                                     : io_rs1_data[8]
                                         ? 6'h8
                                         : io_rs1_data[9]
                                             ? 6'h9
                                             : io_rs1_data[10]
                                                 ? 6'hA
                                                 : io_rs1_data[11]
                                                     ? 6'hB
                                                     : io_rs1_data[12]
                                                         ? 6'hC
                                                         : io_rs1_data[13]
                                                             ? 6'hD
                                                             : io_rs1_data[14]
                                                                 ? 6'hE
                                                                 : io_rs1_data[15]
                                                                     ? 6'hF
                                                                     : io_rs1_data[16]
                                                                         ? 6'h10
                                                                         : io_rs1_data[17]
                                                                             ? 6'h11
                                                                             : io_rs1_data[18]
                                                                                 ? 6'h12
                                                                                 : io_rs1_data[19]
                                                                                     ? 6'h13
                                                                                     : io_rs1_data[20]
                                                                                         ? 6'h14
                                                                                         : io_rs1_data[21]
                                                                                             ? 6'h15
                                                                                             : io_rs1_data[22]
                                                                                                 ? 6'h16
                                                                                                 : io_rs1_data[23]
                                                                                                     ? 6'h17
                                                                                                     : io_rs1_data[24]
                                                                                                         ? 6'h18
                                                                                                         : io_rs1_data[25]
                                                                                                             ? 6'h19
                                                                                                             : io_rs1_data[26]
                                                                                                                 ? 6'h1A
                                                                                                                 : io_rs1_data[27]
                                                                                                                     ? 6'h1B
                                                                                                                     : io_rs1_data[28]
                                                                                                                         ? 6'h1C
                                                                                                                         : io_rs1_data[29]
                                                                                                                             ? 6'h1D
                                                                                                                             : io_rs1_data[30]
                                                                                                                                 ? 6'h1E
                                                                                                                                 : io_rs1_data[31]
                                                                                                                                     ? 6'h1F
                                                                                                                                     : 6'h20}},
     {{26'h0,
       _io_rd_bits_data_T_69[0]
         ? 6'h0
         : _io_rd_bits_data_T_69[1]
             ? 6'h1
             : _io_rd_bits_data_T_69[2]
                 ? 6'h2
                 : _io_rd_bits_data_T_69[3]
                     ? 6'h3
                     : _io_rd_bits_data_T_69[4]
                         ? 6'h4
                         : _io_rd_bits_data_T_69[5]
                             ? 6'h5
                             : _io_rd_bits_data_T_69[6]
                                 ? 6'h6
                                 : _io_rd_bits_data_T_69[7]
                                     ? 6'h7
                                     : _io_rd_bits_data_T_69[8]
                                         ? 6'h8
                                         : _io_rd_bits_data_T_69[9]
                                             ? 6'h9
                                             : _io_rd_bits_data_T_69[10]
                                                 ? 6'hA
                                                 : _io_rd_bits_data_T_69[11]
                                                     ? 6'hB
                                                     : _io_rd_bits_data_T_69[12]
                                                         ? 6'hC
                                                         : _io_rd_bits_data_T_69[13]
                                                             ? 6'hD
                                                             : _io_rd_bits_data_T_69[14]
                                                                 ? 6'hE
                                                                 : _io_rd_bits_data_T_69[15]
                                                                     ? 6'hF
                                                                     : _io_rd_bits_data_T_69[16]
                                                                         ? 6'h10
                                                                         : _io_rd_bits_data_T_69[17]
                                                                             ? 6'h11
                                                                             : _io_rd_bits_data_T_69[18]
                                                                                 ? 6'h12
                                                                                 : _io_rd_bits_data_T_69[19]
                                                                                     ? 6'h13
                                                                                     : _io_rd_bits_data_T_69[20]
                                                                                         ? 6'h14
                                                                                         : _io_rd_bits_data_T_69[21]
                                                                                             ? 6'h15
                                                                                             : _io_rd_bits_data_T_69[22]
                                                                                                 ? 6'h16
                                                                                                 : _io_rd_bits_data_T_69[23]
                                                                                                     ? 6'h17
                                                                                                     : _io_rd_bits_data_T_69[24]
                                                                                                         ? 6'h18
                                                                                                         : _io_rd_bits_data_T_69[25]
                                                                                                             ? 6'h19
                                                                                                             : _io_rd_bits_data_T_69[26]
                                                                                                                 ? 6'h1A
                                                                                                                 : _io_rd_bits_data_T_69[27]
                                                                                                                     ? 6'h1B
                                                                                                                     : _io_rd_bits_data_T_69[28]
                                                                                                                         ? 6'h1C
                                                                                                                         : _io_rd_bits_data_T_69[29]
                                                                                                                             ? 6'h1D
                                                                                                                             : _io_rd_bits_data_T_69[30]
                                                                                                                                 ? 6'h1E
                                                                                                                                 : _io_rd_bits_data_T_69[31]
                                                                                                                                     ? 6'h1F
                                                                                                                                     : 6'h20}},
     {~_io_rd_bits_data_T_19},
     {io_rs1_data | ~io_rs2_data},
     {io_rs1_data & ~io_rs2_data},
     {io_rs2_data},
     {$signed($signed(io_rs1_data) >>> _GEN)},
     {io_rs1_data >> _GEN},
     {_io_rd_bits_data_T_7[31:0]},
     {io_rs1_data & io_rs2_data},
     {io_rs1_data | io_rs2_data},
     {_io_rd_bits_data_T_19},
     {{31'h0, r2IsGreaterU}},
     {{31'h0, r2IsGreater}},
     {io_rs1_data - io_rs2_data},
     {io_rs1_data + io_rs2_data}};
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      valid <= 1'h0;
      addr <= 5'h0;
      op <= 5'h0;
    end
    else begin
      valid <= io_req_valid;
      if (io_req_valid) begin
        addr <= io_req_bits_addr;
        op <= io_req_bits_op;
      end
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        valid = _RANDOM[/*Zero width*/ 1'b0][0];
        addr = _RANDOM[/*Zero width*/ 1'b0][5:1];
        op = _RANDOM[/*Zero width*/ 1'b0][10:6];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        valid = 1'h0;
        addr = 5'h0;
        op = 5'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_rd_valid = valid;
  assign io_rd_bits_addr = addr;
  assign io_rd_bits_data = _GEN_0[op];
endmodule

module Bru(
  input         clock,
                reset,
                io_req_valid,
                io_req_bits_fwd,
  input  [3:0]  io_req_bits_op,
  input  [31:0] io_req_bits_pc,
                io_req_bits_target,
  input  [4:0]  io_req_bits_link,
  output        io_csr_in_mode_valid,
  output [1:0]  io_csr_in_mode_bits,
  output        io_csr_in_mcause_valid,
  output [31:0] io_csr_in_mcause_bits,
  output        io_csr_in_mepc_valid,
  output [31:0] io_csr_in_mepc_bits,
  output        io_csr_in_mtval_valid,
  output [31:0] io_csr_in_mtval_bits,
  output        io_csr_in_halt,
                io_csr_in_fault,
                io_csr_in_wfi,
  input  [1:0]  io_csr_out_mode,
  input  [31:0] io_csr_out_mepc,
                io_csr_out_mtvec,
  input         io_rs1_valid,
  input  [31:0] io_rs1_data,
  input         io_rs2_valid,
  input  [31:0] io_rs2_data,
  output        io_rd_valid,
  output [4:0]  io_rd_bits_addr,
  output [31:0] io_rd_bits_data,
  output        io_taken_valid,
  output [31:0] io_taken_value,
  input  [31:0] io_target_data,
  output        io_interlock,
  input         io_fault_manager_valid,
  input  [31:0] io_fault_manager_bits_mepc,
                io_fault_manager_bits_mtval,
                io_fault_manager_bits_mcause
);

  wire        io_csr_in_fault_0;
  reg         stateReg_valid;
  reg         stateReg_bits_fwd;
  reg  [3:0]  stateReg_bits_op;
  reg  [31:0] stateReg_bits_target;
  reg         stateReg_bits_linkValid;
  reg  [4:0]  stateReg_bits_linkAddr;
  reg  [31:0] stateReg_bits_linkData;
  reg  [31:0] stateReg_bits_pcEx;
  wire        _io_csr_in_fault_T = io_csr_out_mode == 2'h0;
  wire        _io_csr_in_mcause_bits_T_4 = io_csr_out_mode == 2'h1;
  wire        _ignore_T_2 = stateReg_bits_op == 4'h8;
  wire        _ignore_T_3 = stateReg_bits_op == 4'h9;
  wire        _ignore_T_4 = stateReg_bits_op == 4'hA;
  wire        _ignore_T_5 = stateReg_bits_op == 4'hB;
  wire        _ignore_T_7 = stateReg_bits_op == 4'hD;
  wire        usageFault =
    stateReg_valid
    & (_io_csr_in_mcause_bits_T_4 ? (|{_ignore_T_5, _ignore_T_4}) : _ignore_T_2);
  assign io_csr_in_fault_0 = usageFault & _io_csr_in_fault_T;
  wire        _ignore_T_6 = stateReg_bits_op == 4'hC;
  wire [31:0] nextState_linkData = io_req_bits_pc + 32'h4;
  wire        _nextState_target_T = io_req_bits_op == 4'h1;
  wire [31:0] mtvec = {io_csr_out_mtvec[31:2], 2'h0};
  wire        _pipeline0Target_call_T = io_req_bits_op == 4'hB;
  wire        stateRegValid = io_req_valid | io_fault_manager_valid;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      stateReg_valid <= 1'h0;
      stateReg_bits_fwd <= 1'h0;
      stateReg_bits_op <= 4'h0;
      stateReg_bits_target <= 32'h0;
      stateReg_bits_linkValid <= 1'h0;
      stateReg_bits_linkAddr <= 5'h0;
      stateReg_bits_linkData <= 32'h0;
      stateReg_bits_pcEx <= 32'h0;
    end
    else begin
      stateReg_valid <= stateRegValid;
      if (stateRegValid) begin
        stateReg_bits_fwd <= io_req_valid & io_req_bits_fwd;
        stateReg_bits_op <= io_fault_manager_valid ? 4'hD : io_req_bits_op;
        stateReg_bits_target <=
          io_fault_manager_valid
            ? mtvec
            : io_req_bits_fwd
                ? nextState_linkData
                : _nextState_target_T
                    ? io_target_data & 32'hFFFFFFFE
                    : io_req_bits_op == 4'h9
                        ? mtvec
                        : (|{_pipeline0Target_call_T & _io_csr_in_fault_T,
                             _pipeline0Target_call_T & _io_csr_in_mcause_bits_T_4,
                             io_req_bits_op == 4'hA,
                             io_req_bits_op == 4'h8})
                            ? io_csr_out_mepc
                            : io_req_bits_op == 4'hC
                                ? nextState_linkData
                                : io_req_bits_target;
        stateReg_bits_linkValid <=
          io_req_valid & (|io_req_bits_link)
          & (|{_nextState_target_T, io_req_bits_op == 4'h0});
        stateReg_bits_linkAddr <= io_req_bits_link;
        stateReg_bits_linkData <= nextState_linkData;
        stateReg_bits_pcEx <= io_req_bits_pc;
      end
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:3];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h4; i += 3'h1) begin
          _RANDOM[i[1:0]] = `RANDOM;
        end
        stateReg_valid = _RANDOM[2'h0][0];
        stateReg_bits_fwd = _RANDOM[2'h0][1];
        stateReg_bits_op = _RANDOM[2'h0][5:2];
        stateReg_bits_target = {_RANDOM[2'h0][31:6], _RANDOM[2'h1][5:0]};
        stateReg_bits_linkValid = _RANDOM[2'h1][6];
        stateReg_bits_linkAddr = _RANDOM[2'h1][11:7];
        stateReg_bits_linkData = {_RANDOM[2'h1][31:12], _RANDOM[2'h2][11:0]};
        stateReg_bits_pcEx = {_RANDOM[2'h2][31:12], _RANDOM[2'h3][11:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        stateReg_valid = 1'h0;
        stateReg_bits_fwd = 1'h0;
        stateReg_bits_op = 4'h0;
        stateReg_bits_target = 32'h0;
        stateReg_bits_linkValid = 1'h0;
        stateReg_bits_linkAddr = 5'h0;
        stateReg_bits_linkData = 32'h0;
        stateReg_bits_pcEx = 32'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_csr_in_mode_valid =
    stateReg_valid
    & (_io_csr_in_mcause_bits_T_4
         ? (|{_ignore_T_7, _ignore_T_5, _ignore_T_4, _ignore_T_3, _ignore_T_2})
         : _ignore_T_5);
  assign io_csr_in_mode_bits = {1'h0, ~(_ignore_T_5 & _io_csr_in_fault_T)};
  assign io_csr_in_mcause_valid =
    stateReg_valid & (usageFault | _ignore_T_3 | _io_csr_in_mcause_bits_T_4 & _ignore_T_2)
    | io_fault_manager_valid;
  assign io_csr_in_mcause_bits =
    io_fault_manager_valid
      ? io_fault_manager_bits_mcause
      : {27'h0,
         _ignore_T_3 & _io_csr_in_fault_T
           ? 5'hB
           : _ignore_T_3 & _io_csr_in_mcause_bits_T_4
               ? 5'h8
               : _ignore_T_2 ? 5'h3 : usageFault ? 5'h19 : 5'h0};
  assign io_csr_in_mepc_valid = stateReg_valid & _ignore_T_3 | io_fault_manager_valid;
  assign io_csr_in_mepc_bits =
    io_fault_manager_valid ? io_fault_manager_bits_mepc : stateReg_bits_pcEx;
  assign io_csr_in_mtval_valid = usageFault | io_fault_manager_valid;
  assign io_csr_in_mtval_bits =
    io_fault_manager_valid ? io_fault_manager_bits_mtval : stateReg_bits_pcEx;
  assign io_csr_in_halt =
    stateReg_valid & _ignore_T_4 & _io_csr_in_fault_T | io_csr_in_fault_0;
  assign io_csr_in_fault = io_csr_in_fault_0;
  assign io_csr_in_wfi = stateReg_valid & _ignore_T_6;
  assign io_rd_valid = stateReg_valid & stateReg_bits_linkValid;
  assign io_rd_bits_addr = stateReg_bits_linkAddr;
  assign io_rd_bits_data = stateReg_bits_linkData;
  assign io_taken_valid =
    stateReg_valid
    & (stateReg_bits_op == 4'hD
       | (stateReg_bits_op == 4'h7
            ? io_rs1_data >= io_rs2_data != stateReg_bits_fwd
            : stateReg_bits_op == 4'h6
                ? io_rs1_data < io_rs2_data != stateReg_bits_fwd
                : stateReg_bits_op == 4'h5
                    ? $signed(io_rs1_data) >= $signed(io_rs2_data) != stateReg_bits_fwd
                    : stateReg_bits_op == 4'h4
                        ? $signed(io_rs1_data) < $signed(io_rs2_data) != stateReg_bits_fwd
                        : stateReg_bits_op == 4'h3
                            ? io_rs1_data != io_rs2_data != stateReg_bits_fwd
                            : stateReg_bits_op == 4'h2
                                ? io_rs1_data == io_rs2_data != stateReg_bits_fwd
                                : stateReg_bits_op == 4'h1 | ~(|stateReg_bits_op)
                                    ? ~stateReg_bits_fwd
                                    : stateReg_bits_op == 4'hC
                                      | (stateReg_bits_op == 4'hB
                                           ? _io_csr_in_fault_T
                                           : stateReg_bits_op == 4'hA
                                               ? _io_csr_in_mcause_bits_T_4
                                               : stateReg_bits_op == 4'h9
                                                 | stateReg_bits_op == 4'h8
                                                 & _io_csr_in_mcause_bits_T_4)));
  assign io_taken_value = stateReg_bits_target;
  assign io_interlock =
    stateReg_valid & (|{_ignore_T_7, _ignore_T_5, _ignore_T_4, _ignore_T_3, _ignore_T_2});
endmodule

module Bru_1(
  input         clock,
                reset,
                io_req_valid,
                io_req_bits_fwd,
  input  [3:0]  io_req_bits_op,
  input  [31:0] io_req_bits_pc,
                io_req_bits_target,
  input  [4:0]  io_req_bits_link,
  input         io_rs1_valid,
  input  [31:0] io_rs1_data,
  input         io_rs2_valid,
  input  [31:0] io_rs2_data,
  output        io_rd_valid,
  output [4:0]  io_rd_bits_addr,
  output [31:0] io_rd_bits_data,
  output        io_taken_valid,
  output [31:0] io_taken_value,
  input  [31:0] io_target_data
);

  reg         stateReg_valid;
  reg         stateReg_bits_fwd;
  reg  [3:0]  stateReg_bits_op;
  reg  [31:0] stateReg_bits_target;
  reg         stateReg_bits_linkValid;
  reg  [4:0]  stateReg_bits_linkAddr;
  reg  [31:0] stateReg_bits_linkData;
  wire        _ignore_T_2 = stateReg_bits_op == 4'h8;
  wire        _ignore_T_3 = stateReg_bits_op == 4'h9;
  wire        _ignore_T_4 = stateReg_bits_op == 4'hA;
  wire        _ignore_T_5 = stateReg_bits_op == 4'hB;
  wire        _ignore_T_6 = stateReg_bits_op == 4'hC;
  wire [31:0] nextState_linkData = io_req_bits_pc + 32'h4;
  wire        _nextState_target_T = io_req_bits_op == 4'h1;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      stateReg_valid <= 1'h0;
      stateReg_bits_fwd <= 1'h0;
      stateReg_bits_op <= 4'h0;
      stateReg_bits_target <= 32'h0;
      stateReg_bits_linkValid <= 1'h0;
      stateReg_bits_linkAddr <= 5'h0;
      stateReg_bits_linkData <= 32'h0;
    end
    else begin
      stateReg_valid <= io_req_valid;
      if (io_req_valid) begin
        stateReg_bits_fwd <= io_req_valid & io_req_bits_fwd;
        stateReg_bits_op <= io_req_bits_op;
        stateReg_bits_target <=
          io_req_bits_fwd
            ? nextState_linkData
            : _nextState_target_T ? io_target_data & 32'hFFFFFFFE : io_req_bits_target;
        stateReg_bits_linkValid <=
          io_req_valid & (|io_req_bits_link)
          & (|{_nextState_target_T, io_req_bits_op == 4'h0});
        stateReg_bits_linkAddr <= io_req_bits_link;
        stateReg_bits_linkData <= nextState_linkData;
      end
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:2];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        stateReg_valid = _RANDOM[2'h0][0];
        stateReg_bits_fwd = _RANDOM[2'h0][1];
        stateReg_bits_op = _RANDOM[2'h0][5:2];
        stateReg_bits_target = {_RANDOM[2'h0][31:6], _RANDOM[2'h1][5:0]};
        stateReg_bits_linkValid = _RANDOM[2'h1][6];
        stateReg_bits_linkAddr = _RANDOM[2'h1][11:7];
        stateReg_bits_linkData = {_RANDOM[2'h1][31:12], _RANDOM[2'h2][11:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        stateReg_valid = 1'h0;
        stateReg_bits_fwd = 1'h0;
        stateReg_bits_op = 4'h0;
        stateReg_bits_target = 32'h0;
        stateReg_bits_linkValid = 1'h0;
        stateReg_bits_linkAddr = 5'h0;
        stateReg_bits_linkData = 32'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_rd_valid = stateReg_valid & stateReg_bits_linkValid;
  assign io_rd_bits_addr = stateReg_bits_linkAddr;
  assign io_rd_bits_data = stateReg_bits_linkData;
  assign io_taken_valid =
    stateReg_valid
    & (stateReg_bits_op == 4'hD
       | (stateReg_bits_op == 4'h7
            ? io_rs1_data >= io_rs2_data != stateReg_bits_fwd
            : stateReg_bits_op == 4'h6
                ? io_rs1_data < io_rs2_data != stateReg_bits_fwd
                : stateReg_bits_op == 4'h5
                    ? $signed(io_rs1_data) >= $signed(io_rs2_data) != stateReg_bits_fwd
                    : stateReg_bits_op == 4'h4
                        ? $signed(io_rs1_data) < $signed(io_rs2_data) != stateReg_bits_fwd
                        : stateReg_bits_op == 4'h3
                            ? io_rs1_data != io_rs2_data != stateReg_bits_fwd
                            : stateReg_bits_op == 4'h2
                                ? io_rs1_data == io_rs2_data != stateReg_bits_fwd
                                : (stateReg_bits_op == 4'h1 | ~(|stateReg_bits_op))
                                  & ~stateReg_bits_fwd));
  assign io_taken_value = stateReg_bits_target;
endmodule

module CircularBufferMulti_1(
  input         clock,
                reset,
  input  [1:0]  io_enqValid,
  input         io_enqData_0_store,
  input  [4:0]  io_enqData_0_rd,
                io_enqData_0_op,
  input  [31:0] io_enqData_0_pc,
                io_enqData_0_addr,
                io_enqData_0_data,
  input         io_enqData_1_store,
  input  [4:0]  io_enqData_1_rd,
                io_enqData_1_op,
  input  [31:0] io_enqData_1_pc,
                io_enqData_1_addr,
                io_enqData_1_data,
  output [2:0]  io_nEnqueued,
                io_nSpace,
  output        io_dataOut_0_store,
  output [4:0]  io_dataOut_0_rd,
                io_dataOut_0_op,
  output [31:0] io_dataOut_0_pc,
                io_dataOut_0_addr,
                io_dataOut_0_data,
  output        io_dataOut_1_store,
  output [4:0]  io_dataOut_1_rd,
                io_dataOut_1_op,
  output [31:0] io_dataOut_1_pc,
                io_dataOut_1_addr,
                io_dataOut_1_data,
  input  [1:0]  io_deqReady,
  input         io_flush
);

  reg          buffer_0_store;
  reg  [4:0]   buffer_0_rd;
  reg  [4:0]   buffer_0_op;
  reg  [31:0]  buffer_0_pc;
  reg  [31:0]  buffer_0_addr;
  reg  [31:0]  buffer_0_data;
  reg          buffer_1_store;
  reg  [4:0]   buffer_1_rd;
  reg  [4:0]   buffer_1_op;
  reg  [31:0]  buffer_1_pc;
  reg  [31:0]  buffer_1_addr;
  reg  [31:0]  buffer_1_data;
  reg          buffer_2_store;
  reg  [4:0]   buffer_2_rd;
  reg  [4:0]   buffer_2_op;
  reg  [31:0]  buffer_2_pc;
  reg  [31:0]  buffer_2_addr;
  reg  [31:0]  buffer_2_data;
  reg          buffer_3_store;
  reg  [4:0]   buffer_3_rd;
  reg  [4:0]   buffer_3_op;
  reg  [31:0]  buffer_3_pc;
  reg  [31:0]  buffer_3_addr;
  reg  [31:0]  buffer_3_data;
  reg  [1:0]   enqPtr;
  reg  [1:0]   deqPtr;
  reg  [2:0]   nEnqueued;
  wire [8:0]   _outputBufferView_rotated_T_9 = {7'h0, deqPtr} * 9'h6B;
  wire [427:0] _outputBufferView_rotated_T_22 =
    _outputBufferView_rotated_T_9[0]
      ? {buffer_0_data[0],
         buffer_3_store,
         buffer_3_rd,
         buffer_3_op,
         buffer_3_pc,
         buffer_3_addr,
         buffer_3_data,
         buffer_2_store,
         buffer_2_rd,
         buffer_2_op,
         buffer_2_pc,
         buffer_2_addr,
         buffer_2_data,
         buffer_1_store,
         buffer_1_rd,
         buffer_1_op,
         buffer_1_pc,
         buffer_1_addr,
         buffer_1_data,
         buffer_0_store,
         buffer_0_rd,
         buffer_0_op,
         buffer_0_pc,
         buffer_0_addr,
         buffer_0_data[31:1]}
      : {buffer_3_store,
         buffer_3_rd,
         buffer_3_op,
         buffer_3_pc,
         buffer_3_addr,
         buffer_3_data,
         buffer_2_store,
         buffer_2_rd,
         buffer_2_op,
         buffer_2_pc,
         buffer_2_addr,
         buffer_2_data,
         buffer_1_store,
         buffer_1_rd,
         buffer_1_op,
         buffer_1_pc,
         buffer_1_addr,
         buffer_1_data,
         buffer_0_store,
         buffer_0_rd,
         buffer_0_op,
         buffer_0_pc,
         buffer_0_addr,
         buffer_0_data};
  wire [427:0] _outputBufferView_rotated_T_26 =
    _outputBufferView_rotated_T_9[1]
      ? {_outputBufferView_rotated_T_22[1:0], _outputBufferView_rotated_T_22[427:2]}
      : _outputBufferView_rotated_T_22;
  wire [427:0] _outputBufferView_rotated_T_30 =
    _outputBufferView_rotated_T_9[2]
      ? {_outputBufferView_rotated_T_26[3:0], _outputBufferView_rotated_T_26[427:4]}
      : _outputBufferView_rotated_T_26;
  wire [427:0] _outputBufferView_rotated_T_34 =
    _outputBufferView_rotated_T_9[3]
      ? {_outputBufferView_rotated_T_30[7:0], _outputBufferView_rotated_T_30[427:8]}
      : _outputBufferView_rotated_T_30;
  wire [427:0] _outputBufferView_rotated_T_38 =
    _outputBufferView_rotated_T_9[4]
      ? {_outputBufferView_rotated_T_34[15:0], _outputBufferView_rotated_T_34[427:16]}
      : _outputBufferView_rotated_T_34;
  wire [427:0] _outputBufferView_rotated_T_42 =
    _outputBufferView_rotated_T_9[5]
      ? {_outputBufferView_rotated_T_38[31:0], _outputBufferView_rotated_T_38[427:32]}
      : _outputBufferView_rotated_T_38;
  wire [427:0] _outputBufferView_rotated_T_46 =
    _outputBufferView_rotated_T_9[6]
      ? {_outputBufferView_rotated_T_42[63:0], _outputBufferView_rotated_T_42[427:64]}
      : _outputBufferView_rotated_T_42;
  wire [427:0] _outputBufferView_rotated_T_50 =
    _outputBufferView_rotated_T_9[7]
      ? {_outputBufferView_rotated_T_46[127:0], _outputBufferView_rotated_T_46[427:128]}
      : _outputBufferView_rotated_T_46;
  wire [213:0] outputBufferView_rotated =
    _outputBufferView_rotated_T_9[8]
      ? {_outputBufferView_rotated_T_50[41:0], _outputBufferView_rotated_T_50[427:256]}
      : _outputBufferView_rotated_T_50[213:0];
  wire [8:0]   _rotatedInput_rotated_T_13 = {7'h0, enqPtr} * 9'h6C;
  wire [431:0] _rotatedInput_rotated_T_26 =
    _rotatedInput_rotated_T_13[0]
      ? {215'h0,
         io_enqValid[1],
         io_enqData_1_store,
         io_enqData_1_rd,
         io_enqData_1_op,
         io_enqData_1_pc,
         io_enqData_1_addr,
         io_enqData_1_data,
         |io_enqValid,
         io_enqData_0_store,
         io_enqData_0_rd,
         io_enqData_0_op,
         io_enqData_0_pc,
         io_enqData_0_addr,
         io_enqData_0_data,
         1'h0}
      : {216'h0,
         io_enqValid[1],
         io_enqData_1_store,
         io_enqData_1_rd,
         io_enqData_1_op,
         io_enqData_1_pc,
         io_enqData_1_addr,
         io_enqData_1_data,
         |io_enqValid,
         io_enqData_0_store,
         io_enqData_0_rd,
         io_enqData_0_op,
         io_enqData_0_pc,
         io_enqData_0_addr,
         io_enqData_0_data};
  wire [431:0] _rotatedInput_rotated_T_30 =
    _rotatedInput_rotated_T_13[1]
      ? {_rotatedInput_rotated_T_26[429:0], _rotatedInput_rotated_T_26[431:430]}
      : _rotatedInput_rotated_T_26;
  wire [431:0] _rotatedInput_rotated_T_34 =
    _rotatedInput_rotated_T_13[2]
      ? {_rotatedInput_rotated_T_30[427:0], _rotatedInput_rotated_T_30[431:428]}
      : _rotatedInput_rotated_T_30;
  wire [431:0] _rotatedInput_rotated_T_38 =
    _rotatedInput_rotated_T_13[3]
      ? {_rotatedInput_rotated_T_34[423:0], _rotatedInput_rotated_T_34[431:424]}
      : _rotatedInput_rotated_T_34;
  wire [431:0] _rotatedInput_rotated_T_42 =
    _rotatedInput_rotated_T_13[4]
      ? {_rotatedInput_rotated_T_38[415:0], _rotatedInput_rotated_T_38[431:416]}
      : _rotatedInput_rotated_T_38;
  wire [431:0] _rotatedInput_rotated_T_46 =
    _rotatedInput_rotated_T_13[5]
      ? {_rotatedInput_rotated_T_42[399:0], _rotatedInput_rotated_T_42[431:400]}
      : _rotatedInput_rotated_T_42;
  wire [431:0] _rotatedInput_rotated_T_50 =
    _rotatedInput_rotated_T_13[6]
      ? {_rotatedInput_rotated_T_46[367:0], _rotatedInput_rotated_T_46[431:368]}
      : _rotatedInput_rotated_T_46;
  wire [431:0] _rotatedInput_rotated_T_54 =
    _rotatedInput_rotated_T_13[7]
      ? {_rotatedInput_rotated_T_50[303:0], _rotatedInput_rotated_T_50[431:304]}
      : _rotatedInput_rotated_T_50;
  wire [431:0] rotatedInput_rotated =
    _rotatedInput_rotated_T_13[8]
      ? {_rotatedInput_rotated_T_54[175:0], _rotatedInput_rotated_T_54[431:176]}
      : _rotatedInput_rotated_T_54;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      buffer_0_store <= 1'h0;
      buffer_0_rd <= 5'h0;
      buffer_0_op <= 5'h0;
      buffer_0_pc <= 32'h0;
      buffer_0_addr <= 32'h0;
      buffer_0_data <= 32'h0;
      buffer_1_store <= 1'h0;
      buffer_1_rd <= 5'h0;
      buffer_1_op <= 5'h0;
      buffer_1_pc <= 32'h0;
      buffer_1_addr <= 32'h0;
      buffer_1_data <= 32'h0;
      buffer_2_store <= 1'h0;
      buffer_2_rd <= 5'h0;
      buffer_2_op <= 5'h0;
      buffer_2_pc <= 32'h0;
      buffer_2_addr <= 32'h0;
      buffer_2_data <= 32'h0;
      buffer_3_store <= 1'h0;
      buffer_3_rd <= 5'h0;
      buffer_3_op <= 5'h0;
      buffer_3_pc <= 32'h0;
      buffer_3_addr <= 32'h0;
      buffer_3_data <= 32'h0;
      enqPtr <= 2'h0;
      deqPtr <= 2'h0;
      nEnqueued <= 3'h0;
    end
    else begin
      if (rotatedInput_rotated[107]) begin
        buffer_0_store <= rotatedInput_rotated[106];
        buffer_0_rd <= rotatedInput_rotated[105:101];
        buffer_0_op <= rotatedInput_rotated[100:96];
        buffer_0_pc <= rotatedInput_rotated[95:64];
        buffer_0_addr <= rotatedInput_rotated[63:32];
        buffer_0_data <= rotatedInput_rotated[31:0];
      end
      if (rotatedInput_rotated[215]) begin
        buffer_1_store <= rotatedInput_rotated[214];
        buffer_1_rd <= rotatedInput_rotated[213:209];
        buffer_1_op <= rotatedInput_rotated[208:204];
        buffer_1_pc <= rotatedInput_rotated[203:172];
        buffer_1_addr <= rotatedInput_rotated[171:140];
        buffer_1_data <= rotatedInput_rotated[139:108];
      end
      if (rotatedInput_rotated[323]) begin
        buffer_2_store <= rotatedInput_rotated[322];
        buffer_2_rd <= rotatedInput_rotated[321:317];
        buffer_2_op <= rotatedInput_rotated[316:312];
        buffer_2_pc <= rotatedInput_rotated[311:280];
        buffer_2_addr <= rotatedInput_rotated[279:248];
        buffer_2_data <= rotatedInput_rotated[247:216];
      end
      if (rotatedInput_rotated[431]) begin
        buffer_3_store <= rotatedInput_rotated[430];
        buffer_3_rd <= rotatedInput_rotated[429:425];
        buffer_3_op <= rotatedInput_rotated[424:420];
        buffer_3_pc <= rotatedInput_rotated[419:388];
        buffer_3_addr <= rotatedInput_rotated[387:356];
        buffer_3_data <= rotatedInput_rotated[355:324];
      end
      enqPtr <= io_flush ? 2'h0 : enqPtr + io_enqValid;
      deqPtr <= io_flush ? 2'h0 : deqPtr + io_deqReady;
      nEnqueued <=
        io_flush ? 3'h0 : nEnqueued + {1'h0, io_enqValid} - {1'h0, io_deqReady};
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:13];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [3:0] i = 4'h0; i < 4'hE; i += 4'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        buffer_0_store = _RANDOM[4'h0][0];
        buffer_0_rd = _RANDOM[4'h0][5:1];
        buffer_0_op = _RANDOM[4'h0][10:6];
        buffer_0_pc = {_RANDOM[4'h0][31:11], _RANDOM[4'h1][10:0]};
        buffer_0_addr = {_RANDOM[4'h1][31:11], _RANDOM[4'h2][10:0]};
        buffer_0_data = {_RANDOM[4'h2][31:11], _RANDOM[4'h3][10:0]};
        buffer_1_store = _RANDOM[4'h3][11];
        buffer_1_rd = _RANDOM[4'h3][16:12];
        buffer_1_op = _RANDOM[4'h3][21:17];
        buffer_1_pc = {_RANDOM[4'h3][31:22], _RANDOM[4'h4][21:0]};
        buffer_1_addr = {_RANDOM[4'h4][31:22], _RANDOM[4'h5][21:0]};
        buffer_1_data = {_RANDOM[4'h5][31:22], _RANDOM[4'h6][21:0]};
        buffer_2_store = _RANDOM[4'h6][22];
        buffer_2_rd = _RANDOM[4'h6][27:23];
        buffer_2_op = {_RANDOM[4'h6][31:28], _RANDOM[4'h7][0]};
        buffer_2_pc = {_RANDOM[4'h7][31:1], _RANDOM[4'h8][0]};
        buffer_2_addr = {_RANDOM[4'h8][31:1], _RANDOM[4'h9][0]};
        buffer_2_data = {_RANDOM[4'h9][31:1], _RANDOM[4'hA][0]};
        buffer_3_store = _RANDOM[4'hA][1];
        buffer_3_rd = _RANDOM[4'hA][6:2];
        buffer_3_op = _RANDOM[4'hA][11:7];
        buffer_3_pc = {_RANDOM[4'hA][31:12], _RANDOM[4'hB][11:0]};
        buffer_3_addr = {_RANDOM[4'hB][31:12], _RANDOM[4'hC][11:0]};
        buffer_3_data = {_RANDOM[4'hC][31:12], _RANDOM[4'hD][11:0]};
        enqPtr = _RANDOM[4'hD][13:12];
        deqPtr = _RANDOM[4'hD][15:14];
        nEnqueued = _RANDOM[4'hD][18:16];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        buffer_0_store = 1'h0;
        buffer_0_rd = 5'h0;
        buffer_0_op = 5'h0;
        buffer_0_pc = 32'h0;
        buffer_0_addr = 32'h0;
        buffer_0_data = 32'h0;
        buffer_1_store = 1'h0;
        buffer_1_rd = 5'h0;
        buffer_1_op = 5'h0;
        buffer_1_pc = 32'h0;
        buffer_1_addr = 32'h0;
        buffer_1_data = 32'h0;
        buffer_2_store = 1'h0;
        buffer_2_rd = 5'h0;
        buffer_2_op = 5'h0;
        buffer_2_pc = 32'h0;
        buffer_2_addr = 32'h0;
        buffer_2_data = 32'h0;
        buffer_3_store = 1'h0;
        buffer_3_rd = 5'h0;
        buffer_3_op = 5'h0;
        buffer_3_pc = 32'h0;
        buffer_3_addr = 32'h0;
        buffer_3_data = 32'h0;
        enqPtr = 2'h0;
        deqPtr = 2'h0;
        nEnqueued = 3'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_nEnqueued = nEnqueued;
  assign io_nSpace = 3'h4 - nEnqueued;
  assign io_dataOut_0_store = outputBufferView_rotated[106];
  assign io_dataOut_0_rd = outputBufferView_rotated[105:101];
  assign io_dataOut_0_op = outputBufferView_rotated[100:96];
  assign io_dataOut_0_pc = outputBufferView_rotated[95:64];
  assign io_dataOut_0_addr = outputBufferView_rotated[63:32];
  assign io_dataOut_0_data = outputBufferView_rotated[31:0];
  assign io_dataOut_1_store = outputBufferView_rotated[213];
  assign io_dataOut_1_rd = outputBufferView_rotated[212:208];
  assign io_dataOut_1_op = outputBufferView_rotated[207:203];
  assign io_dataOut_1_pc = outputBufferView_rotated[202:171];
  assign io_dataOut_1_addr = outputBufferView_rotated[170:139];
  assign io_dataOut_1_data = outputBufferView_rotated[138:107];
endmodule

module LsuV2(
  input          clock,
                 reset,
  output         io_req_0_ready,
  input          io_req_0_valid,
                 io_req_0_bits_store,
  input  [4:0]   io_req_0_bits_addr,
                 io_req_0_bits_op,
  input  [31:0]  io_req_0_bits_pc,
  output         io_req_1_ready,
  input          io_req_1_valid,
                 io_req_1_bits_store,
  input  [4:0]   io_req_1_bits_addr,
                 io_req_1_bits_op,
  input  [31:0]  io_req_1_bits_pc,
                 io_busPort_addr_0,
                 io_busPort_addr_1,
                 io_busPort_data_0,
                 io_busPort_data_1,
                 io_busPort_flt_data_0,
  output         io_rd_valid,
  output [4:0]   io_rd_bits_addr,
  output [31:0]  io_rd_bits_data,
  output         io_rd_flt_valid,
  output [4:0]   io_rd_flt_bits_addr,
  output [31:0]  io_rd_flt_bits_data,
  output         io_ibus_valid,
  input          io_ibus_ready,
  output [31:0]  io_ibus_addr,
  input  [127:0] io_ibus_rdata,
  output         io_dbus_valid,
                 io_dbus_write,
  output [31:0]  io_dbus_addr,
  output [127:0] io_dbus_wdata,
  output [15:0]  io_dbus_wmask,
  input  [127:0] io_dbus_rdata,
  output         io_flush_valid,
  input          io_flush_ready,
  output         io_flush_fencei,
  output [31:0]  io_flush_pcNext,
  output         io_fault_valid,
                 io_fault_bits_write,
  output [31:0]  io_fault_bits_addr,
                 io_fault_bits_epc,
  output         io_ebus_dbus_valid,
  input          io_ebus_dbus_ready,
  output         io_ebus_dbus_write,
  output [31:0]  io_ebus_dbus_pc,
                 io_ebus_dbus_addr,
  output [4:0]   io_ebus_dbus_size,
  output [127:0] io_ebus_dbus_wdata,
  output [15:0]  io_ebus_dbus_wmask,
  input  [127:0] io_ebus_dbus_rdata,
  input          io_ebus_fault_valid,
                 io_ebus_fault_bits_write,
  input  [31:0]  io_ebus_fault_bits_addr,
                 io_ebus_fault_bits_epc,
  output [2:0]   io_queueCapacity,
  output         io_active
);

  wire              io_req_0_ready_0;
  wire              _alignedOps_aligner_out_0_valid;
  wire [106:0]      _alignedOps_aligner_out_0_bits;
  wire              _alignedOps_aligner_out_1_valid;
  wire [106:0]      _alignedOps_aligner_out_1_bits;
  wire [2:0]        _opQueue_io_nEnqueued;
  wire [2:0]        _opQueue_io_nSpace;
  wire              _opQueue_io_dataOut_0_store;
  wire [4:0]        _opQueue_io_dataOut_0_rd;
  wire [4:0]        _opQueue_io_dataOut_0_op;
  wire [31:0]       _opQueue_io_dataOut_0_pc;
  wire [31:0]       _opQueue_io_dataOut_0_addr;
  wire [31:0]       _opQueue_io_dataOut_0_data;
  reg               flushCmd_valid;
  reg               flushCmd_bits_fencei;
  reg  [31:0]       flushCmd_bits_pcNext;
  wire              _ops_T = io_req_0_ready_0 & io_req_0_valid;
  wire              flushCmd_result_fencei = io_req_0_bits_op == 5'h8;
  wire              _ops_T_2 = io_req_0_bits_op == 5'h9;
  wire              _ops_T_3 = io_req_0_bits_op == 5'hA;
  assign io_req_0_ready_0 = (|_opQueue_io_nSpace) & ~flushCmd_valid;
  wire              io_req_1_ready_0 =
    {2'h0, io_req_0_valid} < _opQueue_io_nSpace & ~flushCmd_valid;
  wire [1:0]        opQueue_io_enqValid =
    {1'h0, _alignedOps_aligner_out_0_valid} + {1'h0, _alignedOps_aligner_out_1_valid};
  reg               readFired_valid;
  reg  [1:0]        readFired_bits_bus;
  reg  [27:0]       readFired_bits_lineAddr;
  reg  [4:0]        slot_op;
  reg  [4:0]        slot_rd;
  reg               slot_store;
  reg  [31:0]       slot_pc;
  reg               slot_active_0;
  reg               slot_active_1;
  reg               slot_active_2;
  reg               slot_active_3;
  reg               slot_active_4;
  reg               slot_active_5;
  reg               slot_active_6;
  reg               slot_active_7;
  reg               slot_active_8;
  reg               slot_active_9;
  reg               slot_active_10;
  reg               slot_active_11;
  reg               slot_active_12;
  reg               slot_active_13;
  reg               slot_active_14;
  reg               slot_active_15;
  reg  [31:0]       slot_baseAddr;
  reg  [31:0]       slot_addrs_0;
  reg  [31:0]       slot_addrs_1;
  reg  [31:0]       slot_addrs_2;
  reg  [31:0]       slot_addrs_3;
  reg  [31:0]       slot_addrs_4;
  reg  [31:0]       slot_addrs_5;
  reg  [31:0]       slot_addrs_6;
  reg  [31:0]       slot_addrs_7;
  reg  [31:0]       slot_addrs_8;
  reg  [31:0]       slot_addrs_9;
  reg  [31:0]       slot_addrs_10;
  reg  [31:0]       slot_addrs_11;
  reg  [31:0]       slot_addrs_12;
  reg  [31:0]       slot_addrs_13;
  reg  [31:0]       slot_addrs_14;
  reg  [31:0]       slot_addrs_15;
  reg  [7:0]        slot_data_0;
  reg  [7:0]        slot_data_1;
  reg  [7:0]        slot_data_2;
  reg  [7:0]        slot_data_3;
  reg  [7:0]        slot_data_4;
  reg  [7:0]        slot_data_5;
  reg  [7:0]        slot_data_6;
  reg  [7:0]        slot_data_7;
  reg  [7:0]        slot_data_8;
  reg  [7:0]        slot_data_9;
  reg  [7:0]        slot_data_10;
  reg  [7:0]        slot_data_11;
  reg  [7:0]        slot_data_12;
  reg  [7:0]        slot_data_13;
  reg  [7:0]        slot_data_14;
  reg  [7:0]        slot_data_15;
  reg               slot_pendingVector;
  reg               slot_pendingWriteback;
  reg  [31:0]       slot_elemStride;
  reg  [31:0]       slot_segmentStride;
  reg  [2:0]        slot_elemWidth;
  reg  [2:0]        slot_sew;
  reg               slot_vectorLoop_isActive;
  reg  [1:0]        slot_vectorLoop_subvector_curr;
  reg  [1:0]        slot_vectorLoop_subvector_max;
  reg  [2:0]        slot_vectorLoop_segment_curr;
  reg  [2:0]        slot_vectorLoop_segment_max;
  reg  [2:0]        slot_vectorLoop_lmul_curr;
  reg  [2:0]        slot_vectorLoop_lmul_max;
  reg  [4:0]        slot_vectorLoop_rdStart;
  reg  [4:0]        slot_vectorLoop_rd;
  wire              _writebackUpdatedSlot_result_baseAddr_T_3 = slot_op == 5'hD;
  wire              _writebackUpdatedSlot_result_baseAddr_T_4 = slot_op == 5'h11;
  wire              _writebackUpdatedSlot_result_baseAddr_T_12 = slot_op == 5'hE;
  wire              _writebackUpdatedSlot_result_baseAddr_T_13 = slot_op == 5'h12;
  wire              _storeComplete_T_44 = slot_op == 5'hF;
  wire              _storeComplete_T_45 = slot_op == 5'h10;
  wire              _storeComplete_T_48 = slot_op == 5'h13;
  wire              _storeComplete_T_49 = slot_op == 5'h14;
  wire              loadUpdatedSlot_lineActive_0 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_0 & slot_addrs_0[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_1 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_1 & slot_addrs_1[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_2 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_2 & slot_addrs_2[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_3 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_3 & slot_addrs_3[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_4 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_4 & slot_addrs_4[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_5 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_5 & slot_addrs_5[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_6 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_6 & slot_addrs_6[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_7 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_7 & slot_addrs_7[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_8 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_8 & slot_addrs_8[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_9 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_9 & slot_addrs_9[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_10 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_10 & slot_addrs_10[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_11 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_11 & slot_addrs_11[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_12 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_12 & slot_addrs_12[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_13 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_13 & slot_addrs_13[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_14 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_14 & slot_addrs_14[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_15 =
    ~slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector)
    & readFired_valid & slot_active_15 & slot_addrs_15[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_active_0 =
    slot_active_0 & ~loadUpdatedSlot_lineActive_0;
  wire              loadUpdatedSlot_active_1 =
    slot_active_1 & ~loadUpdatedSlot_lineActive_1;
  wire              loadUpdatedSlot_active_2 =
    slot_active_2 & ~loadUpdatedSlot_lineActive_2;
  wire              loadUpdatedSlot_active_3 =
    slot_active_3 & ~loadUpdatedSlot_lineActive_3;
  wire              loadUpdatedSlot_active_4 =
    slot_active_4 & ~loadUpdatedSlot_lineActive_4;
  wire              loadUpdatedSlot_active_5 =
    slot_active_5 & ~loadUpdatedSlot_lineActive_5;
  wire              loadUpdatedSlot_active_6 =
    slot_active_6 & ~loadUpdatedSlot_lineActive_6;
  wire              loadUpdatedSlot_active_7 =
    slot_active_7 & ~loadUpdatedSlot_lineActive_7;
  wire              loadUpdatedSlot_active_8 =
    slot_active_8 & ~loadUpdatedSlot_lineActive_8;
  wire              loadUpdatedSlot_active_9 =
    slot_active_9 & ~loadUpdatedSlot_lineActive_9;
  wire              loadUpdatedSlot_active_10 =
    slot_active_10 & ~loadUpdatedSlot_lineActive_10;
  wire              loadUpdatedSlot_active_11 =
    slot_active_11 & ~loadUpdatedSlot_lineActive_11;
  wire              loadUpdatedSlot_active_12 =
    slot_active_12 & ~loadUpdatedSlot_lineActive_12;
  wire              loadUpdatedSlot_active_13 =
    slot_active_13 & ~loadUpdatedSlot_lineActive_13;
  wire              loadUpdatedSlot_active_14 =
    slot_active_14 & ~loadUpdatedSlot_lineActive_14;
  wire              loadUpdatedSlot_active_15 =
    slot_active_15 & ~loadUpdatedSlot_lineActive_15;
  wire [31:0]       targetAddress_bits =
    loadUpdatedSlot_active_0
    & (~readFired_valid | readFired_bits_lineAddr != slot_addrs_0[31:4])
      ? slot_addrs_0
      : loadUpdatedSlot_active_1
        & (~readFired_valid | readFired_bits_lineAddr != slot_addrs_1[31:4])
          ? slot_addrs_1
          : loadUpdatedSlot_active_2
            & (~readFired_valid | readFired_bits_lineAddr != slot_addrs_2[31:4])
              ? slot_addrs_2
              : loadUpdatedSlot_active_3
                & (~readFired_valid | readFired_bits_lineAddr != slot_addrs_3[31:4])
                  ? slot_addrs_3
                  : loadUpdatedSlot_active_4
                    & (~readFired_valid | readFired_bits_lineAddr != slot_addrs_4[31:4])
                      ? slot_addrs_4
                      : loadUpdatedSlot_active_5
                        & (~readFired_valid
                           | readFired_bits_lineAddr != slot_addrs_5[31:4])
                          ? slot_addrs_5
                          : loadUpdatedSlot_active_6
                            & (~readFired_valid
                               | readFired_bits_lineAddr != slot_addrs_6[31:4])
                              ? slot_addrs_6
                              : loadUpdatedSlot_active_7
                                & (~readFired_valid
                                   | readFired_bits_lineAddr != slot_addrs_7[31:4])
                                  ? slot_addrs_7
                                  : loadUpdatedSlot_active_8
                                    & (~readFired_valid
                                       | readFired_bits_lineAddr != slot_addrs_8[31:4])
                                      ? slot_addrs_8
                                      : loadUpdatedSlot_active_9
                                        & (~readFired_valid
                                           | readFired_bits_lineAddr != slot_addrs_9[31:4])
                                          ? slot_addrs_9
                                          : loadUpdatedSlot_active_10
                                            & (~readFired_valid
                                               | readFired_bits_lineAddr != slot_addrs_10[31:4])
                                              ? slot_addrs_10
                                              : loadUpdatedSlot_active_11
                                                & (~readFired_valid
                                                   | readFired_bits_lineAddr != slot_addrs_11[31:4])
                                                  ? slot_addrs_11
                                                  : loadUpdatedSlot_active_12
                                                    & (~readFired_valid
                                                       | readFired_bits_lineAddr != slot_addrs_12[31:4])
                                                      ? slot_addrs_12
                                                      : loadUpdatedSlot_active_13
                                                        & (~readFired_valid
                                                           | readFired_bits_lineAddr != slot_addrs_13[31:4])
                                                          ? slot_addrs_13
                                                          : loadUpdatedSlot_active_14
                                                            & (~readFired_valid
                                                               | readFired_bits_lineAddr != slot_addrs_14[31:4])
                                                              ? slot_addrs_14
                                                              : loadUpdatedSlot_active_15
                                                                & (~readFired_valid
                                                                   | readFired_bits_lineAddr != slot_addrs_15[31:4])
                                                                  ? slot_addrs_15
                                                                  : 32'h0;
  wire [31:0]       targetLineAddr = {targetAddress_bits[31:4], 4'h0};
  wire              itcm = targetLineAddr < 32'h1000;
  wire              dtcm = (|(targetAddress_bits[31:16])) & targetLineAddr < 32'h12000;
  wire              peri = targetLineAddr > 32'h2FFFF & targetLineAddr < 32'h31000;
  wire              canScatter =
    slot_store
    & ({_storeComplete_T_49,
        _storeComplete_T_48,
        _writebackUpdatedSlot_result_baseAddr_T_13,
        _writebackUpdatedSlot_result_baseAddr_T_4,
        _storeComplete_T_45,
        _storeComplete_T_44,
        _writebackUpdatedSlot_result_baseAddr_T_12,
        _writebackUpdatedSlot_result_baseAddr_T_3} == 8'h0 | ~slot_pendingVector);
  wire              lineActive_0 =
    canScatter & slot_active_0 & slot_addrs_0[31:4] == targetAddress_bits[31:4];
  wire              lineActive_1 =
    canScatter & slot_active_1 & slot_addrs_1[31:4] == targetAddress_bits[31:4];
  wire              lineActive_2 =
    canScatter & slot_active_2 & slot_addrs_2[31:4] == targetAddress_bits[31:4];
  wire              lineActive_3 =
    canScatter & slot_active_3 & slot_addrs_3[31:4] == targetAddress_bits[31:4];
  wire              lineActive_4 =
    canScatter & slot_active_4 & slot_addrs_4[31:4] == targetAddress_bits[31:4];
  wire              lineActive_5 =
    canScatter & slot_active_5 & slot_addrs_5[31:4] == targetAddress_bits[31:4];
  wire              lineActive_6 =
    canScatter & slot_active_6 & slot_addrs_6[31:4] == targetAddress_bits[31:4];
  wire              lineActive_7 =
    canScatter & slot_active_7 & slot_addrs_7[31:4] == targetAddress_bits[31:4];
  wire              lineActive_8 =
    canScatter & slot_active_8 & slot_addrs_8[31:4] == targetAddress_bits[31:4];
  wire              lineActive_9 =
    canScatter & slot_active_9 & slot_addrs_9[31:4] == targetAddress_bits[31:4];
  wire              lineActive_10 =
    canScatter & slot_active_10 & slot_addrs_10[31:4] == targetAddress_bits[31:4];
  wire              lineActive_11 =
    canScatter & slot_active_11 & slot_addrs_11[31:4] == targetAddress_bits[31:4];
  wire              lineActive_12 =
    canScatter & slot_active_12 & slot_addrs_12[31:4] == targetAddress_bits[31:4];
  wire              lineActive_13 =
    canScatter & slot_active_13 & slot_addrs_13[31:4] == targetAddress_bits[31:4];
  wire              lineActive_14 =
    canScatter & slot_active_14 & slot_addrs_14[31:4] == targetAddress_bits[31:4];
  wire              lineActive_15 =
    canScatter & slot_active_15 & slot_addrs_15[31:4] == targetAddress_bits[31:4];
  wire [15:0]       valueSet_1 = lineActive_0 ? 16'h1 << slot_addrs_0[3:0] : 16'h0;
  wire [15:0]       validMatrix_1 = lineActive_1 ? 16'h1 << slot_addrs_1[3:0] : 16'h0;
  wire [15:0]       validMatrix_2 = lineActive_2 ? 16'h1 << slot_addrs_2[3:0] : 16'h0;
  wire [15:0]       validMatrix_3 = lineActive_3 ? 16'h1 << slot_addrs_3[3:0] : 16'h0;
  wire [15:0]       validMatrix_4 = lineActive_4 ? 16'h1 << slot_addrs_4[3:0] : 16'h0;
  wire [15:0]       validMatrix_5 = lineActive_5 ? 16'h1 << slot_addrs_5[3:0] : 16'h0;
  wire [15:0]       validMatrix_6 = lineActive_6 ? 16'h1 << slot_addrs_6[3:0] : 16'h0;
  wire [15:0]       validMatrix_7 = lineActive_7 ? 16'h1 << slot_addrs_7[3:0] : 16'h0;
  wire [15:0]       validMatrix_8 = lineActive_8 ? 16'h1 << slot_addrs_8[3:0] : 16'h0;
  wire [15:0]       validMatrix_9 = lineActive_9 ? 16'h1 << slot_addrs_9[3:0] : 16'h0;
  wire [15:0]       validMatrix_10 = lineActive_10 ? 16'h1 << slot_addrs_10[3:0] : 16'h0;
  wire [15:0]       validMatrix_11 = lineActive_11 ? 16'h1 << slot_addrs_11[3:0] : 16'h0;
  wire [15:0]       validMatrix_12 = lineActive_12 ? 16'h1 << slot_addrs_12[3:0] : 16'h0;
  wire [15:0]       validMatrix_13 = lineActive_13 ? 16'h1 << slot_addrs_13[3:0] : 16'h0;
  wire [15:0]       validMatrix_14 = lineActive_14 ? 16'h1 << slot_addrs_14[3:0] : 16'h0;
  wire [15:0]       valueSet_2 = valueSet_1 | validMatrix_1;
  wire [15:0]       valueSet_3 = valueSet_2 | validMatrix_2;
  wire [15:0]       valueSet_4 = valueSet_3 | validMatrix_3;
  wire [15:0]       valueSet_5 = valueSet_4 | validMatrix_4;
  wire [15:0]       valueSet_6 = valueSet_5 | validMatrix_5;
  wire [15:0]       valueSet_7 = valueSet_6 | validMatrix_6;
  wire [15:0]       valueSet_8 = valueSet_7 | validMatrix_7;
  wire [15:0]       valueSet_9 = valueSet_8 | validMatrix_8;
  wire [15:0]       valueSet_10 = valueSet_9 | validMatrix_9;
  wire [15:0]       valueSet_11 = valueSet_10 | validMatrix_10;
  wire [15:0]       valueSet_12 = valueSet_11 | validMatrix_11;
  wire [15:0]       valueSet_13 = valueSet_12 | validMatrix_12;
  wire [15:0]       valueSet_14 = valueSet_13 | validMatrix_13;
  wire [15:0]       selectionMatrix_1 = validMatrix_1 & ~valueSet_1;
  wire [15:0]       selectionMatrix_2 = validMatrix_2 & ~valueSet_2;
  wire [15:0]       selectionMatrix_3 = validMatrix_3 & ~valueSet_3;
  wire [15:0]       selectionMatrix_4 = validMatrix_4 & ~valueSet_4;
  wire [15:0]       selectionMatrix_5 = validMatrix_5 & ~valueSet_5;
  wire [15:0]       selectionMatrix_6 = validMatrix_6 & ~valueSet_6;
  wire [15:0]       selectionMatrix_7 = validMatrix_7 & ~valueSet_7;
  wire [15:0]       selectionMatrix_8 = validMatrix_8 & ~valueSet_8;
  wire [15:0]       selectionMatrix_9 = validMatrix_9 & ~valueSet_9;
  wire [15:0]       selectionMatrix_10 = validMatrix_10 & ~valueSet_10;
  wire [15:0]       selectionMatrix_11 = validMatrix_11 & ~valueSet_11;
  wire [15:0]       selectionMatrix_12 = validMatrix_12 & ~valueSet_12;
  wire [15:0]       selectionMatrix_13 = validMatrix_13 & ~valueSet_13;
  wire [15:0]       selectionMatrix_14 = validMatrix_14 & ~valueSet_14;
  wire [15:0]       selectionMatrix_15 =
    (lineActive_15 ? 16'h1 << slot_addrs_15[3:0] : 16'h0)
    & ~(valueSet_14 | validMatrix_14);
  wire [15:0]       _resultMask_T_14 =
    valueSet_1 | selectionMatrix_1 | selectionMatrix_2 | selectionMatrix_3
    | selectionMatrix_4 | selectionMatrix_5 | selectionMatrix_6 | selectionMatrix_7
    | selectionMatrix_8 | selectionMatrix_9 | selectionMatrix_10 | selectionMatrix_11
    | selectionMatrix_12 | selectionMatrix_13 | selectionMatrix_14 | selectionMatrix_15;
  wire [7:0]        wdata_0 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h0
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h0
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h0
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h0
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h0
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h0
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h0
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h0
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h0
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h0
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h0
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h0
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h0
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h0
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h0
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h0
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_1 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h1
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h1
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h1
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h1
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h1
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h1
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h1
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h1
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h1
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h1
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h1
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h1
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h1
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h1
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h1
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h1
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_2 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h2
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h2
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h2
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h2
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h2
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h2
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h2
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h2
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h2
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h2
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h2
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h2
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h2
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h2
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h2
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h2
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_3 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h3
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h3
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h3
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h3
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h3
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h3
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h3
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h3
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h3
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h3
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h3
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h3
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h3
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h3
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h3
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h3
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_4 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h4
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h4
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h4
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h4
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h4
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h4
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h4
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h4
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h4
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h4
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h4
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h4
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h4
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h4
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h4
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h4
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_5 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h5
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h5
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h5
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h5
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h5
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h5
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h5
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h5
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h5
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h5
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h5
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h5
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h5
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h5
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h5
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h5
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_6 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h6
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h6
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h6
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h6
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h6
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h6
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h6
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h6
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h6
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h6
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h6
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h6
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h6
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h6
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h6
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h6
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_7 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h7
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h7
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h7
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h7
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h7
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h7
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h7
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h7
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h7
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h7
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h7
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h7
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h7
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h7
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h7
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h7
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_8 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h8
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h8
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h8
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h8
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h8
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h8
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h8
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h8
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h8
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h8
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h8
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h8
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h8
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h8
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h8
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h8
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_9 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h9
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h9
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h9
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h9
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h9
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h9
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h9
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h9
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h9
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h9
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h9
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h9
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h9
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h9
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h9
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h9
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_10 =
    lineActive_0 & slot_addrs_0[3:0] == 4'hA
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'hA
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'hA
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'hA
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'hA
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'hA
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'hA
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'hA
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'hA
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'hA
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'hA
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'hA
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'hA
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'hA
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'hA
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'hA
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_11 =
    lineActive_0 & slot_addrs_0[3:0] == 4'hB
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'hB
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'hB
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'hB
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'hB
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'hB
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'hB
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'hB
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'hB
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'hB
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'hB
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'hB
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'hB
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'hB
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'hB
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'hB
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_12 =
    lineActive_0 & slot_addrs_0[3:0] == 4'hC
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'hC
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'hC
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'hC
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'hC
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'hC
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'hC
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'hC
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'hC
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'hC
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'hC
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'hC
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'hC
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'hC
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'hC
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'hC
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_13 =
    lineActive_0 & slot_addrs_0[3:0] == 4'hD
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'hD
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'hD
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'hD
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'hD
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'hD
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'hD
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'hD
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'hD
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'hD
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'hD
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'hD
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'hD
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'hD
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'hD
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'hD
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_14 =
    lineActive_0 & slot_addrs_0[3:0] == 4'hE
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'hE
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'hE
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'hE
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'hE
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'hE
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'hE
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'hE
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'hE
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'hE
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'hE
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'hE
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'hE
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'hE
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'hE
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'hE
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_15 =
    lineActive_0 & (&(slot_addrs_0[3:0]))
      ? slot_data_0
      : lineActive_1 & (&(slot_addrs_1[3:0]))
          ? slot_data_1
          : lineActive_2 & (&(slot_addrs_2[3:0]))
              ? slot_data_2
              : lineActive_3 & (&(slot_addrs_3[3:0]))
                  ? slot_data_3
                  : lineActive_4 & (&(slot_addrs_4[3:0]))
                      ? slot_data_4
                      : lineActive_5 & (&(slot_addrs_5[3:0]))
                          ? slot_data_5
                          : lineActive_6 & (&(slot_addrs_6[3:0]))
                              ? slot_data_6
                              : lineActive_7 & (&(slot_addrs_7[3:0]))
                                  ? slot_data_7
                                  : lineActive_8 & (&(slot_addrs_8[3:0]))
                                      ? slot_data_8
                                      : lineActive_9 & (&(slot_addrs_9[3:0]))
                                          ? slot_data_9
                                          : lineActive_10 & (&(slot_addrs_10[3:0]))
                                              ? slot_data_10
                                              : lineActive_11 & (&(slot_addrs_11[3:0]))
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & (&(slot_addrs_12[3:0]))
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & (&(slot_addrs_13[3:0]))
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & (&(slot_addrs_14[3:0]))
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & (&(slot_addrs_15[3:0]))
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire              wordAligned = targetAddress_bits[1:0] == 2'h0;
  wire              _io_rd_flt_bits_data_T = slot_op == 5'h0;
  wire              _io_rd_flt_bits_data_T_2 = slot_op == 5'h3;
  wire              _alignedAddress_T_2 = slot_op == 5'h5;
  wire              _io_rd_flt_bits_data_T_3 = slot_op == 5'h1;
  wire              _io_rd_flt_bits_data_T_5 = slot_op == 5'h4;
  wire              _alignedAddress_T_7 = slot_op == 5'h6;
  wire              _io_rd_flt_bits_data_T_6 = slot_op == 5'h2;
  wire              _alignedAddress_T_12 = slot_op == 5'h7;
  wire              _io_rd_flt_bits_data_T_7 = slot_op == 5'hC;
  wire              _ibusFault_valid_T_1 =
    loadUpdatedSlot_active_0 | loadUpdatedSlot_active_1;
  wire              io_ibus_valid_0 =
    ~slot_pendingVector
    & (_ibusFault_valid_T_1 | loadUpdatedSlot_active_2 | loadUpdatedSlot_active_3
       | loadUpdatedSlot_active_4 | loadUpdatedSlot_active_5 | loadUpdatedSlot_active_6
       | loadUpdatedSlot_active_7 | loadUpdatedSlot_active_8 | loadUpdatedSlot_active_9
       | loadUpdatedSlot_active_10 | loadUpdatedSlot_active_11 | loadUpdatedSlot_active_12
       | loadUpdatedSlot_active_13 | loadUpdatedSlot_active_14
       | loadUpdatedSlot_active_15) & itcm & ~slot_store;
  wire              _io_active_T = slot_active_0 | slot_active_1;
  wire              io_dbus_valid_0 =
    dtcm
    & (slot_store
         ? ~slot_pendingVector
           & (_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
              | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9
              | slot_active_10 | slot_active_11 | slot_active_12 | slot_active_13
              | slot_active_14 | slot_active_15)
         : ~slot_pendingVector
           & (_ibusFault_valid_T_1 | loadUpdatedSlot_active_2 | loadUpdatedSlot_active_3
              | loadUpdatedSlot_active_4 | loadUpdatedSlot_active_5
              | loadUpdatedSlot_active_6 | loadUpdatedSlot_active_7
              | loadUpdatedSlot_active_8 | loadUpdatedSlot_active_9
              | loadUpdatedSlot_active_10 | loadUpdatedSlot_active_11
              | loadUpdatedSlot_active_12 | loadUpdatedSlot_active_13
              | loadUpdatedSlot_active_14 | loadUpdatedSlot_active_15));
  wire              io_ebus_dbus_valid_0 =
    (~(itcm | dtcm | peri) | peri)
    & (slot_store
         ? ~slot_pendingVector
           & (_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
              | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9
              | slot_active_10 | slot_active_11 | slot_active_12 | slot_active_13
              | slot_active_14 | slot_active_15)
         : ~slot_pendingVector
           & (_ibusFault_valid_T_1 | loadUpdatedSlot_active_2 | loadUpdatedSlot_active_3
              | loadUpdatedSlot_active_4 | loadUpdatedSlot_active_5
              | loadUpdatedSlot_active_6 | loadUpdatedSlot_active_7
              | loadUpdatedSlot_active_8 | loadUpdatedSlot_active_9
              | loadUpdatedSlot_active_10 | loadUpdatedSlot_active_11
              | loadUpdatedSlot_active_12 | loadUpdatedSlot_active_13
              | loadUpdatedSlot_active_14 | loadUpdatedSlot_active_15));
  wire              ibusFired = io_ibus_valid_0 & io_ibus_ready;
  wire              ebusFired = io_ebus_dbus_valid_0 & io_ebus_dbus_ready;
  wire              ibusFault_valid =
    ~slot_pendingVector
    & (_ibusFault_valid_T_1 | loadUpdatedSlot_active_2 | loadUpdatedSlot_active_3
       | loadUpdatedSlot_active_4 | loadUpdatedSlot_active_5 | loadUpdatedSlot_active_6
       | loadUpdatedSlot_active_7 | loadUpdatedSlot_active_8 | loadUpdatedSlot_active_9
       | loadUpdatedSlot_active_10 | loadUpdatedSlot_active_11 | loadUpdatedSlot_active_12
       | loadUpdatedSlot_active_13 | loadUpdatedSlot_active_14
       | loadUpdatedSlot_active_15) & itcm & slot_store;
  wire              io_fault_valid_0 =
    io_ebus_fault_valid ? io_ebus_fault_valid : ibusFault_valid;
  wire              io_rd_valid_0 =
    (io_fault_valid_0 | ~slot_pendingVector
     & ~(_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
         | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9 | slot_active_10
         | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14
         | slot_active_15) & slot_pendingWriteback)
    & (|{_io_rd_flt_bits_data_T_6,
         _io_rd_flt_bits_data_T_5,
         _io_rd_flt_bits_data_T_3,
         _io_rd_flt_bits_data_T_2,
         _io_rd_flt_bits_data_T});
  wire [31:0]       io_rd_bits_data_halfSigned =
    {{16{slot_data_1[7]}}, slot_data_1, slot_data_0};
  wire [31:0]       io_rd_bits_data_byteSigned = {{24{slot_data_0[7]}}, slot_data_0};
  wire              _GEN = _io_rd_flt_bits_data_T_6 | _io_rd_flt_bits_data_T_7;
  wire [31:0]       _GEN_0 = {16'h0, slot_data_1, slot_data_0};
  wire [31:0]       _GEN_1 = {24'h0, slot_data_0};
  wire              io_rd_flt_valid_0 =
    ~slot_pendingVector
    & ~(_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
        | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9 | slot_active_10
        | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14
        | slot_active_15) & slot_pendingWriteback & _io_rd_flt_bits_data_T_7
    & ~slot_store;
  wire [31:0]       _GEN_2 = {slot_elemStride[27:0], 4'h0};
  wire              _vectorUpdatedSlot_T_538 = slot_sew == 3'h0;
  wire              _vectorUpdatedSlot_T_571 = slot_sew == 3'h1;
  wire              _vectorUpdatedSlot_T_636 = slot_sew == 3'h2;
  wire              _GEN_3 =
    _vectorUpdatedSlot_T_538 | _vectorUpdatedSlot_T_571 | _vectorUpdatedSlot_T_636;
  wire              _GEN_4 = _vectorUpdatedSlot_T_538 | _vectorUpdatedSlot_T_571;
  wire [31:0]       _vectorUpdatedSlot_segmentBaseAddr_T_2 =
    slot_baseAddr + slot_segmentStride * {29'h0, slot_vectorLoop_segment_curr};
  wire [31:0]       _GEN_5 = {slot_elemStride[30:0], 1'h0};
  wire [31:0]       _vectorUpdatedSlot_T_523 = slot_elemStride * 32'h3;
  wire [31:0]       _vectorUpdatedSlot_T_402 = slot_elemStride * 32'h5;
  wire [31:0]       _vectorUpdatedSlot_T_414 = slot_elemStride * 32'h6;
  wire [31:0]       _vectorUpdatedSlot_T_426 = slot_elemStride * 32'h7;
  wire [31:0]       _vectorUpdatedSlot_T_307 = slot_elemStride * 32'h9;
  wire [31:0]       _vectorUpdatedSlot_T_311 = slot_elemStride * 32'hA;
  wire [31:0]       _vectorUpdatedSlot_T_315 = slot_elemStride * 32'hB;
  wire [31:0]       _vectorUpdatedSlot_T_319 = slot_elemStride * 32'hC;
  wire [31:0]       _vectorUpdatedSlot_T_323 = slot_elemStride * 32'hD;
  wire [31:0]       _vectorUpdatedSlot_T_327 = slot_elemStride * 32'hE;
  wire [31:0]       _vectorUpdatedSlot_T_331 = slot_elemStride * 32'hF;
  wire              _writebackUpdatedSlot_result_baseAddr_T_19 = slot_elemWidth == 3'h0;
  wire [31:0]       _GEN_6 = {slot_elemStride[29:0], 2'h0};
  wire [31:0]       _GEN_7 = {slot_elemStride[28:0], 3'h0};
  wire              _writebackUpdatedSlot_result_baseAddr_T_23 = slot_elemWidth == 3'h5;
  wire              _writebackUpdatedSlot_result_baseAddr_T_27 = slot_elemWidth == 3'h6;
  wire              _GEN_8 =
    _writebackUpdatedSlot_result_baseAddr_T_19
    | _writebackUpdatedSlot_result_baseAddr_T_23
    | _writebackUpdatedSlot_result_baseAddr_T_27;
  wire              _flushCmd_T_6 =
    _ops_T & (|{_ops_T_3, _ops_T_2, flushCmd_result_fencei});
  wire              _flushCmd_T_7 = flushCmd_valid & io_flush_ready;
  wire              _nextSlot_result_elemStride_T = _opQueue_io_dataOut_0_op == 5'hD;
  wire              _nextSlot_T_16 = _opQueue_io_dataOut_0_op == 5'hE;
  wire              _nextSlot_unitStride_T = _opQueue_io_dataOut_0_op == 5'hF;
  wire              _nextSlot_unitStride_T_1 = _opQueue_io_dataOut_0_op == 5'h10;
  wire              _nextSlot_result_elemStride_T_1 = _opQueue_io_dataOut_0_op == 5'h11;
  wire              _nextSlot_T_17 = _opQueue_io_dataOut_0_op == 5'h12;
  wire              _nextSlot_unitStride_T_2 = _opQueue_io_dataOut_0_op == 5'h13;
  wire              _nextSlot_unitStride_T_3 = _opQueue_io_dataOut_0_op == 5'h14;
  wire [15:0]       nextSlot_active =
    (|{_opQueue_io_dataOut_0_op == 5'h5,
       _opQueue_io_dataOut_0_op == 5'h3,
       _opQueue_io_dataOut_0_op == 5'h0})
      ? 16'h1
      : (|{_opQueue_io_dataOut_0_op == 5'h6,
           _opQueue_io_dataOut_0_op == 5'h4,
           _opQueue_io_dataOut_0_op == 5'h1})
          ? 16'h3
          : (|{_opQueue_io_dataOut_0_op == 5'hC,
               _opQueue_io_dataOut_0_op == 5'h7,
               _opQueue_io_dataOut_0_op == 5'h2})
              ? 16'hF
              : {16{|{_nextSlot_unitStride_T_3,
                      _nextSlot_unitStride_T_2,
                      _nextSlot_T_17,
                      _nextSlot_result_elemStride_T_1,
                      _nextSlot_unitStride_T_1,
                      _nextSlot_unitStride_T,
                      _nextSlot_T_16,
                      _nextSlot_result_elemStride_T}}};
  wire [3:0][127:0] _GEN_9 =
    {{128'h0}, {io_ebus_dbus_rdata}, {io_dbus_rdata}, {io_ibus_rdata}};
  wire [127:0]      readData = _GEN_9[readFired_bits_bus];
  wire [15:0][7:0]  _GEN_10 =
    {{readData[127:120]},
     {readData[119:112]},
     {readData[111:104]},
     {readData[103:96]},
     {readData[95:88]},
     {readData[87:80]},
     {readData[79:72]},
     {readData[71:64]},
     {readData[63:56]},
     {readData[55:48]},
     {readData[47:40]},
     {readData[39:32]},
     {readData[31:24]},
     {readData[23:16]},
     {readData[15:8]},
     {readData[7:0]}};
  wire              slotFired = ebusFired | io_dbus_valid_0 | ibusFired;
  wire              _readFired_T_1 = io_dbus_valid_0 & ~slot_store;
  wire              _readFired_T_3 = ebusFired & ~slot_store;
  wire              writebackFired = io_rd_valid_0 | io_rd_flt_valid_0;
  wire              writebackUpdatedSlot_vectorWriteback =
    writebackFired & slot_vectorLoop_isActive;
  wire              _writebackUpdatedSlot_lmulUpdate_T =
    slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max;
  wire              _writebackUpdatedSlot_lmulUpdate_T_1 =
    slot_vectorLoop_segment_curr == slot_vectorLoop_segment_max;
  wire              _writebackUpdatedSlot_result_vectorLoop_T_22 =
    slot_vectorLoop_lmul_curr == slot_vectorLoop_lmul_max;
  wire [2:0]        _writebackUpdatedSlot_result_vectorLoop_T_23 =
    slot_vectorLoop_lmul_curr + 3'h1;
  wire              _writebackUpdatedSlot_result_vectorLoop_T_21 =
    _writebackUpdatedSlot_lmulUpdate_T & _writebackUpdatedSlot_lmulUpdate_T_1;
  wire [4:0]        _writebackUpdatedSlot_result_vectorLoop_T_25 =
    slot_vectorLoop_rdStart
    + {2'h0,
       _writebackUpdatedSlot_result_vectorLoop_T_22
         ? 3'h0
         : _writebackUpdatedSlot_result_vectorLoop_T_23};
  wire [4:0]        _writebackUpdatedSlot_result_vectorLoop_T_30 =
    slot_vectorLoop_rd + {2'h0, slot_vectorLoop_lmul_max} + 5'h1;
  wire              _GEN_11 =
    ~writebackUpdatedSlot_vectorWriteback
    | ~(_writebackUpdatedSlot_lmulUpdate_T & _writebackUpdatedSlot_lmulUpdate_T_1
        & _writebackUpdatedSlot_result_vectorLoop_T_22);
  wire              writebackUpdatedSlot_vectorLoop_isActive =
    _GEN_11 & slot_vectorLoop_isActive;
  wire              _slotNext_T_20 =
    ~(slot_pendingVector | _io_active_T | slot_active_2 | slot_active_3 | slot_active_4
      | slot_active_5 | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9
      | slot_active_10 | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14
      | slot_active_15 | slot_pendingWriteback | slot_vectorLoop_isActive)
    & (|_opQueue_io_nEnqueued);
  wire              _slotNext_T_37 =
    ~slot_pendingVector
    & (_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
       | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9 | slot_active_10
       | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14
       | slot_active_15);
  wire              _slotNext_T_56 =
    ~slot_pendingVector
    & ~(_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
        | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9 | slot_active_10
        | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14
        | slot_active_15) & slot_pendingWriteback;
  wire              _GEN_12 = slot_pendingVector | _slotNext_T_37 | ~_slotNext_T_56;
  wire              _GEN_13 = slot_pendingVector | ~_slotNext_T_37;
  wire              _GEN_14 = io_fault_valid_0 | _slotNext_T_20;
  wire [1:0]        _nextSlot_T_18 = {_nextSlot_T_17, _nextSlot_T_16};
  wire              _GEN_15 =
    slot_pendingVector | _slotNext_T_37
    | ~(_slotNext_T_56 & writebackUpdatedSlot_vectorWriteback);
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      flushCmd_valid <= 1'h0;
      flushCmd_bits_fencei <= 1'h0;
      flushCmd_bits_pcNext <= 32'h0;
      readFired_valid <= 1'h0;
      readFired_bits_bus <= 2'h0;
      readFired_bits_lineAddr <= 28'h0;
      slot_op <= 5'h0;
      slot_rd <= 5'h0;
      slot_store <= 1'h0;
      slot_pc <= 32'h0;
      slot_active_0 <= 1'h0;
      slot_active_1 <= 1'h0;
      slot_active_2 <= 1'h0;
      slot_active_3 <= 1'h0;
      slot_active_4 <= 1'h0;
      slot_active_5 <= 1'h0;
      slot_active_6 <= 1'h0;
      slot_active_7 <= 1'h0;
      slot_active_8 <= 1'h0;
      slot_active_9 <= 1'h0;
      slot_active_10 <= 1'h0;
      slot_active_11 <= 1'h0;
      slot_active_12 <= 1'h0;
      slot_active_13 <= 1'h0;
      slot_active_14 <= 1'h0;
      slot_active_15 <= 1'h0;
      slot_baseAddr <= 32'h0;
      slot_addrs_0 <= 32'h0;
      slot_addrs_1 <= 32'h0;
      slot_addrs_2 <= 32'h0;
      slot_addrs_3 <= 32'h0;
      slot_addrs_4 <= 32'h0;
      slot_addrs_5 <= 32'h0;
      slot_addrs_6 <= 32'h0;
      slot_addrs_7 <= 32'h0;
      slot_addrs_8 <= 32'h0;
      slot_addrs_9 <= 32'h0;
      slot_addrs_10 <= 32'h0;
      slot_addrs_11 <= 32'h0;
      slot_addrs_12 <= 32'h0;
      slot_addrs_13 <= 32'h0;
      slot_addrs_14 <= 32'h0;
      slot_addrs_15 <= 32'h0;
      slot_data_0 <= 8'h0;
      slot_data_1 <= 8'h0;
      slot_data_2 <= 8'h0;
      slot_data_3 <= 8'h0;
      slot_data_4 <= 8'h0;
      slot_data_5 <= 8'h0;
      slot_data_6 <= 8'h0;
      slot_data_7 <= 8'h0;
      slot_data_8 <= 8'h0;
      slot_data_9 <= 8'h0;
      slot_data_10 <= 8'h0;
      slot_data_11 <= 8'h0;
      slot_data_12 <= 8'h0;
      slot_data_13 <= 8'h0;
      slot_data_14 <= 8'h0;
      slot_data_15 <= 8'h0;
      slot_pendingVector <= 1'h0;
      slot_pendingWriteback <= 1'h0;
      slot_elemStride <= 32'h0;
      slot_segmentStride <= 32'h0;
      slot_elemWidth <= 3'h0;
      slot_sew <= 3'h0;
      slot_vectorLoop_isActive <= 1'h0;
      slot_vectorLoop_subvector_curr <= 2'h0;
      slot_vectorLoop_subvector_max <= 2'h0;
      slot_vectorLoop_segment_curr <= 3'h0;
      slot_vectorLoop_segment_max <= 3'h0;
      slot_vectorLoop_lmul_curr <= 3'h0;
      slot_vectorLoop_lmul_max <= 3'h0;
      slot_vectorLoop_rdStart <= 5'h0;
      slot_vectorLoop_rd <= 5'h0;
    end
    else begin
      flushCmd_valid <= _flushCmd_T_6 | ~_flushCmd_T_7 & flushCmd_valid;
      flushCmd_bits_fencei <=
        _flushCmd_T_6 ? flushCmd_result_fencei : ~_flushCmd_T_7 & flushCmd_bits_fencei;
      if (_flushCmd_T_6)
        flushCmd_bits_pcNext <= io_req_0_bits_pc + 32'h4;
      else if (_flushCmd_T_7)
        flushCmd_bits_pcNext <= 32'h0;
      readFired_valid <=
        ibusFired | io_dbus_valid_0 & ~slot_store | ebusFired & ~slot_store;
      if (ibusFired)
        readFired_bits_bus <= 2'h0;
      else if (_readFired_T_1)
        readFired_bits_bus <= 2'h1;
      else if (_readFired_T_3)
        readFired_bits_bus <= 2'h2;
      if (ibusFired | _readFired_T_1 | _readFired_T_3)
        readFired_bits_lineAddr <= targetAddress_bits[31:4];
      if (io_fault_valid_0) begin
        slot_op <= 5'h0;
        slot_rd <= 5'h0;
        slot_pc <= 32'h0;
        slot_baseAddr <= 32'h0;
        slot_addrs_0 <= 32'h0;
        slot_addrs_1 <= 32'h0;
        slot_addrs_2 <= 32'h0;
        slot_addrs_3 <= 32'h0;
        slot_addrs_4 <= 32'h0;
        slot_addrs_5 <= 32'h0;
        slot_addrs_6 <= 32'h0;
        slot_addrs_7 <= 32'h0;
        slot_addrs_8 <= 32'h0;
        slot_addrs_9 <= 32'h0;
        slot_addrs_10 <= 32'h0;
        slot_addrs_11 <= 32'h0;
        slot_addrs_12 <= 32'h0;
        slot_addrs_13 <= 32'h0;
        slot_addrs_14 <= 32'h0;
        slot_addrs_15 <= 32'h0;
        slot_data_0 <= 8'h0;
        slot_data_1 <= 8'h0;
        slot_data_2 <= 8'h0;
        slot_data_3 <= 8'h0;
        slot_elemStride <= 32'h0;
        slot_segmentStride <= 32'h0;
      end
      else if (_slotNext_T_20) begin
        slot_op <= _opQueue_io_dataOut_0_op;
        slot_rd <= _opQueue_io_dataOut_0_rd;
        slot_pc <= _opQueue_io_dataOut_0_pc;
        slot_baseAddr <= _opQueue_io_dataOut_0_addr;
        slot_addrs_0 <= _opQueue_io_dataOut_0_addr;
        slot_addrs_1 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data
            : _opQueue_io_dataOut_0_addr + 32'h1;
        slot_addrs_2 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + {_opQueue_io_dataOut_0_data[30:0], 1'h0}
            : _opQueue_io_dataOut_0_addr + 32'h2;
        slot_addrs_3 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'h3
            : _opQueue_io_dataOut_0_addr + 32'h3;
        slot_addrs_4 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + {_opQueue_io_dataOut_0_data[29:0], 2'h0}
            : _opQueue_io_dataOut_0_addr + 32'h4;
        slot_addrs_5 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'h5
            : _opQueue_io_dataOut_0_addr + 32'h5;
        slot_addrs_6 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'h6
            : _opQueue_io_dataOut_0_addr + 32'h6;
        slot_addrs_7 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'h7
            : _opQueue_io_dataOut_0_addr + 32'h7;
        slot_addrs_8 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + {_opQueue_io_dataOut_0_data[28:0], 3'h0}
            : _opQueue_io_dataOut_0_addr + 32'h8;
        slot_addrs_9 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'h9
            : _opQueue_io_dataOut_0_addr + 32'h9;
        slot_addrs_10 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'hA
            : _opQueue_io_dataOut_0_addr + 32'hA;
        slot_addrs_11 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'hB
            : _opQueue_io_dataOut_0_addr + 32'hB;
        slot_addrs_12 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'hC
            : _opQueue_io_dataOut_0_addr + 32'hC;
        slot_addrs_13 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'hD
            : _opQueue_io_dataOut_0_addr + 32'hD;
        slot_addrs_14 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'hE
            : _opQueue_io_dataOut_0_addr + 32'hE;
        slot_addrs_15 <=
          (|_nextSlot_T_18)
            ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'hF
            : _opQueue_io_dataOut_0_addr + 32'hF;
        slot_data_0 <= _opQueue_io_dataOut_0_data[7:0];
        slot_data_1 <= _opQueue_io_dataOut_0_data[15:8];
        slot_data_2 <= _opQueue_io_dataOut_0_data[23:16];
        slot_data_3 <= _opQueue_io_dataOut_0_data[31:24];
        slot_elemStride <=
          (|{_nextSlot_result_elemStride_T_1, _nextSlot_result_elemStride_T})
            ? 32'h4
            : _opQueue_io_dataOut_0_data;
        slot_segmentStride <= 32'h1;
      end
      else begin
        if (_GEN_12) begin
        end
        else
          slot_rd <=
            writebackUpdatedSlot_vectorWriteback
              ? (_writebackUpdatedSlot_result_vectorLoop_T_21
                   ? _writebackUpdatedSlot_result_vectorLoop_T_25
                   : _writebackUpdatedSlot_lmulUpdate_T
                       ? _writebackUpdatedSlot_result_vectorLoop_T_30
                       : slot_vectorLoop_rd)
              : slot_vectorLoop_rd;
        if (slot_pendingVector | _slotNext_T_37
            | ~(_slotNext_T_56 & writebackFired & writebackUpdatedSlot_vectorWriteback
                & _writebackUpdatedSlot_lmulUpdate_T
                & _writebackUpdatedSlot_lmulUpdate_T_1)) begin
        end
        else if (|{_writebackUpdatedSlot_result_baseAddr_T_4,
                   _writebackUpdatedSlot_result_baseAddr_T_3})
          slot_baseAddr <=
            slot_baseAddr + {25'h0, slot_vectorLoop_segment_max, 4'h0} + 32'h10;
        else if (|{_writebackUpdatedSlot_result_baseAddr_T_13,
                   _writebackUpdatedSlot_result_baseAddr_T_12})
          slot_baseAddr <=
            _writebackUpdatedSlot_result_baseAddr_T_19
              ? slot_baseAddr + _GEN_2
              : _writebackUpdatedSlot_result_baseAddr_T_23
                  ? slot_baseAddr + _GEN_7
                  : _writebackUpdatedSlot_result_baseAddr_T_27
                      ? slot_baseAddr + _GEN_6
                      : slot_baseAddr + _GEN_2;
        if (slot_pendingVector) begin
          if (|{_writebackUpdatedSlot_result_baseAddr_T_4,
                _writebackUpdatedSlot_result_baseAddr_T_3}) begin
            slot_addrs_0 <= _GEN_8 ? _vectorUpdatedSlot_segmentBaseAddr_T_2 : 32'h0;
            slot_addrs_1 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                        : 32'h0;
            slot_addrs_2 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h2
                        : 32'h0;
            slot_addrs_3 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_523
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h3
                        : 32'h0;
            slot_addrs_4 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_6
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride
                        : 32'h0;
            slot_addrs_5 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_402
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5 + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h1
                        : 32'h0;
            slot_addrs_6 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_414
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_523
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h2
                        : 32'h0;
            slot_addrs_7 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_426
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_523
                      + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h3
                        : 32'h0;
            slot_addrs_8 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_7
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_6
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5
                        : 32'h0;
            slot_addrs_9 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_307
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_6 + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5 + 32'h1
                        : 32'h0;
            slot_addrs_10 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_311
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_402
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5 + 32'h2
                        : 32'h0;
            slot_addrs_11 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_315
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_402
                      + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5 + 32'h3
                        : 32'h0;
            slot_addrs_12 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_319
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_414
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_T_523
                        : 32'h0;
            slot_addrs_13 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_323
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_414
                      + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_T_523 + 32'h1
                        : 32'h0;
            slot_addrs_14 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_327
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_426
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_T_523 + 32'h2
                        : 32'h0;
            slot_addrs_15 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_331
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_426
                      + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_T_523 + 32'h3
                        : 32'h0;
          end
          else if (|{_writebackUpdatedSlot_result_baseAddr_T_13,
                     _writebackUpdatedSlot_result_baseAddr_T_12}) begin
            slot_addrs_0 <= _GEN_8 ? _vectorUpdatedSlot_segmentBaseAddr_T_2 : 32'h0;
            slot_addrs_1 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                        : 32'h0;
            slot_addrs_2 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h2
                        : 32'h0;
            slot_addrs_3 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_523
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h3
                        : 32'h0;
            slot_addrs_4 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_6
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride
                        : 32'h0;
            slot_addrs_5 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_402
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5 + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h1
                        : 32'h0;
            slot_addrs_6 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_414
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_523
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h2
                        : 32'h0;
            slot_addrs_7 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_426
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_523
                      + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h3
                        : 32'h0;
            slot_addrs_8 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_7
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_6
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5
                        : 32'h0;
            slot_addrs_9 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_307
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_6 + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5 + 32'h1
                        : 32'h0;
            slot_addrs_10 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_311
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_402
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5 + 32'h2
                        : 32'h0;
            slot_addrs_11 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_315
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_402
                      + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_5 + 32'h3
                        : 32'h0;
            slot_addrs_12 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_319
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_414
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_T_523
                        : 32'h0;
            slot_addrs_13 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_323
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_414
                      + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_T_523 + 32'h1
                        : 32'h0;
            slot_addrs_14 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_327
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_426
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_T_523 + 32'h2
                        : 32'h0;
            slot_addrs_15 <=
              _writebackUpdatedSlot_result_baseAddr_T_19
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_331
                : _writebackUpdatedSlot_result_baseAddr_T_23
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _vectorUpdatedSlot_T_426
                      + 32'h1
                    : _writebackUpdatedSlot_result_baseAddr_T_27
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_T_523 + 32'h3
                        : 32'h0;
          end
          else if (|{_storeComplete_T_49,
                     _storeComplete_T_48,
                     _storeComplete_T_45,
                     _storeComplete_T_44}) begin
            slot_addrs_0 <= _GEN_3 ? _vectorUpdatedSlot_segmentBaseAddr_T_2 : 32'h0;
            slot_addrs_1 <=
              _vectorUpdatedSlot_T_538
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                : _vectorUpdatedSlot_T_571
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                    : _vectorUpdatedSlot_T_636
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                        : 32'h0;
            slot_addrs_2 <=
              _GEN_4
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                : _vectorUpdatedSlot_T_636
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h2
                    : 32'h0;
            slot_addrs_3 <=
              _vectorUpdatedSlot_T_538
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                : _vectorUpdatedSlot_T_571
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                    : _vectorUpdatedSlot_T_636
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h3
                        : 32'h0;
            slot_addrs_4 <= _GEN_3 ? _vectorUpdatedSlot_segmentBaseAddr_T_2 : 32'h0;
            slot_addrs_5 <=
              _vectorUpdatedSlot_T_538
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                : _vectorUpdatedSlot_T_571
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                    : _vectorUpdatedSlot_T_636
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                        : 32'h0;
            slot_addrs_6 <=
              _GEN_4
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                : _vectorUpdatedSlot_T_636
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h2
                    : 32'h0;
            slot_addrs_7 <=
              _vectorUpdatedSlot_T_538
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                : _vectorUpdatedSlot_T_571
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                    : _vectorUpdatedSlot_T_636
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h3
                        : 32'h0;
            slot_addrs_8 <= _GEN_3 ? _vectorUpdatedSlot_segmentBaseAddr_T_2 : 32'h0;
            slot_addrs_9 <=
              _vectorUpdatedSlot_T_538
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                : _vectorUpdatedSlot_T_571
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                    : _vectorUpdatedSlot_T_636
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                        : 32'h0;
            slot_addrs_10 <=
              _GEN_4
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                : _vectorUpdatedSlot_T_636
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h2
                    : 32'h0;
            slot_addrs_11 <=
              _vectorUpdatedSlot_T_538
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                : _vectorUpdatedSlot_T_571
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                    : _vectorUpdatedSlot_T_636
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h3
                        : 32'h0;
            slot_addrs_12 <= _GEN_3 ? _vectorUpdatedSlot_segmentBaseAddr_T_2 : 32'h0;
            slot_addrs_13 <=
              _vectorUpdatedSlot_T_538
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                : _vectorUpdatedSlot_T_571
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                    : _vectorUpdatedSlot_T_636
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                        : 32'h0;
            slot_addrs_14 <=
              _GEN_4
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                : _vectorUpdatedSlot_T_636
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h2
                    : 32'h0;
            slot_addrs_15 <=
              _vectorUpdatedSlot_T_538
                ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                : _vectorUpdatedSlot_T_571
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                    : _vectorUpdatedSlot_T_636
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h3
                        : 32'h0;
          end
        end
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_0) begin
        end
        else
          slot_data_0 <= _GEN_10[slot_addrs_0[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_1) begin
        end
        else
          slot_data_1 <= _GEN_10[slot_addrs_1[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_2) begin
        end
        else
          slot_data_2 <= _GEN_10[slot_addrs_2[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_3) begin
        end
        else
          slot_data_3 <= _GEN_10[slot_addrs_3[3:0]];
      end
      slot_store <=
        ~io_fault_valid_0 & (_slotNext_T_20 ? _opQueue_io_dataOut_0_store : slot_store);
      slot_active_0 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[0]
             : _GEN_13
                 ? slot_active_0
                 : slot_store
                     ? slot_active_0 & ~(slotFired & (|valueSet_1))
                     : loadUpdatedSlot_active_0);
      slot_active_1 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[1]
             : _GEN_13
                 ? slot_active_1
                 : slot_store
                     ? slot_active_1 & ~(slotFired & (|selectionMatrix_1))
                     : loadUpdatedSlot_active_1);
      slot_active_2 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[2]
             : _GEN_13
                 ? slot_active_2
                 : slot_store
                     ? slot_active_2 & ~(slotFired & (|selectionMatrix_2))
                     : loadUpdatedSlot_active_2);
      slot_active_3 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[3]
             : _GEN_13
                 ? slot_active_3
                 : slot_store
                     ? slot_active_3 & ~(slotFired & (|selectionMatrix_3))
                     : loadUpdatedSlot_active_3);
      slot_active_4 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[4]
             : _GEN_13
                 ? slot_active_4
                 : slot_store
                     ? slot_active_4 & ~(slotFired & (|selectionMatrix_4))
                     : loadUpdatedSlot_active_4);
      slot_active_5 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[5]
             : _GEN_13
                 ? slot_active_5
                 : slot_store
                     ? slot_active_5 & ~(slotFired & (|selectionMatrix_5))
                     : loadUpdatedSlot_active_5);
      slot_active_6 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[6]
             : _GEN_13
                 ? slot_active_6
                 : slot_store
                     ? slot_active_6 & ~(slotFired & (|selectionMatrix_6))
                     : loadUpdatedSlot_active_6);
      slot_active_7 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[7]
             : _GEN_13
                 ? slot_active_7
                 : slot_store
                     ? slot_active_7 & ~(slotFired & (|selectionMatrix_7))
                     : loadUpdatedSlot_active_7);
      slot_active_8 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[8]
             : _GEN_13
                 ? slot_active_8
                 : slot_store
                     ? slot_active_8 & ~(slotFired & (|selectionMatrix_8))
                     : loadUpdatedSlot_active_8);
      slot_active_9 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[9]
             : _GEN_13
                 ? slot_active_9
                 : slot_store
                     ? slot_active_9 & ~(slotFired & (|selectionMatrix_9))
                     : loadUpdatedSlot_active_9);
      slot_active_10 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[10]
             : _GEN_13
                 ? slot_active_10
                 : slot_store
                     ? slot_active_10 & ~(slotFired & (|selectionMatrix_10))
                     : loadUpdatedSlot_active_10);
      slot_active_11 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[11]
             : _GEN_13
                 ? slot_active_11
                 : slot_store
                     ? slot_active_11 & ~(slotFired & (|selectionMatrix_11))
                     : loadUpdatedSlot_active_11);
      slot_active_12 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[12]
             : _GEN_13
                 ? slot_active_12
                 : slot_store
                     ? slot_active_12 & ~(slotFired & (|selectionMatrix_12))
                     : loadUpdatedSlot_active_12);
      slot_active_13 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[13]
             : _GEN_13
                 ? slot_active_13
                 : slot_store
                     ? slot_active_13 & ~(slotFired & (|selectionMatrix_13))
                     : loadUpdatedSlot_active_13);
      slot_active_14 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[14]
             : _GEN_13
                 ? slot_active_14
                 : slot_store
                     ? slot_active_14 & ~(slotFired & (|selectionMatrix_14))
                     : loadUpdatedSlot_active_14);
      slot_active_15 <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? nextSlot_active[15]
             : _GEN_13
                 ? slot_active_15
                 : slot_store
                     ? slot_active_15 & ~(slotFired & (|selectionMatrix_15))
                     : loadUpdatedSlot_active_15);
      if (_GEN_14) begin
        slot_data_4 <= 8'h0;
        slot_data_5 <= 8'h0;
        slot_data_6 <= 8'h0;
        slot_data_7 <= 8'h0;
        slot_data_8 <= 8'h0;
        slot_data_9 <= 8'h0;
        slot_data_10 <= 8'h0;
        slot_data_11 <= 8'h0;
        slot_data_12 <= 8'h0;
        slot_data_13 <= 8'h0;
        slot_data_14 <= 8'h0;
        slot_data_15 <= 8'h0;
        slot_elemWidth <= 3'h0;
        slot_sew <= 3'h0;
        slot_vectorLoop_subvector_curr <= 2'h0;
        slot_vectorLoop_subvector_max <= 2'h0;
        slot_vectorLoop_segment_curr <= 3'h0;
        slot_vectorLoop_segment_max <= 3'h0;
        slot_vectorLoop_lmul_curr <= 3'h0;
        slot_vectorLoop_lmul_max <= 3'h0;
        slot_vectorLoop_rdStart <= 5'h0;
        slot_vectorLoop_rd <= 5'h0;
      end
      else begin
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_4) begin
        end
        else
          slot_data_4 <= _GEN_10[slot_addrs_4[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_5) begin
        end
        else
          slot_data_5 <= _GEN_10[slot_addrs_5[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_6) begin
        end
        else
          slot_data_6 <= _GEN_10[slot_addrs_6[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_7) begin
        end
        else
          slot_data_7 <= _GEN_10[slot_addrs_7[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_8) begin
        end
        else
          slot_data_8 <= _GEN_10[slot_addrs_8[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_9) begin
        end
        else
          slot_data_9 <= _GEN_10[slot_addrs_9[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_10) begin
        end
        else
          slot_data_10 <= _GEN_10[slot_addrs_10[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_11) begin
        end
        else
          slot_data_11 <= _GEN_10[slot_addrs_11[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_12) begin
        end
        else
          slot_data_12 <= _GEN_10[slot_addrs_12[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_13) begin
        end
        else
          slot_data_13 <= _GEN_10[slot_addrs_13[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_14) begin
        end
        else
          slot_data_14 <= _GEN_10[slot_addrs_14[3:0]];
        if (slot_pendingVector | ~_slotNext_T_37 | slot_store
            | ~loadUpdatedSlot_lineActive_15) begin
        end
        else
          slot_data_15 <= _GEN_10[slot_addrs_15[3:0]];
        if (_GEN_15) begin
        end
        else
          slot_vectorLoop_subvector_curr <=
            _writebackUpdatedSlot_lmulUpdate_T
              ? 2'h0
              : slot_vectorLoop_subvector_curr + 2'h1;
        if (slot_pendingVector | _slotNext_T_37
            | ~(_slotNext_T_56 & writebackUpdatedSlot_vectorWriteback
                & _writebackUpdatedSlot_lmulUpdate_T)) begin
        end
        else
          slot_vectorLoop_segment_curr <=
            _writebackUpdatedSlot_lmulUpdate_T_1
              ? 3'h0
              : slot_vectorLoop_segment_curr + 3'h1;
        if (slot_pendingVector | _slotNext_T_37
            | ~(_slotNext_T_56 & writebackUpdatedSlot_vectorWriteback
                & _writebackUpdatedSlot_lmulUpdate_T
                & _writebackUpdatedSlot_lmulUpdate_T_1)) begin
        end
        else
          slot_vectorLoop_lmul_curr <=
            _writebackUpdatedSlot_result_vectorLoop_T_22
              ? 3'h0
              : _writebackUpdatedSlot_result_vectorLoop_T_23;
        if (_GEN_15) begin
        end
        else if (_writebackUpdatedSlot_result_vectorLoop_T_21)
          slot_vectorLoop_rd <= _writebackUpdatedSlot_result_vectorLoop_T_25;
        else if (_writebackUpdatedSlot_lmulUpdate_T)
          slot_vectorLoop_rd <= _writebackUpdatedSlot_result_vectorLoop_T_30;
      end
      slot_pendingVector <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? (|{_nextSlot_unitStride_T_3,
                  _nextSlot_unitStride_T_2,
                  _nextSlot_T_17,
                  _nextSlot_result_elemStride_T_1,
                  _nextSlot_unitStride_T_1,
                  _nextSlot_unitStride_T,
                  _nextSlot_T_16,
                  _nextSlot_result_elemStride_T})
             : _GEN_12
                 ? slot_pendingVector
                 : writebackFired
                     ? writebackUpdatedSlot_vectorLoop_isActive
                     : slot_pendingWriteback);
      slot_pendingWriteback <=
        ~io_fault_valid_0
        & (_slotNext_T_20
             ? (|{~_opQueue_io_dataOut_0_store,
                  _nextSlot_unitStride_T_3,
                  _nextSlot_unitStride_T_2,
                  _nextSlot_T_17,
                  _nextSlot_result_elemStride_T_1,
                  _nextSlot_unitStride_T_1,
                  _nextSlot_unitStride_T,
                  _nextSlot_T_16,
                  _nextSlot_result_elemStride_T})
             : slot_pendingVector | _slotNext_T_37 | ~(_slotNext_T_56 & writebackFired)
                 ? slot_pendingWriteback
                 : writebackUpdatedSlot_vectorLoop_isActive);
      slot_vectorLoop_isActive <=
        ~_GEN_14 & (slot_pendingVector | _slotNext_T_37 | ~_slotNext_T_56 | _GEN_11)
        & slot_vectorLoop_isActive;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:27];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [4:0] i = 5'h0; i < 5'h1C; i += 5'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        flushCmd_valid = _RANDOM[5'h0][0];
        flushCmd_bits_fencei = _RANDOM[5'h0][2];
        flushCmd_bits_pcNext = {_RANDOM[5'h0][31:3], _RANDOM[5'h1][2:0]};
        readFired_valid = _RANDOM[5'h1][3];
        readFired_bits_bus = _RANDOM[5'h1][5:4];
        readFired_bits_lineAddr = {_RANDOM[5'h1][31:6], _RANDOM[5'h2][1:0]};
        slot_op = _RANDOM[5'h2][6:2];
        slot_rd = _RANDOM[5'h2][11:7];
        slot_store = _RANDOM[5'h2][12];
        slot_pc = {_RANDOM[5'h2][31:13], _RANDOM[5'h3][12:0]};
        slot_active_0 = _RANDOM[5'h3][13];
        slot_active_1 = _RANDOM[5'h3][14];
        slot_active_2 = _RANDOM[5'h3][15];
        slot_active_3 = _RANDOM[5'h3][16];
        slot_active_4 = _RANDOM[5'h3][17];
        slot_active_5 = _RANDOM[5'h3][18];
        slot_active_6 = _RANDOM[5'h3][19];
        slot_active_7 = _RANDOM[5'h3][20];
        slot_active_8 = _RANDOM[5'h3][21];
        slot_active_9 = _RANDOM[5'h3][22];
        slot_active_10 = _RANDOM[5'h3][23];
        slot_active_11 = _RANDOM[5'h3][24];
        slot_active_12 = _RANDOM[5'h3][25];
        slot_active_13 = _RANDOM[5'h3][26];
        slot_active_14 = _RANDOM[5'h3][27];
        slot_active_15 = _RANDOM[5'h3][28];
        slot_baseAddr = {_RANDOM[5'h3][31:29], _RANDOM[5'h4][28:0]};
        slot_addrs_0 = {_RANDOM[5'h4][31:29], _RANDOM[5'h5][28:0]};
        slot_addrs_1 = {_RANDOM[5'h5][31:29], _RANDOM[5'h6][28:0]};
        slot_addrs_2 = {_RANDOM[5'h6][31:29], _RANDOM[5'h7][28:0]};
        slot_addrs_3 = {_RANDOM[5'h7][31:29], _RANDOM[5'h8][28:0]};
        slot_addrs_4 = {_RANDOM[5'h8][31:29], _RANDOM[5'h9][28:0]};
        slot_addrs_5 = {_RANDOM[5'h9][31:29], _RANDOM[5'hA][28:0]};
        slot_addrs_6 = {_RANDOM[5'hA][31:29], _RANDOM[5'hB][28:0]};
        slot_addrs_7 = {_RANDOM[5'hB][31:29], _RANDOM[5'hC][28:0]};
        slot_addrs_8 = {_RANDOM[5'hC][31:29], _RANDOM[5'hD][28:0]};
        slot_addrs_9 = {_RANDOM[5'hD][31:29], _RANDOM[5'hE][28:0]};
        slot_addrs_10 = {_RANDOM[5'hE][31:29], _RANDOM[5'hF][28:0]};
        slot_addrs_11 = {_RANDOM[5'hF][31:29], _RANDOM[5'h10][28:0]};
        slot_addrs_12 = {_RANDOM[5'h10][31:29], _RANDOM[5'h11][28:0]};
        slot_addrs_13 = {_RANDOM[5'h11][31:29], _RANDOM[5'h12][28:0]};
        slot_addrs_14 = {_RANDOM[5'h12][31:29], _RANDOM[5'h13][28:0]};
        slot_addrs_15 = {_RANDOM[5'h13][31:29], _RANDOM[5'h14][28:0]};
        slot_data_0 = {_RANDOM[5'h14][31:29], _RANDOM[5'h15][4:0]};
        slot_data_1 = _RANDOM[5'h15][12:5];
        slot_data_2 = _RANDOM[5'h15][20:13];
        slot_data_3 = _RANDOM[5'h15][28:21];
        slot_data_4 = {_RANDOM[5'h15][31:29], _RANDOM[5'h16][4:0]};
        slot_data_5 = _RANDOM[5'h16][12:5];
        slot_data_6 = _RANDOM[5'h16][20:13];
        slot_data_7 = _RANDOM[5'h16][28:21];
        slot_data_8 = {_RANDOM[5'h16][31:29], _RANDOM[5'h17][4:0]};
        slot_data_9 = _RANDOM[5'h17][12:5];
        slot_data_10 = _RANDOM[5'h17][20:13];
        slot_data_11 = _RANDOM[5'h17][28:21];
        slot_data_12 = {_RANDOM[5'h17][31:29], _RANDOM[5'h18][4:0]};
        slot_data_13 = _RANDOM[5'h18][12:5];
        slot_data_14 = _RANDOM[5'h18][20:13];
        slot_data_15 = _RANDOM[5'h18][28:21];
        slot_pendingVector = _RANDOM[5'h18][29];
        slot_pendingWriteback = _RANDOM[5'h18][30];
        slot_elemStride = {_RANDOM[5'h18][31], _RANDOM[5'h19][30:0]};
        slot_segmentStride = {_RANDOM[5'h19][31], _RANDOM[5'h1A][30:0]};
        slot_elemWidth = {_RANDOM[5'h1A][31], _RANDOM[5'h1B][1:0]};
        slot_sew = _RANDOM[5'h1B][4:2];
        slot_vectorLoop_isActive = _RANDOM[5'h1B][5];
        slot_vectorLoop_subvector_curr = _RANDOM[5'h1B][7:6];
        slot_vectorLoop_subvector_max = _RANDOM[5'h1B][9:8];
        slot_vectorLoop_segment_curr = _RANDOM[5'h1B][12:10];
        slot_vectorLoop_segment_max = _RANDOM[5'h1B][15:13];
        slot_vectorLoop_lmul_curr = _RANDOM[5'h1B][18:16];
        slot_vectorLoop_lmul_max = _RANDOM[5'h1B][21:19];
        slot_vectorLoop_rdStart = _RANDOM[5'h1B][26:22];
        slot_vectorLoop_rd = _RANDOM[5'h1B][31:27];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        flushCmd_valid = 1'h0;
        flushCmd_bits_fencei = 1'h0;
        flushCmd_bits_pcNext = 32'h0;
        readFired_valid = 1'h0;
        readFired_bits_bus = 2'h0;
        readFired_bits_lineAddr = 28'h0;
        slot_op = 5'h0;
        slot_rd = 5'h0;
        slot_store = 1'h0;
        slot_pc = 32'h0;
        slot_active_0 = 1'h0;
        slot_active_1 = 1'h0;
        slot_active_2 = 1'h0;
        slot_active_3 = 1'h0;
        slot_active_4 = 1'h0;
        slot_active_5 = 1'h0;
        slot_active_6 = 1'h0;
        slot_active_7 = 1'h0;
        slot_active_8 = 1'h0;
        slot_active_9 = 1'h0;
        slot_active_10 = 1'h0;
        slot_active_11 = 1'h0;
        slot_active_12 = 1'h0;
        slot_active_13 = 1'h0;
        slot_active_14 = 1'h0;
        slot_active_15 = 1'h0;
        slot_baseAddr = 32'h0;
        slot_addrs_0 = 32'h0;
        slot_addrs_1 = 32'h0;
        slot_addrs_2 = 32'h0;
        slot_addrs_3 = 32'h0;
        slot_addrs_4 = 32'h0;
        slot_addrs_5 = 32'h0;
        slot_addrs_6 = 32'h0;
        slot_addrs_7 = 32'h0;
        slot_addrs_8 = 32'h0;
        slot_addrs_9 = 32'h0;
        slot_addrs_10 = 32'h0;
        slot_addrs_11 = 32'h0;
        slot_addrs_12 = 32'h0;
        slot_addrs_13 = 32'h0;
        slot_addrs_14 = 32'h0;
        slot_addrs_15 = 32'h0;
        slot_data_0 = 8'h0;
        slot_data_1 = 8'h0;
        slot_data_2 = 8'h0;
        slot_data_3 = 8'h0;
        slot_data_4 = 8'h0;
        slot_data_5 = 8'h0;
        slot_data_6 = 8'h0;
        slot_data_7 = 8'h0;
        slot_data_8 = 8'h0;
        slot_data_9 = 8'h0;
        slot_data_10 = 8'h0;
        slot_data_11 = 8'h0;
        slot_data_12 = 8'h0;
        slot_data_13 = 8'h0;
        slot_data_14 = 8'h0;
        slot_data_15 = 8'h0;
        slot_pendingVector = 1'h0;
        slot_pendingWriteback = 1'h0;
        slot_elemStride = 32'h0;
        slot_segmentStride = 32'h0;
        slot_elemWidth = 3'h0;
        slot_sew = 3'h0;
        slot_vectorLoop_isActive = 1'h0;
        slot_vectorLoop_subvector_curr = 2'h0;
        slot_vectorLoop_subvector_max = 2'h0;
        slot_vectorLoop_segment_curr = 3'h0;
        slot_vectorLoop_segment_max = 3'h0;
        slot_vectorLoop_lmul_curr = 3'h0;
        slot_vectorLoop_lmul_max = 3'h0;
        slot_vectorLoop_rdStart = 5'h0;
        slot_vectorLoop_rd = 5'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  CircularBufferMulti_1 opQueue (
    .clock              (clock),
    .reset              (reset),
    .io_enqValid        (opQueue_io_enqValid),
    .io_enqData_0_store (_alignedOps_aligner_out_0_bits[106]),
    .io_enqData_0_rd    (_alignedOps_aligner_out_0_bits[105:101]),
    .io_enqData_0_op    (_alignedOps_aligner_out_0_bits[100:96]),
    .io_enqData_0_pc    (_alignedOps_aligner_out_0_bits[95:64]),
    .io_enqData_0_addr  (_alignedOps_aligner_out_0_bits[63:32]),
    .io_enqData_0_data  (_alignedOps_aligner_out_0_bits[31:0]),
    .io_enqData_1_store (_alignedOps_aligner_out_1_bits[106]),
    .io_enqData_1_rd    (_alignedOps_aligner_out_1_bits[105:101]),
    .io_enqData_1_op    (_alignedOps_aligner_out_1_bits[100:96]),
    .io_enqData_1_pc    (_alignedOps_aligner_out_1_bits[95:64]),
    .io_enqData_1_addr  (_alignedOps_aligner_out_1_bits[63:32]),
    .io_enqData_1_data  (_alignedOps_aligner_out_1_bits[31:0]),
    .io_nEnqueued       (_opQueue_io_nEnqueued),
    .io_nSpace          (_opQueue_io_nSpace),
    .io_dataOut_0_store (_opQueue_io_dataOut_0_store),
    .io_dataOut_0_rd    (_opQueue_io_dataOut_0_rd),
    .io_dataOut_0_op    (_opQueue_io_dataOut_0_op),
    .io_dataOut_0_pc    (_opQueue_io_dataOut_0_pc),
    .io_dataOut_0_addr  (_opQueue_io_dataOut_0_addr),
    .io_dataOut_0_data  (_opQueue_io_dataOut_0_data),
    .io_dataOut_1_store (/* unused */),
    .io_dataOut_1_rd    (/* unused */),
    .io_dataOut_1_op    (/* unused */),
    .io_dataOut_1_pc    (/* unused */),
    .io_dataOut_1_addr  (/* unused */),
    .io_dataOut_1_data  (/* unused */),
    .io_deqReady
      ({1'h0,
        ~(slot_pendingVector | _io_active_T | slot_active_2 | slot_active_3
          | slot_active_4 | slot_active_5 | slot_active_6 | slot_active_7 | slot_active_8
          | slot_active_9 | slot_active_10 | slot_active_11 | slot_active_12
          | slot_active_13 | slot_active_14 | slot_active_15 | slot_pendingWriteback
          | slot_vectorLoop_isActive) & (|_opQueue_io_nEnqueued)}),
    .io_flush           (1'h0)
  );
  Aligner_107_2 alignedOps_aligner (
    .in_0_valid  (_ops_T & {_ops_T_3, _ops_T_2, flushCmd_result_fencei} == 3'h0),
    .in_0_bits
      ({io_req_0_bits_store,
        io_req_0_bits_addr,
        io_req_0_bits_op,
        io_req_0_bits_pc,
        io_busPort_addr_0,
        io_req_0_bits_op == 5'hC ? io_busPort_flt_data_0 : io_busPort_data_0}),
    .in_1_valid
      (io_req_1_ready_0 & io_req_1_valid
       & {io_req_1_bits_op == 5'hA,
          io_req_1_bits_op == 5'h9,
          io_req_1_bits_op == 5'h8} == 3'h0),
    .in_1_bits
      ({io_req_1_bits_store,
        io_req_1_bits_addr,
        io_req_1_bits_op,
        io_req_1_bits_pc,
        io_busPort_addr_1,
        io_req_1_bits_op == 5'hC ? 32'h0 : io_busPort_data_1}),
    .out_0_valid (_alignedOps_aligner_out_0_valid),
    .out_0_bits  (_alignedOps_aligner_out_0_bits),
    .out_1_valid (_alignedOps_aligner_out_1_valid),
    .out_1_bits  (_alignedOps_aligner_out_1_bits)
  );
  assign io_req_0_ready = io_req_0_ready_0;
  assign io_req_1_ready = io_req_1_ready_0;
  assign io_rd_valid = io_rd_valid_0;
  assign io_rd_bits_addr = slot_rd;
  assign io_rd_bits_data =
    _io_rd_flt_bits_data_T
      ? io_rd_bits_data_byteSigned
      : _io_rd_flt_bits_data_T_2
          ? _GEN_1
          : _io_rd_flt_bits_data_T_3
              ? io_rd_bits_data_halfSigned
              : _io_rd_flt_bits_data_T_5
                  ? _GEN_0
                  : _GEN ? {slot_data_3, slot_data_2, slot_data_1, slot_data_0} : 32'h0;
  assign io_rd_flt_valid = io_rd_flt_valid_0;
  assign io_rd_flt_bits_addr = slot_rd;
  assign io_rd_flt_bits_data =
    _io_rd_flt_bits_data_T
      ? io_rd_bits_data_byteSigned
      : _io_rd_flt_bits_data_T_2
          ? _GEN_1
          : _io_rd_flt_bits_data_T_3
              ? io_rd_bits_data_halfSigned
              : _io_rd_flt_bits_data_T_5
                  ? _GEN_0
                  : _GEN ? {slot_data_3, slot_data_2, slot_data_1, slot_data_0} : 32'h0;
  assign io_ibus_valid = io_ibus_valid_0;
  assign io_ibus_addr = targetLineAddr;
  assign io_dbus_valid = io_dbus_valid_0;
  assign io_dbus_write = slot_store;
  assign io_dbus_addr = targetLineAddr;
  assign io_dbus_wdata =
    {wdata_15,
     wdata_14,
     wdata_13,
     wdata_12,
     wdata_11,
     wdata_10,
     wdata_9,
     wdata_8,
     wdata_7,
     wdata_6,
     wdata_5,
     wdata_4,
     wdata_3,
     wdata_2,
     wdata_1,
     wdata_0};
  assign io_dbus_wmask = _resultMask_T_14;
  assign io_flush_valid = flushCmd_valid;
  assign io_flush_fencei = flushCmd_bits_fencei;
  assign io_flush_pcNext = flushCmd_bits_pcNext;
  assign io_fault_valid = io_fault_valid_0;
  assign io_fault_bits_write =
    io_ebus_fault_valid ? io_ebus_fault_bits_write : ibusFault_valid;
  assign io_fault_bits_addr =
    io_ebus_fault_valid
      ? io_ebus_fault_bits_addr
      : ibusFault_valid ? targetLineAddr : 32'h0;
  assign io_fault_bits_epc =
    io_ebus_fault_valid ? io_ebus_fault_bits_epc : ibusFault_valid ? slot_pc : 32'h0;
  assign io_ebus_dbus_valid = io_ebus_dbus_valid_0;
  assign io_ebus_dbus_write = slot_store;
  assign io_ebus_dbus_pc = slot_pc;
  assign io_ebus_dbus_addr =
    (|{_alignedAddress_T_2, _io_rd_flt_bits_data_T_2, _io_rd_flt_bits_data_T})
      ? targetAddress_bits
      : (|{_alignedAddress_T_7, _io_rd_flt_bits_data_T_5, _io_rd_flt_bits_data_T_3})
        & ~(targetAddress_bits[0])
          ? {targetAddress_bits[31:1], 1'h0}
          : (|{_io_rd_flt_bits_data_T_7, _alignedAddress_T_12, _io_rd_flt_bits_data_T_6})
            & wordAligned
              ? {targetAddress_bits[31:2], 2'h0}
              : {targetAddress_bits[31:4], 4'h0};
  assign io_ebus_dbus_size =
    (|{_alignedAddress_T_2, _io_rd_flt_bits_data_T_2, _io_rd_flt_bits_data_T})
      ? 5'h1
      : (|{_alignedAddress_T_7, _io_rd_flt_bits_data_T_5, _io_rd_flt_bits_data_T_3})
          ? (targetAddress_bits[0] ? 5'h10 : 5'h2)
          : (|{_io_rd_flt_bits_data_T_7, _alignedAddress_T_12, _io_rd_flt_bits_data_T_6})
            & wordAligned
              ? 5'h4
              : 5'h10;
  assign io_ebus_dbus_wdata =
    {wdata_15,
     wdata_14,
     wdata_13,
     wdata_12,
     wdata_11,
     wdata_10,
     wdata_9,
     wdata_8,
     wdata_7,
     wdata_6,
     wdata_5,
     wdata_4,
     wdata_3,
     wdata_2,
     wdata_1,
     wdata_0};
  assign io_ebus_dbus_wmask = _resultMask_T_14;
  assign io_queueCapacity = _opQueue_io_nSpace;
  assign io_active =
    |{slot_pendingVector | _io_active_T | slot_active_2 | slot_active_3 | slot_active_4
        | slot_active_5 | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9
        | slot_active_10 | slot_active_11 | slot_active_12 | slot_active_13
        | slot_active_14 | slot_active_15 | slot_pendingWriteback
        | slot_vectorLoop_isActive,
      _opQueue_io_nEnqueued};
endmodule

module Arbiter2_MluCmd(
  input        io_in_0_valid,
  input  [4:0] io_in_0_bits_addr,
  input  [2:0] io_in_0_bits_op,
  output       io_in_1_ready,
  input        io_in_1_valid,
  input  [4:0] io_in_1_bits_addr,
  input  [2:0] io_in_1_bits_op,
  output       io_out_valid,
  output [4:0] io_out_bits_addr,
  output [2:0] io_out_bits_op,
  output       io_chosen
);

  assign io_in_1_ready = ~io_in_0_valid;
  assign io_out_valid = io_in_0_valid | io_in_1_valid;
  assign io_out_bits_addr = io_in_0_valid ? io_in_0_bits_addr : io_in_1_bits_addr;
  assign io_out_bits_op = io_in_0_valid ? io_in_0_bits_op : io_in_1_bits_op;
  assign io_chosen = ~io_in_0_valid;
endmodule

module Queue1_MluStage1(
  input        clock,
               reset,
               io_enq_valid,
  input  [4:0] io_enq_bits_rd,
  input  [2:0] io_enq_bits_op,
  input  [1:0] io_enq_bits_sel,
  output       io_deq_valid,
  output [4:0] io_deq_bits_rd,
  output [2:0] io_deq_bits_op,
  output [1:0] io_deq_bits_sel
);

  reg [9:0] ram;
  reg       full;
  always @(posedge clock or posedge reset) begin
    if (reset)
      full <= 1'h0;
    else if (~(io_enq_valid == full))
      full <= io_enq_valid;
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (io_enq_valid)
      ram <= {io_enq_bits_rd, io_enq_bits_op, io_enq_bits_sel};
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        full = _RANDOM[/*Zero width*/ 1'b0][0];
        ram = _RANDOM[/*Zero width*/ 1'b0][10:1];
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        full = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_deq_valid = full;
  assign io_deq_bits_rd = ram[9:5];
  assign io_deq_bits_op = ram[4:2];
  assign io_deq_bits_sel = ram[1:0];
endmodule

module Queue1_MluStage2(
  input         clock,
                reset,
                io_enq_valid,
  input  [4:0]  io_enq_bits_rd,
  input  [2:0]  io_enq_bits_op,
  input  [65:0] io_enq_bits_prod,
  output        io_deq_valid,
  output [4:0]  io_deq_bits_rd,
  output [2:0]  io_deq_bits_op,
  output [65:0] io_deq_bits_prod
);

  reg [73:0] ram;
  reg        full;
  always @(posedge clock or posedge reset) begin
    if (reset)
      full <= 1'h0;
    else if (~(io_enq_valid == full))
      full <= io_enq_valid;
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (io_enq_valid)
      ram <= {io_enq_bits_rd, io_enq_bits_op, io_enq_bits_prod};
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:2];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        full = _RANDOM[2'h0][0];
        ram = {_RANDOM[2'h0][31:1], _RANDOM[2'h1], _RANDOM[2'h2][10:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        full = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_deq_valid = full;
  assign io_deq_bits_rd = ram[73:69];
  assign io_deq_bits_op = ram[68:66];
  assign io_deq_bits_prod = ram[65:0];
endmodule

module Mlu(
  input         clock,
                reset,
                io_req_0_valid,
  input  [4:0]  io_req_0_bits_addr,
  input  [2:0]  io_req_0_bits_op,
  output        io_req_1_ready,
  input         io_req_1_valid,
  input  [4:0]  io_req_1_bits_addr,
  input  [2:0]  io_req_1_bits_op,
  input         io_rs1_0_valid,
  input  [31:0] io_rs1_0_data,
  input         io_rs1_1_valid,
  input  [31:0] io_rs1_1_data,
  input         io_rs2_0_valid,
  input  [31:0] io_rs2_0_data,
  input         io_rs2_1_valid,
  input  [31:0] io_rs2_1_data,
  output        io_rd_valid,
  output [4:0]  io_rd_bits_addr,
  output [31:0] io_rd_bits_data
);

  wire [2:0]  _stage3Input_q_io_deq_bits_op;
  wire [65:0] _stage3Input_q_io_deq_bits_prod;
  wire        _stage2Input_q_io_deq_valid;
  wire [4:0]  _stage2Input_q_io_deq_bits_rd;
  wire [2:0]  _stage2Input_q_io_deq_bits_op;
  wire [1:0]  _stage2Input_q_io_deq_bits_sel;
  wire        _arb_io_out_valid;
  wire [4:0]  _arb_io_out_bits_addr;
  wire [2:0]  _arb_io_out_bits_op;
  wire        _arb_io_chosen;
  wire [31:0] rs1 =
    (_stage2Input_q_io_deq_valid & _stage2Input_q_io_deq_bits_sel[0]
       ? io_rs1_0_data
       : 32'h0)
    | (_stage2Input_q_io_deq_valid & _stage2Input_q_io_deq_bits_sel[1]
         ? io_rs1_1_data
         : 32'h0);
  wire [31:0] rs2 =
    (_stage2Input_q_io_deq_valid & _stage2Input_q_io_deq_bits_sel[0]
       ? io_rs2_0_data
       : 32'h0)
    | (_stage2Input_q_io_deq_valid & _stage2Input_q_io_deq_bits_sel[1]
         ? io_rs2_1_data
         : 32'h0);
  wire        rs2signed = _stage2Input_q_io_deq_bits_op == 3'h1;
  Arbiter2_MluCmd arb (
    .io_in_0_valid     (io_req_0_valid),
    .io_in_0_bits_addr (io_req_0_bits_addr),
    .io_in_0_bits_op   (io_req_0_bits_op),
    .io_in_1_ready     (io_req_1_ready),
    .io_in_1_valid     (io_req_1_valid),
    .io_in_1_bits_addr (io_req_1_bits_addr),
    .io_in_1_bits_op   (io_req_1_bits_op),
    .io_out_valid      (_arb_io_out_valid),
    .io_out_bits_addr  (_arb_io_out_bits_addr),
    .io_out_bits_op    (_arb_io_out_bits_op),
    .io_chosen         (_arb_io_chosen)
  );
  Queue1_MluStage1 stage2Input_q (
    .clock           (clock),
    .reset           (reset),
    .io_enq_valid    (_arb_io_out_valid),
    .io_enq_bits_rd  (_arb_io_out_bits_addr),
    .io_enq_bits_op  (_arb_io_out_bits_op),
    .io_enq_bits_sel (2'h1 << _arb_io_chosen),
    .io_deq_valid    (_stage2Input_q_io_deq_valid),
    .io_deq_bits_rd  (_stage2Input_q_io_deq_bits_rd),
    .io_deq_bits_op  (_stage2Input_q_io_deq_bits_op),
    .io_deq_bits_sel (_stage2Input_q_io_deq_bits_sel)
  );
  Queue1_MluStage2 stage3Input_q (
    .clock            (clock),
    .reset            (reset),
    .io_enq_valid     (_stage2Input_q_io_deq_valid),
    .io_enq_bits_rd   (_stage2Input_q_io_deq_bits_rd),
    .io_enq_bits_op   (_stage2Input_q_io_deq_bits_op),
    .io_enq_bits_prod
      ({{34{(_stage2Input_q_io_deq_bits_op == 3'h2 | rs2signed) & rs1[31]}}, rs1}
       * {{34{rs2signed & rs2[31]}}, rs2}),
    .io_deq_valid     (io_rd_valid),
    .io_deq_bits_rd   (io_rd_bits_addr),
    .io_deq_bits_op   (_stage3Input_q_io_deq_bits_op),
    .io_deq_bits_prod (_stage3Input_q_io_deq_bits_prod)
  );
  assign io_rd_bits_data =
    _stage3Input_q_io_deq_bits_op == 3'h0
      ? _stage3Input_q_io_deq_bits_prod[31:0]
      : (|{_stage3Input_q_io_deq_bits_op == 3'h3,
           _stage3Input_q_io_deq_bits_op == 3'h2,
           _stage3Input_q_io_deq_bits_op == 3'h1})
          ? _stage3Input_q_io_deq_bits_prod[63:32]
          : 32'h0;
endmodule

module Dvu(
  input         clock,
                reset,
  output        io_req_ready,
  input         io_req_valid,
  input  [4:0]  io_req_bits_addr,
  input  [1:0]  io_req_bits_op,
  input  [31:0] io_rs1_data,
                io_rs2_data,
  input         io_rd_ready,
  output        io_rd_valid,
  output [4:0]  io_rd_bits_addr,
  output [31:0] io_rd_bits_data
);

  reg         active;
  reg         compute;
  reg  [4:0]  addr1;
  reg         signed1;
  reg         divide1;
  reg  [4:0]  addr2;
  reg         signed2d;
  reg         signed2r;
  reg         divide2;
  reg  [5:0]  count;
  reg  [31:0] divide;
  reg  [31:0] remain;
  reg  [31:0] denom;
  wire        io_req_ready_0 = ~active & ~compute & ~(count[5]);
  wire        _divide1_T_1 = io_req_bits_op == 2'h0;
  wire [31:0] inp = signed1 & io_rs1_data[31] ? ~io_rs1_data + 32'h1 : io_rs1_data;
  wire [15:0] _clz_T_12 = {8'h0, inp[15:8]} | {inp[7:0], 8'h0};
  wire [15:0] _clz_T_22 =
    {4'h0, _clz_T_12[15:4] & 12'hF0F} | {_clz_T_12[11:0] & 12'hF0F, 4'h0};
  wire [15:0] _clz_T_32 =
    {2'h0, _clz_T_22[15:2] & 14'h3333} | {_clz_T_22[13:0] & 14'h3333, 2'h0};
  wire [14:0] _clz_T_42 =
    _clz_T_32[15:1] & 15'h5555 | {1'h0, _clz_T_32[12:0] & 13'h1555, 1'h0};
  wire [7:0]  _clz_T_53 = {4'h0, inp[23:20]} | {inp[19:16], 4'h0};
  wire [7:0]  _clz_T_63 = {2'h0, _clz_T_53[7:2] & 6'h33} | {_clz_T_53[5:0] & 6'h33, 2'h0};
  wire [7:0]  _clz_T_73 = {1'h0, _clz_T_63[7:1] & 7'h55} | {_clz_T_63[6:0] & 7'h55, 1'h0};
  wire [4:0]  clz =
    ~(|io_rs2_data) | inp[31] | inp[30]
      ? 5'h0
      : inp[29]
          ? 5'h1
          : inp[28]
              ? 5'h2
              : inp[27]
                  ? 5'h3
                  : inp[26]
                      ? 5'h4
                      : inp[25]
                          ? 5'h5
                          : inp[24]
                              ? 5'h6
                              : _clz_T_73[0]
                                  ? 5'h7
                                  : _clz_T_73[1]
                                      ? 5'h8
                                      : _clz_T_73[2]
                                          ? 5'h9
                                          : _clz_T_73[3]
                                              ? 5'hA
                                              : _clz_T_73[4]
                                                  ? 5'hB
                                                  : _clz_T_73[5]
                                                      ? 5'hC
                                                      : _clz_T_73[6]
                                                          ? 5'hD
                                                          : _clz_T_73[7]
                                                              ? 5'hE
                                                              : _clz_T_42[0]
                                                                  ? 5'hF
                                                                  : _clz_T_42[1]
                                                                      ? 5'h10
                                                                      : _clz_T_42[2]
                                                                          ? 5'h11
                                                                          : _clz_T_42[3]
                                                                              ? 5'h12
                                                                              : _clz_T_42[4]
                                                                                  ? 5'h13
                                                                                  : _clz_T_42[5]
                                                                                      ? 5'h14
                                                                                      : _clz_T_42[6]
                                                                                          ? 5'h15
                                                                                          : _clz_T_42[7]
                                                                                              ? 5'h16
                                                                                              : _clz_T_42[8]
                                                                                                  ? 5'h17
                                                                                                  : _clz_T_42[9]
                                                                                                      ? 5'h18
                                                                                                      : _clz_T_42[10]
                                                                                                          ? 5'h19
                                                                                                          : _clz_T_42[11]
                                                                                                              ? 5'h1A
                                                                                                              : _clz_T_42[12]
                                                                                                                  ? 5'h1B
                                                                                                                  : _clz_T_42[13]
                                                                                                                      ? 5'h1C
                                                                                                                      : _clz_T_42[14]
                                                                                                                          ? 5'h1D
                                                                                                                          : 5'h1E;
  wire [62:0] _divide_T = {31'h0, inp} << clz;
  wire [32:0] subtract = {1'h0, remain[30:0], divide[31]} - {1'h0, denom};
  wire        _divide1_T = io_req_valid & io_req_ready_0;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      active <= 1'h0;
      compute <= 1'h0;
      addr1 <= 5'h0;
      signed1 <= 1'h0;
      divide1 <= 1'h0;
      addr2 <= 5'h0;
      signed2d <= 1'h0;
      signed2r <= 1'h0;
      divide2 <= 1'h0;
      count <= 6'h0;
      divide <= 32'h0;
      remain <= 32'h0;
      denom <= 32'h0;
    end
    else begin
      active <= _divide1_T | count != 6'h1E & active;
      compute <= active;
      if (_divide1_T) begin
        addr1 <= io_req_bits_addr;
        signed1 <= |{io_req_bits_op == 2'h2, _divide1_T_1};
        divide1 <= |{io_req_bits_op == 2'h1, _divide1_T_1};
      end
      if (active & ~compute) begin
        addr2 <= addr1;
        signed2d <= signed1 & io_rs1_data[31] != io_rs2_data[31] & (|io_rs2_data);
        signed2r <= signed1 & io_rs1_data[31];
        divide2 <= divide1;
        count <= {1'h0, clz};
        divide <= _divide_T[31:0];
        remain <= 32'h0;
        denom <= signed1 & io_rs2_data[31] ? ~io_rs2_data + 32'h1 : io_rs2_data;
      end
      else if (compute & ~(count[5])) begin
        count <= count + 6'h1;
        divide <= subtract[32] ? {divide[30:0], 1'h0} : {divide[30:0], 1'h1};
        remain <= subtract[32] ? {remain[30:0], divide[31]} : subtract[31:0];
      end
      else if (count[5] & io_rd_ready)
        count <= 6'h0;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:3];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h4; i += 3'h1) begin
          _RANDOM[i[1:0]] = `RANDOM;
        end
        active = _RANDOM[2'h0][0];
        compute = _RANDOM[2'h0][1];
        addr1 = _RANDOM[2'h0][6:2];
        signed1 = _RANDOM[2'h0][7];
        divide1 = _RANDOM[2'h0][8];
        addr2 = _RANDOM[2'h0][13:9];
        signed2d = _RANDOM[2'h0][14];
        signed2r = _RANDOM[2'h0][15];
        divide2 = _RANDOM[2'h0][16];
        count = _RANDOM[2'h0][22:17];
        divide = {_RANDOM[2'h0][31:23], _RANDOM[2'h1][22:0]};
        remain = {_RANDOM[2'h1][31:23], _RANDOM[2'h2][22:0]};
        denom = {_RANDOM[2'h2][31:23], _RANDOM[2'h3][22:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        active = 1'h0;
        compute = 1'h0;
        addr1 = 5'h0;
        signed1 = 1'h0;
        divide1 = 1'h0;
        addr2 = 5'h0;
        signed2d = 1'h0;
        signed2r = 1'h0;
        divide2 = 1'h0;
        count = 6'h0;
        divide = 32'h0;
        remain = 32'h0;
        denom = 32'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_req_ready = io_req_ready_0;
  assign io_rd_valid = count[5];
  assign io_rd_bits_addr = addr2;
  assign io_rd_bits_data =
    divide2 ? (signed2d ? ~divide + 32'h1 : divide) : signed2r ? ~remain + 32'h1 : remain;
endmodule

module FaultManager(
  input         io_in_fault_0_csr,
                io_in_fault_0_jal,
                io_in_fault_0_jalr,
                io_in_fault_0_bxx,
                io_in_fault_0_undef,
                io_in_fault_1_jal,
                io_in_fault_1_jalr,
                io_in_fault_1_bxx,
  input  [31:0] io_in_pc_0_pc,
                io_in_pc_1_pc,
  input         io_in_memory_fault_valid,
                io_in_memory_fault_bits_write,
  input  [31:0] io_in_memory_fault_bits_addr,
                io_in_memory_fault_bits_epc,
  input         io_in_ibus_fault,
  input  [31:0] io_in_undef_0_inst,
                io_in_undef_1_inst,
                io_in_jal_0_target,
                io_in_jal_1_target,
                io_in_jalr_0_target,
                io_in_jalr_1_target,
  input         io_in_fetchFault,
  output        io_out_valid,
  output [31:0] io_out_bits_mepc,
                io_out_bits_mtval,
                io_out_bits_mcause
);

  wire faults_0 =
    io_in_fault_0_csr | io_in_fault_0_jal | io_in_fault_0_jalr | io_in_fault_0_bxx
    | io_in_fault_0_undef;
  wire fault = faults_0 | io_in_fault_1_jal | io_in_fault_1_jalr | io_in_fault_1_bxx;
  wire load_fault =
    io_in_memory_fault_valid & ~io_in_memory_fault_bits_write & ~io_in_ibus_fault;
  wire store_fault =
    io_in_memory_fault_valid & io_in_memory_fault_bits_write & ~io_in_ibus_fault;
  wire _GEN = load_fault | store_fault;
  wire first_fault_is_csr = io_in_fault_0_csr & ~io_in_fault_0_csr == ~faults_0;
  wire first_fault_is_jal =
    (io_in_fault_0_jal | io_in_fault_1_jal) & ~io_in_fault_0_jal == ~faults_0;
  wire first_fault_is_jalr =
    (io_in_fault_0_jalr | io_in_fault_1_jalr) & ~io_in_fault_0_jalr == ~faults_0;
  wire first_fault_is_bxx =
    (io_in_fault_0_bxx | io_in_fault_1_bxx) & ~io_in_fault_0_bxx == ~faults_0;
  wire first_fault_is_undef = io_in_fault_0_undef & ~io_in_fault_0_undef == ~faults_0;
  assign io_out_valid = fault | io_in_fetchFault | load_fault | store_fault;
  assign io_out_bits_mepc =
    _GEN
      ? io_in_memory_fault_bits_epc
      : fault
          ? (faults_0 ? io_in_pc_0_pc : io_in_pc_1_pc)
          : io_in_fetchFault ? io_in_memory_fault_bits_epc : 32'h0;
  assign io_out_bits_mtval =
    _GEN
      ? io_in_memory_fault_bits_addr
      : first_fault_is_csr
          ? 32'h0
          : first_fault_is_jal
              ? (io_in_fault_0_jal ? io_in_jal_0_target : io_in_jal_1_target)
              : first_fault_is_jalr
                  ? (io_in_fault_0_jalr ? io_in_jalr_0_target : io_in_jalr_1_target)
                    & 32'hFFFFFFFE
                  : first_fault_is_bxx | ~first_fault_is_undef
                      ? 32'h0
                      : io_in_fault_0_undef ? io_in_undef_0_inst : io_in_undef_1_inst;
  assign io_out_bits_mcause =
    load_fault
      ? 32'h5
      : store_fault
          ? 32'h7
          : first_fault_is_csr
              ? 32'h2
              : first_fault_is_jal | first_fault_is_jalr | first_fault_is_bxx
                  ? 32'h0
                  : first_fault_is_undef ? 32'h2 : {31'h0, io_in_fetchFault};
endmodule

module Queue1_FloatInstruction(
  input         clock,
                reset,
                io_enq_valid,
  input  [2:0]  io_enq_bits_opcode,
  input  [4:0]  io_enq_bits_funct5,
                io_enq_bits_rs3,
                io_enq_bits_rs2,
                io_enq_bits_rs1,
  input  [2:0]  io_enq_bits_rm,
  input  [31:0] io_enq_bits_inst,
                io_enq_bits_pc,
  input         io_enq_bits_scalar_rd,
                io_enq_bits_scalar_rs1,
  input  [4:0]  io_enq_bits_rd,
  input         io_enq_bits_uses_rs3,
                io_enq_bits_uses_rs2,
                io_deq_ready,
  output        io_deq_valid,
  output [2:0]  io_deq_bits_opcode,
  output [4:0]  io_deq_bits_funct5,
                io_deq_bits_rs3,
                io_deq_bits_rs2,
                io_deq_bits_rs1,
  output [2:0]  io_deq_bits_rm,
  output        io_deq_bits_scalar_rd,
  output [4:0]  io_deq_bits_rd,
  output        io_count
);

  reg  [98:0] ram;
  wire        io_enq_ready;
  reg         full;
  wire        do_enq = io_enq_ready & io_enq_valid;
  assign io_enq_ready = ~full;
  always @(posedge clock or posedge reset) begin
    if (reset)
      full <= 1'h0;
    else if (~(do_enq == (io_deq_ready & full)))
      full <= do_enq;
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (do_enq)
      ram <=
        {io_enq_bits_opcode,
         io_enq_bits_funct5,
         io_enq_bits_rs3,
         io_enq_bits_rs2,
         io_enq_bits_rs1,
         io_enq_bits_rm,
         io_enq_bits_inst,
         io_enq_bits_pc,
         io_enq_bits_scalar_rd,
         io_enq_bits_scalar_rs1,
         io_enq_bits_rd,
         io_enq_bits_uses_rs3,
         io_enq_bits_uses_rs2};
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:3];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h4; i += 3'h1) begin
          _RANDOM[i[1:0]] = `RANDOM;
        end
        full = _RANDOM[2'h0][0];
        ram = {_RANDOM[2'h0][31:1], _RANDOM[2'h1], _RANDOM[2'h2], _RANDOM[2'h3][3:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        full = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_deq_valid = full;
  assign io_deq_bits_opcode = ram[98:96];
  assign io_deq_bits_funct5 = ram[95:91];
  assign io_deq_bits_rs3 = ram[90:86];
  assign io_deq_bits_rs2 = ram[85:81];
  assign io_deq_bits_rs1 = ram[80:76];
  assign io_deq_bits_rm = ram[75:73];
  assign io_deq_bits_scalar_rd = ram[8];
  assign io_deq_bits_rd = ram[6:2];
  assign io_count = full;
endmodule


// Include rmemory initializers in init blocks unless synthesis is set
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

// VCS coverage exclude_module
module ram_2x37(
  input         R0_addr,
                R0_en,
                R0_clk,
  output [36:0] R0_data,
  input         W0_addr,
                W0_en,
                W0_clk,
  input  [36:0] W0_data
);

  reg [36:0] Memory[0:1];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [63:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          for (logic [6:0] j = 7'h0; j < 7'h40; j += 7'h20) begin
            _RANDOM_MEM[j[5:0] +: 32] = `RANDOM;
          end
          Memory[i[0]] = _RANDOM_MEM[36:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 37'bx;
endmodule

module Queue2_RegfileWriteDataIO(
  input         clock,
                reset,
  output        io_enq_ready,
  input         io_enq_valid,
  input  [4:0]  io_enq_bits_addr,
  input  [31:0] io_enq_bits_data,
  input         io_deq_ready,
  output        io_deq_valid,
  output [4:0]  io_deq_bits_addr,
  output [31:0] io_deq_bits_data
);

  wire [36:0] _ram_ext_R0_data;
  reg         wrap;
  reg         wrap_1;
  reg         maybe_full;
  wire        ptr_match = wrap == wrap_1;
  wire        empty = ptr_match & ~maybe_full;
  wire        full = ptr_match & maybe_full;
  wire        do_enq = ~full & io_enq_valid;
  wire        do_deq = io_deq_ready & ~empty;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      wrap <= 1'h0;
      wrap_1 <= 1'h0;
      maybe_full <= 1'h0;
    end
    else begin
      if (do_enq)
        wrap <= wrap - 1'h1;
      if (do_deq)
        wrap_1 <= wrap_1 - 1'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        wrap = _RANDOM[/*Zero width*/ 1'b0][0];
        wrap_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][2];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        wrap = 1'h0;
        wrap_1 = 1'h0;
        maybe_full = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_2x37 ram_ext (
    .R0_addr (wrap_1),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (wrap),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({io_enq_bits_addr, io_enq_bits_data})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_addr = _ram_ext_R0_data[36:32];
  assign io_deq_bits_data = _ram_ext_R0_data[31:0];
endmodule

module FloatCore(
  input         clock,
                reset,
  output        io_inst_ready,
  input         io_inst_valid,
  input  [2:0]  io_inst_bits_opcode,
  input  [4:0]  io_inst_bits_funct5,
                io_inst_bits_rs3,
                io_inst_bits_rs2,
                io_inst_bits_rs1,
  input  [2:0]  io_inst_bits_rm,
  input  [31:0] io_inst_bits_inst,
                io_inst_bits_pc,
  input         io_inst_bits_scalar_rd,
                io_inst_bits_scalar_rs1,
  input  [4:0]  io_inst_bits_rd,
  input         io_inst_bits_uses_rs3,
                io_inst_bits_uses_rs2,
  output        io_read_ports_0_valid,
  output [4:0]  io_read_ports_0_addr,
  input  [22:0] io_read_ports_0_data_mantissa,
  input  [7:0]  io_read_ports_0_data_exponent,
  input         io_read_ports_0_data_sign,
  output        io_read_ports_1_valid,
  output [4:0]  io_read_ports_1_addr,
  input  [22:0] io_read_ports_1_data_mantissa,
  input  [7:0]  io_read_ports_1_data_exponent,
  input         io_read_ports_1_data_sign,
  output        io_read_ports_2_valid,
  output [4:0]  io_read_ports_2_addr,
  input  [22:0] io_read_ports_2_data_mantissa,
  input  [7:0]  io_read_ports_2_data_exponent,
  input         io_read_ports_2_data_sign,
  output        io_write_ports_0_valid,
  output [4:0]  io_write_ports_0_addr,
  output [22:0] io_write_ports_0_data_mantissa,
  output [7:0]  io_write_ports_0_data_exponent,
  output        io_write_ports_0_data_sign,
                io_write_ports_1_valid,
  output [4:0]  io_write_ports_1_addr,
  output [22:0] io_write_ports_1_data_mantissa,
  output [7:0]  io_write_ports_1_data_exponent,
  output        io_write_ports_1_data_sign,
  input  [31:0] io_rs1_data,
  input         io_scalar_rd_ready,
  output        io_scalar_rd_valid,
  output [4:0]  io_scalar_rd_bits_addr,
  output [31:0] io_scalar_rd_bits_data,
  output        io_csr_in_fflags_valid,
  output [4:0]  io_csr_in_fflags_bits,
  input  [2:0]  io_csr_out_frm,
  input         io_lsu_rd_valid,
  input  [4:0]  io_lsu_rd_bits_addr,
  input  [31:0] io_lsu_rd_bits_data
);

  wire            instQueue_io_deq_ready;
  wire            _floatCoreWrapper_io_out_ready_i_T_4;
  wire            _floatCoreWrapper_io_in_valid_i_T_3;
  wire            _scalar_rd_pipe_q_io_enq_ready;
  wire            _floatCoreWrapper_in_ready_o;
  wire            _floatCoreWrapper_out_valid_o;
  wire [31:0]     _floatCoreWrapper_result_o;
  wire            _instQueue_io_deq_valid;
  wire [2:0]      _instQueue_io_deq_bits_opcode;
  wire [4:0]      _instQueue_io_deq_bits_funct5;
  wire [4:0]      _instQueue_io_deq_bits_rs3;
  wire [4:0]      _instQueue_io_deq_bits_rs2;
  wire [4:0]      _instQueue_io_deq_bits_rs1;
  wire [2:0]      _instQueue_io_deq_bits_rm;
  wire            _instQueue_io_deq_bits_scalar_rd;
  wire [4:0]      _instQueue_io_deq_bits_rd;
  wire            _instQueue_io_count;
  wire            _opfp_mod_T_6 = _instQueue_io_deq_bits_funct5 == 5'h4;
  wire            _opfp_mod_T_8 = _instQueue_io_deq_bits_funct5 == 5'h18;
  wire            _fmv_x_w_T_2 = _instQueue_io_deq_bits_funct5 == 5'h1C;
  wire            _opfp_mod_T_10 = _instQueue_io_deq_bits_funct5 == 5'h1A;
  wire [3:0]      opfp_operation =
    _opfp_mod_T_10
      ? 4'hC
      : _fmv_x_w_T_2
          ? 4'h9
          : _instQueue_io_deq_bits_funct5 == 5'h14
              ? 4'h8
              : _opfp_mod_T_8
                  ? 4'hB
                  : {1'h0,
                     _instQueue_io_deq_bits_funct5 == 5'h5
                       ? 3'h7
                       : _opfp_mod_T_6
                           ? 3'h6
                           : _instQueue_io_deq_bits_funct5 == 5'hB
                               ? 3'h5
                               : _instQueue_io_deq_bits_funct5 == 5'h3
                                   ? 3'h4
                                   : {2'h1, _instQueue_io_deq_bits_funct5 == 5'h2}};
  wire [7:0][3:0] _GEN =
    {{4'h2}, {4'h1}, {4'h1}, {4'h0}, {4'h0}, {opfp_operation}, {4'hF}, {4'h2}};
  wire [3:0]      op_i = _GEN[_instQueue_io_deq_bits_opcode];
  wire            _read_port_2_valid_T = op_i == 4'h0;
  wire            _read_port_2_valid_T_1 = op_i == 4'h1;
  wire            _fmv_w_x_T = _instQueue_io_deq_bits_opcode == 3'h2;
  wire            _floatCoreWrapper_io_operands_i_0_T_1 = opfp_operation == 4'hC;
  wire            _fmv_w_x_T_4 = _instQueue_io_deq_bits_rm == 3'h0;
  wire            fmv_x_w =
    _instQueue_io_deq_valid & _fmv_w_x_T & _fmv_x_w_T_2 & _fmv_w_x_T_4;
  wire            fmv_w_x =
    _instQueue_io_deq_valid & _fmv_w_x_T & _instQueue_io_deq_bits_funct5 == 5'h1E
    & _fmv_w_x_T_4;
  wire            fmv = fmv_x_w | fmv_w_x;
  wire            _op2_addr_T = op_i == 4'h2;
  reg             fpuActive;
  wire            _io_csr_in_fflags_valid_T =
    instQueue_io_deq_ready & _instQueue_io_deq_valid;
  wire            _instQueue_io_deq_ready_T =
    _floatCoreWrapper_io_in_valid_i_T_3 & _floatCoreWrapper_in_ready_o;
  assign _floatCoreWrapper_io_in_valid_i_T_3 =
    _instQueue_io_deq_valid & ~fmv & ~fpuActive;
  wire [31:0]     _io_write_ports_0_data_T =
    fmv_w_x ? io_rs1_data : _floatCoreWrapper_result_o;
  assign _floatCoreWrapper_io_out_ready_i_T_4 =
    _instQueue_io_deq_valid & _instQueue_io_deq_bits_scalar_rd
    & _scalar_rd_pipe_q_io_enq_ready | _instQueue_io_deq_valid
    & ~_instQueue_io_deq_bits_scalar_rd;
  assign instQueue_io_deq_ready =
    (_instQueue_io_deq_ready_T | fpuActive) & _floatCoreWrapper_io_out_ready_i_T_4
    & _floatCoreWrapper_out_valid_o | fmv;
  always @(posedge clock or posedge reset) begin
    if (reset)
      fpuActive <= 1'h0;
    else
      fpuActive <= ~_io_csr_in_fflags_valid_T & (_instQueue_io_deq_ready_T | fpuActive);
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        fpuActive = _RANDOM[/*Zero width*/ 1'b0][0];
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        fpuActive = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Queue1_FloatInstruction instQueue (
    .clock                  (clock),
    .reset                  (reset),
    .io_enq_valid           (io_inst_valid),
    .io_enq_bits_opcode     (io_inst_bits_opcode),
    .io_enq_bits_funct5     (io_inst_bits_funct5),
    .io_enq_bits_rs3        (io_inst_bits_rs3),
    .io_enq_bits_rs2        (io_inst_bits_rs2),
    .io_enq_bits_rs1        (io_inst_bits_rs1),
    .io_enq_bits_rm         (io_inst_bits_rm),
    .io_enq_bits_inst       (io_inst_bits_inst),
    .io_enq_bits_pc         (io_inst_bits_pc),
    .io_enq_bits_scalar_rd  (io_inst_bits_scalar_rd),
    .io_enq_bits_scalar_rs1 (io_inst_bits_scalar_rs1),
    .io_enq_bits_rd         (io_inst_bits_rd),
    .io_enq_bits_uses_rs3   (io_inst_bits_uses_rs3),
    .io_enq_bits_uses_rs2   (io_inst_bits_uses_rs2),
    .io_deq_ready           (instQueue_io_deq_ready),
    .io_deq_valid           (_instQueue_io_deq_valid),
    .io_deq_bits_opcode     (_instQueue_io_deq_bits_opcode),
    .io_deq_bits_funct5     (_instQueue_io_deq_bits_funct5),
    .io_deq_bits_rs3        (_instQueue_io_deq_bits_rs3),
    .io_deq_bits_rs2        (_instQueue_io_deq_bits_rs2),
    .io_deq_bits_rs1        (_instQueue_io_deq_bits_rs1),
    .io_deq_bits_rm         (_instQueue_io_deq_bits_rm),
    .io_deq_bits_scalar_rd  (_instQueue_io_deq_bits_scalar_rd),
    .io_deq_bits_rd         (_instQueue_io_deq_bits_rd),
    .io_count               (_instQueue_io_count)
  );
  FloatCoreWrapper floatCoreWrapper (
    .clk_i        (clock),
    .rst_ni       (~reset),
    .in_valid_i   (_floatCoreWrapper_io_in_valid_i_T_3),
    .in_ready_o   (_floatCoreWrapper_in_ready_o),
    .operands_i_0
      (_fmv_w_x_T & _floatCoreWrapper_io_operands_i_0_T_1
         ? io_rs1_data
         : {io_read_ports_0_data_sign,
            io_read_ports_0_data_exponent,
            io_read_ports_0_data_mantissa}),
    .operands_i_1
      ({io_read_ports_1_data_sign,
        io_read_ports_1_data_exponent,
        io_read_ports_1_data_mantissa}),
    .operands_i_2
      ({io_read_ports_2_data_sign,
        io_read_ports_2_data_exponent,
        io_read_ports_2_data_mantissa}),
    .op_i         (op_i),
    .op_mod_i
      (_instQueue_io_deq_bits_opcode != 3'h6
       & (_instQueue_io_deq_bits_opcode == 3'h5 | _instQueue_io_deq_bits_opcode == 3'h4
          | _instQueue_io_deq_bits_opcode != 3'h3 & _instQueue_io_deq_bits_opcode == 3'h2
          & (_opfp_mod_T_10 | _opfp_mod_T_8
               ? _instQueue_io_deq_bits_rs2[0]
               : _opfp_mod_T_6 | _instQueue_io_deq_bits_funct5 == 5'h1))),
    .rnd_mode_i
      ((&_instQueue_io_deq_bits_rm) ? io_csr_out_frm : _instQueue_io_deq_bits_rm),
    .flush_i      (1'h0),
    .out_valid_o  (_floatCoreWrapper_out_valid_o),
    .out_ready_i  (_floatCoreWrapper_io_out_ready_i_T_4),
    .result_o     (_floatCoreWrapper_result_o),
    .status_o     (io_csr_in_fflags_bits),
    .busy_o       (/* unused */)
  );
  Queue2_RegfileWriteDataIO scalar_rd_pipe_q (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (_scalar_rd_pipe_q_io_enq_ready),
    .io_enq_valid
      ((_instQueue_io_deq_ready_T | fpuActive) & _floatCoreWrapper_out_valid_o
       & _floatCoreWrapper_io_out_ready_i_T_4 & _instQueue_io_deq_bits_scalar_rd
       | fmv_x_w),
    .io_enq_bits_addr (_instQueue_io_deq_bits_rd),
    .io_enq_bits_data
      (fmv_x_w
         ? {io_read_ports_0_data_sign,
            io_read_ports_0_data_exponent,
            io_read_ports_0_data_mantissa}
         : _floatCoreWrapper_result_o),
    .io_deq_ready     (io_scalar_rd_ready),
    .io_deq_valid     (io_scalar_rd_valid),
    .io_deq_bits_addr (io_scalar_rd_bits_addr),
    .io_deq_bits_data (io_scalar_rd_bits_data)
  );
  assign io_inst_ready = ~_instQueue_io_count;
  assign io_read_ports_0_valid = op_i != 4'h2 & _instQueue_io_deq_valid;
  assign io_read_ports_0_addr = _instQueue_io_deq_bits_rs1;
  assign io_read_ports_1_valid =
    ((|{_read_port_2_valid_T_1, _read_port_2_valid_T}) | _fmv_w_x_T
     & {_floatCoreWrapper_io_operands_i_0_T_1,
        opfp_operation == 4'hB,
        opfp_operation == 4'h9,
        opfp_operation == 4'h5} == 4'h0) & _instQueue_io_deq_valid;
  assign io_read_ports_1_addr =
    _op2_addr_T ? _instQueue_io_deq_bits_rs1 : _instQueue_io_deq_bits_rs2;
  assign io_read_ports_2_valid =
    ((|{_read_port_2_valid_T_1, _read_port_2_valid_T}) | _fmv_w_x_T
     & opfp_operation == 4'h2) & _instQueue_io_deq_valid;
  assign io_read_ports_2_addr =
    _op2_addr_T ? _instQueue_io_deq_bits_rs2 : _instQueue_io_deq_bits_rs3;
  assign io_write_ports_0_valid =
    (_floatCoreWrapper_out_valid_o & _io_csr_in_fflags_valid_T
     & ~_instQueue_io_deq_bits_scalar_rd | fmv_w_x)
    & ~(_instQueue_io_deq_valid & _instQueue_io_deq_bits_opcode == 3'h1);
  assign io_write_ports_0_addr = _instQueue_io_deq_bits_rd;
  assign io_write_ports_0_data_mantissa = _io_write_ports_0_data_T[22:0];
  assign io_write_ports_0_data_exponent = _io_write_ports_0_data_T[30:23];
  assign io_write_ports_0_data_sign = _io_write_ports_0_data_T[31];
  assign io_write_ports_1_valid = io_lsu_rd_valid;
  assign io_write_ports_1_addr = io_lsu_rd_bits_addr;
  assign io_write_ports_1_data_mantissa = io_lsu_rd_bits_data[22:0];
  assign io_write_ports_1_data_exponent = io_lsu_rd_bits_data[30:23];
  assign io_write_ports_1_data_sign = io_lsu_rd_bits_data[31];
  assign io_csr_in_fflags_valid =
    _floatCoreWrapper_out_valid_o & _io_csr_in_fflags_valid_T & ~fmv;
endmodule

module FRegfile(
  input         clock,
                reset,
                io_read_ports_0_valid,
  input  [4:0]  io_read_ports_0_addr,
  output [22:0] io_read_ports_0_data_mantissa,
  output [7:0]  io_read_ports_0_data_exponent,
  output        io_read_ports_0_data_sign,
  input         io_read_ports_1_valid,
  input  [4:0]  io_read_ports_1_addr,
  output [22:0] io_read_ports_1_data_mantissa,
  output [7:0]  io_read_ports_1_data_exponent,
  output        io_read_ports_1_data_sign,
  input         io_read_ports_2_valid,
  input  [4:0]  io_read_ports_2_addr,
  output [22:0] io_read_ports_2_data_mantissa,
  output [7:0]  io_read_ports_2_data_exponent,
  output        io_read_ports_2_data_sign,
  input         io_write_ports_0_valid,
  input  [4:0]  io_write_ports_0_addr,
  input  [22:0] io_write_ports_0_data_mantissa,
  input  [7:0]  io_write_ports_0_data_exponent,
  input         io_write_ports_0_data_sign,
                io_write_ports_1_valid,
  input  [4:0]  io_write_ports_1_addr,
  input  [22:0] io_write_ports_1_data_mantissa,
  input  [7:0]  io_write_ports_1_data_exponent,
  input         io_write_ports_1_data_sign,
  input  [31:0] io_scoreboard_set,
  output [31:0] io_scoreboard,
                io_busPort_data_0,
  input  [4:0]  io_busPortAddr
);

  reg  [22:0]       fregfile_0_mantissa;
  reg  [7:0]        fregfile_0_exponent;
  reg               fregfile_0_sign;
  reg  [22:0]       fregfile_1_mantissa;
  reg  [7:0]        fregfile_1_exponent;
  reg               fregfile_1_sign;
  reg  [22:0]       fregfile_2_mantissa;
  reg  [7:0]        fregfile_2_exponent;
  reg               fregfile_2_sign;
  reg  [22:0]       fregfile_3_mantissa;
  reg  [7:0]        fregfile_3_exponent;
  reg               fregfile_3_sign;
  reg  [22:0]       fregfile_4_mantissa;
  reg  [7:0]        fregfile_4_exponent;
  reg               fregfile_4_sign;
  reg  [22:0]       fregfile_5_mantissa;
  reg  [7:0]        fregfile_5_exponent;
  reg               fregfile_5_sign;
  reg  [22:0]       fregfile_6_mantissa;
  reg  [7:0]        fregfile_6_exponent;
  reg               fregfile_6_sign;
  reg  [22:0]       fregfile_7_mantissa;
  reg  [7:0]        fregfile_7_exponent;
  reg               fregfile_7_sign;
  reg  [22:0]       fregfile_8_mantissa;
  reg  [7:0]        fregfile_8_exponent;
  reg               fregfile_8_sign;
  reg  [22:0]       fregfile_9_mantissa;
  reg  [7:0]        fregfile_9_exponent;
  reg               fregfile_9_sign;
  reg  [22:0]       fregfile_10_mantissa;
  reg  [7:0]        fregfile_10_exponent;
  reg               fregfile_10_sign;
  reg  [22:0]       fregfile_11_mantissa;
  reg  [7:0]        fregfile_11_exponent;
  reg               fregfile_11_sign;
  reg  [22:0]       fregfile_12_mantissa;
  reg  [7:0]        fregfile_12_exponent;
  reg               fregfile_12_sign;
  reg  [22:0]       fregfile_13_mantissa;
  reg  [7:0]        fregfile_13_exponent;
  reg               fregfile_13_sign;
  reg  [22:0]       fregfile_14_mantissa;
  reg  [7:0]        fregfile_14_exponent;
  reg               fregfile_14_sign;
  reg  [22:0]       fregfile_15_mantissa;
  reg  [7:0]        fregfile_15_exponent;
  reg               fregfile_15_sign;
  reg  [22:0]       fregfile_16_mantissa;
  reg  [7:0]        fregfile_16_exponent;
  reg               fregfile_16_sign;
  reg  [22:0]       fregfile_17_mantissa;
  reg  [7:0]        fregfile_17_exponent;
  reg               fregfile_17_sign;
  reg  [22:0]       fregfile_18_mantissa;
  reg  [7:0]        fregfile_18_exponent;
  reg               fregfile_18_sign;
  reg  [22:0]       fregfile_19_mantissa;
  reg  [7:0]        fregfile_19_exponent;
  reg               fregfile_19_sign;
  reg  [22:0]       fregfile_20_mantissa;
  reg  [7:0]        fregfile_20_exponent;
  reg               fregfile_20_sign;
  reg  [22:0]       fregfile_21_mantissa;
  reg  [7:0]        fregfile_21_exponent;
  reg               fregfile_21_sign;
  reg  [22:0]       fregfile_22_mantissa;
  reg  [7:0]        fregfile_22_exponent;
  reg               fregfile_22_sign;
  reg  [22:0]       fregfile_23_mantissa;
  reg  [7:0]        fregfile_23_exponent;
  reg               fregfile_23_sign;
  reg  [22:0]       fregfile_24_mantissa;
  reg  [7:0]        fregfile_24_exponent;
  reg               fregfile_24_sign;
  reg  [22:0]       fregfile_25_mantissa;
  reg  [7:0]        fregfile_25_exponent;
  reg               fregfile_25_sign;
  reg  [22:0]       fregfile_26_mantissa;
  reg  [7:0]        fregfile_26_exponent;
  reg               fregfile_26_sign;
  reg  [22:0]       fregfile_27_mantissa;
  reg  [7:0]        fregfile_27_exponent;
  reg               fregfile_27_sign;
  reg  [22:0]       fregfile_28_mantissa;
  reg  [7:0]        fregfile_28_exponent;
  reg               fregfile_28_sign;
  reg  [22:0]       fregfile_29_mantissa;
  reg  [7:0]        fregfile_29_exponent;
  reg               fregfile_29_sign;
  reg  [22:0]       fregfile_30_mantissa;
  reg  [7:0]        fregfile_30_exponent;
  reg               fregfile_30_sign;
  reg  [22:0]       fregfile_31_mantissa;
  reg  [7:0]        fregfile_31_exponent;
  reg               fregfile_31_sign;
  reg  [31:0]       scoreboard;
  reg               scoreboard_error;
  wire [31:0][22:0] _GEN =
    {{fregfile_31_mantissa},
     {fregfile_30_mantissa},
     {fregfile_29_mantissa},
     {fregfile_28_mantissa},
     {fregfile_27_mantissa},
     {fregfile_26_mantissa},
     {fregfile_25_mantissa},
     {fregfile_24_mantissa},
     {fregfile_23_mantissa},
     {fregfile_22_mantissa},
     {fregfile_21_mantissa},
     {fregfile_20_mantissa},
     {fregfile_19_mantissa},
     {fregfile_18_mantissa},
     {fregfile_17_mantissa},
     {fregfile_16_mantissa},
     {fregfile_15_mantissa},
     {fregfile_14_mantissa},
     {fregfile_13_mantissa},
     {fregfile_12_mantissa},
     {fregfile_11_mantissa},
     {fregfile_10_mantissa},
     {fregfile_9_mantissa},
     {fregfile_8_mantissa},
     {fregfile_7_mantissa},
     {fregfile_6_mantissa},
     {fregfile_5_mantissa},
     {fregfile_4_mantissa},
     {fregfile_3_mantissa},
     {fregfile_2_mantissa},
     {fregfile_1_mantissa},
     {fregfile_0_mantissa}};
  wire [31:0][7:0]  _GEN_0 =
    {{fregfile_31_exponent},
     {fregfile_30_exponent},
     {fregfile_29_exponent},
     {fregfile_28_exponent},
     {fregfile_27_exponent},
     {fregfile_26_exponent},
     {fregfile_25_exponent},
     {fregfile_24_exponent},
     {fregfile_23_exponent},
     {fregfile_22_exponent},
     {fregfile_21_exponent},
     {fregfile_20_exponent},
     {fregfile_19_exponent},
     {fregfile_18_exponent},
     {fregfile_17_exponent},
     {fregfile_16_exponent},
     {fregfile_15_exponent},
     {fregfile_14_exponent},
     {fregfile_13_exponent},
     {fregfile_12_exponent},
     {fregfile_11_exponent},
     {fregfile_10_exponent},
     {fregfile_9_exponent},
     {fregfile_8_exponent},
     {fregfile_7_exponent},
     {fregfile_6_exponent},
     {fregfile_5_exponent},
     {fregfile_4_exponent},
     {fregfile_3_exponent},
     {fregfile_2_exponent},
     {fregfile_1_exponent},
     {fregfile_0_exponent}};
  wire [31:0]       _GEN_1 =
    {{fregfile_31_sign},
     {fregfile_30_sign},
     {fregfile_29_sign},
     {fregfile_28_sign},
     {fregfile_27_sign},
     {fregfile_26_sign},
     {fregfile_25_sign},
     {fregfile_24_sign},
     {fregfile_23_sign},
     {fregfile_22_sign},
     {fregfile_21_sign},
     {fregfile_20_sign},
     {fregfile_19_sign},
     {fregfile_18_sign},
     {fregfile_17_sign},
     {fregfile_16_sign},
     {fregfile_15_sign},
     {fregfile_14_sign},
     {fregfile_13_sign},
     {fregfile_12_sign},
     {fregfile_11_sign},
     {fregfile_10_sign},
     {fregfile_9_sign},
     {fregfile_8_sign},
     {fregfile_7_sign},
     {fregfile_6_sign},
     {fregfile_5_sign},
     {fregfile_4_sign},
     {fregfile_3_sign},
     {fregfile_2_sign},
     {fregfile_1_sign},
     {fregfile_0_sign}};
  wire [31:0]       scoreboard_clr =
    (io_write_ports_0_valid ? 32'h1 << io_write_ports_0_addr : 32'h0)
    | (io_write_ports_1_valid ? 32'h1 << io_write_ports_1_addr : 32'h0);
  wire              valid_0 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h0;
  wire              valid_0_1 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h1;
  wire              valid_0_2 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h2;
  wire              valid_0_3 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h3;
  wire              valid_0_4 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h4;
  wire              valid_0_5 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h5;
  wire              valid_0_6 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h6;
  wire              valid_0_7 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h7;
  wire              valid_0_8 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h8;
  wire              valid_0_9 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h9;
  wire              valid_0_10 = io_write_ports_0_valid & io_write_ports_0_addr == 5'hA;
  wire              valid_0_11 = io_write_ports_0_valid & io_write_ports_0_addr == 5'hB;
  wire              valid_0_12 = io_write_ports_0_valid & io_write_ports_0_addr == 5'hC;
  wire              valid_0_13 = io_write_ports_0_valid & io_write_ports_0_addr == 5'hD;
  wire              valid_0_14 = io_write_ports_0_valid & io_write_ports_0_addr == 5'hE;
  wire              valid_0_15 = io_write_ports_0_valid & io_write_ports_0_addr == 5'hF;
  wire              valid_0_16 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h10;
  wire              valid_0_17 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h11;
  wire              valid_0_18 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h12;
  wire              valid_0_19 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h13;
  wire              valid_0_20 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h14;
  wire              valid_0_21 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h15;
  wire              valid_0_22 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h16;
  wire              valid_0_23 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h17;
  wire              valid_0_24 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h18;
  wire              valid_0_25 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h19;
  wire              valid_0_26 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h1A;
  wire              valid_0_27 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h1B;
  wire              valid_0_28 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h1C;
  wire              valid_0_29 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h1D;
  wire              valid_0_30 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h1E;
  wire              valid_0_31 = io_write_ports_0_valid & (&io_write_ports_0_addr);
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      fregfile_0_mantissa <= 23'h0;
      fregfile_0_exponent <= 8'h0;
      fregfile_0_sign <= 1'h0;
      fregfile_1_mantissa <= 23'h0;
      fregfile_1_exponent <= 8'h0;
      fregfile_1_sign <= 1'h0;
      fregfile_2_mantissa <= 23'h0;
      fregfile_2_exponent <= 8'h0;
      fregfile_2_sign <= 1'h0;
      fregfile_3_mantissa <= 23'h0;
      fregfile_3_exponent <= 8'h0;
      fregfile_3_sign <= 1'h0;
      fregfile_4_mantissa <= 23'h0;
      fregfile_4_exponent <= 8'h0;
      fregfile_4_sign <= 1'h0;
      fregfile_5_mantissa <= 23'h0;
      fregfile_5_exponent <= 8'h0;
      fregfile_5_sign <= 1'h0;
      fregfile_6_mantissa <= 23'h0;
      fregfile_6_exponent <= 8'h0;
      fregfile_6_sign <= 1'h0;
      fregfile_7_mantissa <= 23'h0;
      fregfile_7_exponent <= 8'h0;
      fregfile_7_sign <= 1'h0;
      fregfile_8_mantissa <= 23'h0;
      fregfile_8_exponent <= 8'h0;
      fregfile_8_sign <= 1'h0;
      fregfile_9_mantissa <= 23'h0;
      fregfile_9_exponent <= 8'h0;
      fregfile_9_sign <= 1'h0;
      fregfile_10_mantissa <= 23'h0;
      fregfile_10_exponent <= 8'h0;
      fregfile_10_sign <= 1'h0;
      fregfile_11_mantissa <= 23'h0;
      fregfile_11_exponent <= 8'h0;
      fregfile_11_sign <= 1'h0;
      fregfile_12_mantissa <= 23'h0;
      fregfile_12_exponent <= 8'h0;
      fregfile_12_sign <= 1'h0;
      fregfile_13_mantissa <= 23'h0;
      fregfile_13_exponent <= 8'h0;
      fregfile_13_sign <= 1'h0;
      fregfile_14_mantissa <= 23'h0;
      fregfile_14_exponent <= 8'h0;
      fregfile_14_sign <= 1'h0;
      fregfile_15_mantissa <= 23'h0;
      fregfile_15_exponent <= 8'h0;
      fregfile_15_sign <= 1'h0;
      fregfile_16_mantissa <= 23'h0;
      fregfile_16_exponent <= 8'h0;
      fregfile_16_sign <= 1'h0;
      fregfile_17_mantissa <= 23'h0;
      fregfile_17_exponent <= 8'h0;
      fregfile_17_sign <= 1'h0;
      fregfile_18_mantissa <= 23'h0;
      fregfile_18_exponent <= 8'h0;
      fregfile_18_sign <= 1'h0;
      fregfile_19_mantissa <= 23'h0;
      fregfile_19_exponent <= 8'h0;
      fregfile_19_sign <= 1'h0;
      fregfile_20_mantissa <= 23'h0;
      fregfile_20_exponent <= 8'h0;
      fregfile_20_sign <= 1'h0;
      fregfile_21_mantissa <= 23'h0;
      fregfile_21_exponent <= 8'h0;
      fregfile_21_sign <= 1'h0;
      fregfile_22_mantissa <= 23'h0;
      fregfile_22_exponent <= 8'h0;
      fregfile_22_sign <= 1'h0;
      fregfile_23_mantissa <= 23'h0;
      fregfile_23_exponent <= 8'h0;
      fregfile_23_sign <= 1'h0;
      fregfile_24_mantissa <= 23'h0;
      fregfile_24_exponent <= 8'h0;
      fregfile_24_sign <= 1'h0;
      fregfile_25_mantissa <= 23'h0;
      fregfile_25_exponent <= 8'h0;
      fregfile_25_sign <= 1'h0;
      fregfile_26_mantissa <= 23'h0;
      fregfile_26_exponent <= 8'h0;
      fregfile_26_sign <= 1'h0;
      fregfile_27_mantissa <= 23'h0;
      fregfile_27_exponent <= 8'h0;
      fregfile_27_sign <= 1'h0;
      fregfile_28_mantissa <= 23'h0;
      fregfile_28_exponent <= 8'h0;
      fregfile_28_sign <= 1'h0;
      fregfile_29_mantissa <= 23'h0;
      fregfile_29_exponent <= 8'h0;
      fregfile_29_sign <= 1'h0;
      fregfile_30_mantissa <= 23'h0;
      fregfile_30_exponent <= 8'h0;
      fregfile_30_sign <= 1'h0;
      fregfile_31_mantissa <= 23'h0;
      fregfile_31_exponent <= 8'h0;
      fregfile_31_sign <= 1'h0;
      scoreboard <= 32'h0;
      scoreboard_error <= 1'h0;
    end
    else begin
      if (valid_0 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h0) begin
        fregfile_0_mantissa <=
          valid_0 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_0_exponent <=
          valid_0 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_0_sign <=
          valid_0 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_1 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h1) begin
        fregfile_1_mantissa <=
          valid_0_1 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_1_exponent <=
          valid_0_1 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_1_sign <=
          valid_0_1 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_2 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h2) begin
        fregfile_2_mantissa <=
          valid_0_2 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_2_exponent <=
          valid_0_2 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_2_sign <=
          valid_0_2 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_3 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h3) begin
        fregfile_3_mantissa <=
          valid_0_3 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_3_exponent <=
          valid_0_3 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_3_sign <=
          valid_0_3 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_4 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h4) begin
        fregfile_4_mantissa <=
          valid_0_4 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_4_exponent <=
          valid_0_4 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_4_sign <=
          valid_0_4 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_5 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h5) begin
        fregfile_5_mantissa <=
          valid_0_5 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_5_exponent <=
          valid_0_5 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_5_sign <=
          valid_0_5 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_6 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h6) begin
        fregfile_6_mantissa <=
          valid_0_6 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_6_exponent <=
          valid_0_6 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_6_sign <=
          valid_0_6 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_7 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h7) begin
        fregfile_7_mantissa <=
          valid_0_7 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_7_exponent <=
          valid_0_7 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_7_sign <=
          valid_0_7 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_8 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h8) begin
        fregfile_8_mantissa <=
          valid_0_8 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_8_exponent <=
          valid_0_8 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_8_sign <=
          valid_0_8 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_9 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h9) begin
        fregfile_9_mantissa <=
          valid_0_9 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_9_exponent <=
          valid_0_9 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_9_sign <=
          valid_0_9 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_10 | io_write_ports_1_valid & io_write_ports_1_addr == 5'hA) begin
        fregfile_10_mantissa <=
          valid_0_10 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_10_exponent <=
          valid_0_10 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_10_sign <=
          valid_0_10 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_11 | io_write_ports_1_valid & io_write_ports_1_addr == 5'hB) begin
        fregfile_11_mantissa <=
          valid_0_11 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_11_exponent <=
          valid_0_11 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_11_sign <=
          valid_0_11 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_12 | io_write_ports_1_valid & io_write_ports_1_addr == 5'hC) begin
        fregfile_12_mantissa <=
          valid_0_12 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_12_exponent <=
          valid_0_12 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_12_sign <=
          valid_0_12 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_13 | io_write_ports_1_valid & io_write_ports_1_addr == 5'hD) begin
        fregfile_13_mantissa <=
          valid_0_13 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_13_exponent <=
          valid_0_13 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_13_sign <=
          valid_0_13 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_14 | io_write_ports_1_valid & io_write_ports_1_addr == 5'hE) begin
        fregfile_14_mantissa <=
          valid_0_14 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_14_exponent <=
          valid_0_14 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_14_sign <=
          valid_0_14 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_15 | io_write_ports_1_valid & io_write_ports_1_addr == 5'hF) begin
        fregfile_15_mantissa <=
          valid_0_15 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_15_exponent <=
          valid_0_15 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_15_sign <=
          valid_0_15 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_16 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h10) begin
        fregfile_16_mantissa <=
          valid_0_16 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_16_exponent <=
          valid_0_16 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_16_sign <=
          valid_0_16 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_17 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h11) begin
        fregfile_17_mantissa <=
          valid_0_17 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_17_exponent <=
          valid_0_17 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_17_sign <=
          valid_0_17 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_18 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h12) begin
        fregfile_18_mantissa <=
          valid_0_18 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_18_exponent <=
          valid_0_18 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_18_sign <=
          valid_0_18 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_19 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h13) begin
        fregfile_19_mantissa <=
          valid_0_19 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_19_exponent <=
          valid_0_19 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_19_sign <=
          valid_0_19 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_20 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h14) begin
        fregfile_20_mantissa <=
          valid_0_20 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_20_exponent <=
          valid_0_20 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_20_sign <=
          valid_0_20 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_21 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h15) begin
        fregfile_21_mantissa <=
          valid_0_21 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_21_exponent <=
          valid_0_21 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_21_sign <=
          valid_0_21 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_22 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h16) begin
        fregfile_22_mantissa <=
          valid_0_22 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_22_exponent <=
          valid_0_22 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_22_sign <=
          valid_0_22 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_23 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h17) begin
        fregfile_23_mantissa <=
          valid_0_23 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_23_exponent <=
          valid_0_23 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_23_sign <=
          valid_0_23 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_24 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h18) begin
        fregfile_24_mantissa <=
          valid_0_24 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_24_exponent <=
          valid_0_24 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_24_sign <=
          valid_0_24 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_25 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h19) begin
        fregfile_25_mantissa <=
          valid_0_25 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_25_exponent <=
          valid_0_25 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_25_sign <=
          valid_0_25 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_26 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h1A) begin
        fregfile_26_mantissa <=
          valid_0_26 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_26_exponent <=
          valid_0_26 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_26_sign <=
          valid_0_26 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_27 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h1B) begin
        fregfile_27_mantissa <=
          valid_0_27 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_27_exponent <=
          valid_0_27 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_27_sign <=
          valid_0_27 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_28 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h1C) begin
        fregfile_28_mantissa <=
          valid_0_28 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_28_exponent <=
          valid_0_28 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_28_sign <=
          valid_0_28 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_29 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h1D) begin
        fregfile_29_mantissa <=
          valid_0_29 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_29_exponent <=
          valid_0_29 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_29_sign <=
          valid_0_29 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_30 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h1E) begin
        fregfile_30_mantissa <=
          valid_0_30 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_30_exponent <=
          valid_0_30 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_30_sign <=
          valid_0_30 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_31 | io_write_ports_1_valid & (&io_write_ports_1_addr)) begin
        fregfile_31_mantissa <=
          valid_0_31 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_31_exponent <=
          valid_0_31 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_31_sign <=
          valid_0_31 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      scoreboard <= scoreboard & ~scoreboard_clr | io_scoreboard_set;
      scoreboard_error <= (scoreboard & scoreboard_clr) != scoreboard_clr;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:33];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [5:0] i = 6'h0; i < 6'h22; i += 6'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        fregfile_0_mantissa = _RANDOM[6'h0][22:0];
        fregfile_0_exponent = _RANDOM[6'h0][30:23];
        fregfile_0_sign = _RANDOM[6'h0][31];
        fregfile_1_mantissa = _RANDOM[6'h1][22:0];
        fregfile_1_exponent = _RANDOM[6'h1][30:23];
        fregfile_1_sign = _RANDOM[6'h1][31];
        fregfile_2_mantissa = _RANDOM[6'h2][22:0];
        fregfile_2_exponent = _RANDOM[6'h2][30:23];
        fregfile_2_sign = _RANDOM[6'h2][31];
        fregfile_3_mantissa = _RANDOM[6'h3][22:0];
        fregfile_3_exponent = _RANDOM[6'h3][30:23];
        fregfile_3_sign = _RANDOM[6'h3][31];
        fregfile_4_mantissa = _RANDOM[6'h4][22:0];
        fregfile_4_exponent = _RANDOM[6'h4][30:23];
        fregfile_4_sign = _RANDOM[6'h4][31];
        fregfile_5_mantissa = _RANDOM[6'h5][22:0];
        fregfile_5_exponent = _RANDOM[6'h5][30:23];
        fregfile_5_sign = _RANDOM[6'h5][31];
        fregfile_6_mantissa = _RANDOM[6'h6][22:0];
        fregfile_6_exponent = _RANDOM[6'h6][30:23];
        fregfile_6_sign = _RANDOM[6'h6][31];
        fregfile_7_mantissa = _RANDOM[6'h7][22:0];
        fregfile_7_exponent = _RANDOM[6'h7][30:23];
        fregfile_7_sign = _RANDOM[6'h7][31];
        fregfile_8_mantissa = _RANDOM[6'h8][22:0];
        fregfile_8_exponent = _RANDOM[6'h8][30:23];
        fregfile_8_sign = _RANDOM[6'h8][31];
        fregfile_9_mantissa = _RANDOM[6'h9][22:0];
        fregfile_9_exponent = _RANDOM[6'h9][30:23];
        fregfile_9_sign = _RANDOM[6'h9][31];
        fregfile_10_mantissa = _RANDOM[6'hA][22:0];
        fregfile_10_exponent = _RANDOM[6'hA][30:23];
        fregfile_10_sign = _RANDOM[6'hA][31];
        fregfile_11_mantissa = _RANDOM[6'hB][22:0];
        fregfile_11_exponent = _RANDOM[6'hB][30:23];
        fregfile_11_sign = _RANDOM[6'hB][31];
        fregfile_12_mantissa = _RANDOM[6'hC][22:0];
        fregfile_12_exponent = _RANDOM[6'hC][30:23];
        fregfile_12_sign = _RANDOM[6'hC][31];
        fregfile_13_mantissa = _RANDOM[6'hD][22:0];
        fregfile_13_exponent = _RANDOM[6'hD][30:23];
        fregfile_13_sign = _RANDOM[6'hD][31];
        fregfile_14_mantissa = _RANDOM[6'hE][22:0];
        fregfile_14_exponent = _RANDOM[6'hE][30:23];
        fregfile_14_sign = _RANDOM[6'hE][31];
        fregfile_15_mantissa = _RANDOM[6'hF][22:0];
        fregfile_15_exponent = _RANDOM[6'hF][30:23];
        fregfile_15_sign = _RANDOM[6'hF][31];
        fregfile_16_mantissa = _RANDOM[6'h10][22:0];
        fregfile_16_exponent = _RANDOM[6'h10][30:23];
        fregfile_16_sign = _RANDOM[6'h10][31];
        fregfile_17_mantissa = _RANDOM[6'h11][22:0];
        fregfile_17_exponent = _RANDOM[6'h11][30:23];
        fregfile_17_sign = _RANDOM[6'h11][31];
        fregfile_18_mantissa = _RANDOM[6'h12][22:0];
        fregfile_18_exponent = _RANDOM[6'h12][30:23];
        fregfile_18_sign = _RANDOM[6'h12][31];
        fregfile_19_mantissa = _RANDOM[6'h13][22:0];
        fregfile_19_exponent = _RANDOM[6'h13][30:23];
        fregfile_19_sign = _RANDOM[6'h13][31];
        fregfile_20_mantissa = _RANDOM[6'h14][22:0];
        fregfile_20_exponent = _RANDOM[6'h14][30:23];
        fregfile_20_sign = _RANDOM[6'h14][31];
        fregfile_21_mantissa = _RANDOM[6'h15][22:0];
        fregfile_21_exponent = _RANDOM[6'h15][30:23];
        fregfile_21_sign = _RANDOM[6'h15][31];
        fregfile_22_mantissa = _RANDOM[6'h16][22:0];
        fregfile_22_exponent = _RANDOM[6'h16][30:23];
        fregfile_22_sign = _RANDOM[6'h16][31];
        fregfile_23_mantissa = _RANDOM[6'h17][22:0];
        fregfile_23_exponent = _RANDOM[6'h17][30:23];
        fregfile_23_sign = _RANDOM[6'h17][31];
        fregfile_24_mantissa = _RANDOM[6'h18][22:0];
        fregfile_24_exponent = _RANDOM[6'h18][30:23];
        fregfile_24_sign = _RANDOM[6'h18][31];
        fregfile_25_mantissa = _RANDOM[6'h19][22:0];
        fregfile_25_exponent = _RANDOM[6'h19][30:23];
        fregfile_25_sign = _RANDOM[6'h19][31];
        fregfile_26_mantissa = _RANDOM[6'h1A][22:0];
        fregfile_26_exponent = _RANDOM[6'h1A][30:23];
        fregfile_26_sign = _RANDOM[6'h1A][31];
        fregfile_27_mantissa = _RANDOM[6'h1B][22:0];
        fregfile_27_exponent = _RANDOM[6'h1B][30:23];
        fregfile_27_sign = _RANDOM[6'h1B][31];
        fregfile_28_mantissa = _RANDOM[6'h1C][22:0];
        fregfile_28_exponent = _RANDOM[6'h1C][30:23];
        fregfile_28_sign = _RANDOM[6'h1C][31];
        fregfile_29_mantissa = _RANDOM[6'h1D][22:0];
        fregfile_29_exponent = _RANDOM[6'h1D][30:23];
        fregfile_29_sign = _RANDOM[6'h1D][31];
        fregfile_30_mantissa = _RANDOM[6'h1E][22:0];
        fregfile_30_exponent = _RANDOM[6'h1E][30:23];
        fregfile_30_sign = _RANDOM[6'h1E][31];
        fregfile_31_mantissa = _RANDOM[6'h1F][22:0];
        fregfile_31_exponent = _RANDOM[6'h1F][30:23];
        fregfile_31_sign = _RANDOM[6'h1F][31];
        scoreboard = _RANDOM[6'h20];
        scoreboard_error = _RANDOM[6'h21][0];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        fregfile_0_mantissa = 23'h0;
        fregfile_0_exponent = 8'h0;
        fregfile_0_sign = 1'h0;
        fregfile_1_mantissa = 23'h0;
        fregfile_1_exponent = 8'h0;
        fregfile_1_sign = 1'h0;
        fregfile_2_mantissa = 23'h0;
        fregfile_2_exponent = 8'h0;
        fregfile_2_sign = 1'h0;
        fregfile_3_mantissa = 23'h0;
        fregfile_3_exponent = 8'h0;
        fregfile_3_sign = 1'h0;
        fregfile_4_mantissa = 23'h0;
        fregfile_4_exponent = 8'h0;
        fregfile_4_sign = 1'h0;
        fregfile_5_mantissa = 23'h0;
        fregfile_5_exponent = 8'h0;
        fregfile_5_sign = 1'h0;
        fregfile_6_mantissa = 23'h0;
        fregfile_6_exponent = 8'h0;
        fregfile_6_sign = 1'h0;
        fregfile_7_mantissa = 23'h0;
        fregfile_7_exponent = 8'h0;
        fregfile_7_sign = 1'h0;
        fregfile_8_mantissa = 23'h0;
        fregfile_8_exponent = 8'h0;
        fregfile_8_sign = 1'h0;
        fregfile_9_mantissa = 23'h0;
        fregfile_9_exponent = 8'h0;
        fregfile_9_sign = 1'h0;
        fregfile_10_mantissa = 23'h0;
        fregfile_10_exponent = 8'h0;
        fregfile_10_sign = 1'h0;
        fregfile_11_mantissa = 23'h0;
        fregfile_11_exponent = 8'h0;
        fregfile_11_sign = 1'h0;
        fregfile_12_mantissa = 23'h0;
        fregfile_12_exponent = 8'h0;
        fregfile_12_sign = 1'h0;
        fregfile_13_mantissa = 23'h0;
        fregfile_13_exponent = 8'h0;
        fregfile_13_sign = 1'h0;
        fregfile_14_mantissa = 23'h0;
        fregfile_14_exponent = 8'h0;
        fregfile_14_sign = 1'h0;
        fregfile_15_mantissa = 23'h0;
        fregfile_15_exponent = 8'h0;
        fregfile_15_sign = 1'h0;
        fregfile_16_mantissa = 23'h0;
        fregfile_16_exponent = 8'h0;
        fregfile_16_sign = 1'h0;
        fregfile_17_mantissa = 23'h0;
        fregfile_17_exponent = 8'h0;
        fregfile_17_sign = 1'h0;
        fregfile_18_mantissa = 23'h0;
        fregfile_18_exponent = 8'h0;
        fregfile_18_sign = 1'h0;
        fregfile_19_mantissa = 23'h0;
        fregfile_19_exponent = 8'h0;
        fregfile_19_sign = 1'h0;
        fregfile_20_mantissa = 23'h0;
        fregfile_20_exponent = 8'h0;
        fregfile_20_sign = 1'h0;
        fregfile_21_mantissa = 23'h0;
        fregfile_21_exponent = 8'h0;
        fregfile_21_sign = 1'h0;
        fregfile_22_mantissa = 23'h0;
        fregfile_22_exponent = 8'h0;
        fregfile_22_sign = 1'h0;
        fregfile_23_mantissa = 23'h0;
        fregfile_23_exponent = 8'h0;
        fregfile_23_sign = 1'h0;
        fregfile_24_mantissa = 23'h0;
        fregfile_24_exponent = 8'h0;
        fregfile_24_sign = 1'h0;
        fregfile_25_mantissa = 23'h0;
        fregfile_25_exponent = 8'h0;
        fregfile_25_sign = 1'h0;
        fregfile_26_mantissa = 23'h0;
        fregfile_26_exponent = 8'h0;
        fregfile_26_sign = 1'h0;
        fregfile_27_mantissa = 23'h0;
        fregfile_27_exponent = 8'h0;
        fregfile_27_sign = 1'h0;
        fregfile_28_mantissa = 23'h0;
        fregfile_28_exponent = 8'h0;
        fregfile_28_sign = 1'h0;
        fregfile_29_mantissa = 23'h0;
        fregfile_29_exponent = 8'h0;
        fregfile_29_sign = 1'h0;
        fregfile_30_mantissa = 23'h0;
        fregfile_30_exponent = 8'h0;
        fregfile_30_sign = 1'h0;
        fregfile_31_mantissa = 23'h0;
        fregfile_31_exponent = 8'h0;
        fregfile_31_sign = 1'h0;
        scoreboard = 32'h0;
        scoreboard_error = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_read_ports_0_data_mantissa =
    io_read_ports_0_valid ? _GEN[io_read_ports_0_addr] : 23'h0;
  assign io_read_ports_0_data_exponent =
    io_read_ports_0_valid ? _GEN_0[io_read_ports_0_addr] : 8'h0;
  assign io_read_ports_0_data_sign = io_read_ports_0_valid & _GEN_1[io_read_ports_0_addr];
  assign io_read_ports_1_data_mantissa =
    io_read_ports_1_valid ? _GEN[io_read_ports_1_addr] : 23'h0;
  assign io_read_ports_1_data_exponent =
    io_read_ports_1_valid ? _GEN_0[io_read_ports_1_addr] : 8'h0;
  assign io_read_ports_1_data_sign = io_read_ports_1_valid & _GEN_1[io_read_ports_1_addr];
  assign io_read_ports_2_data_mantissa =
    io_read_ports_2_valid ? _GEN[io_read_ports_2_addr] : 23'h0;
  assign io_read_ports_2_data_exponent =
    io_read_ports_2_valid ? _GEN_0[io_read_ports_2_addr] : 8'h0;
  assign io_read_ports_2_data_sign = io_read_ports_2_valid & _GEN_1[io_read_ports_2_addr];
  assign io_scoreboard = scoreboard;
  assign io_busPort_data_0 =
    {_GEN_1[io_busPortAddr], _GEN_0[io_busPortAddr], _GEN[io_busPortAddr]};
endmodule

module Arbiter3_RegfileWriteDataIO(
  input         io_in_0_valid,
  input  [4:0]  io_in_0_bits_addr,
  input  [31:0] io_in_0_bits_data,
  output        io_in_1_ready,
  input         io_in_1_valid,
  input  [4:0]  io_in_1_bits_addr,
  input  [31:0] io_in_1_bits_data,
  output        io_in_2_ready,
  input         io_in_2_valid,
  input  [4:0]  io_in_2_bits_addr,
  input  [31:0] io_in_2_bits_data,
  output        io_out_valid,
  output [4:0]  io_out_bits_addr,
  output [31:0] io_out_bits_data
);

  wire _io_out_valid_T = io_in_0_valid | io_in_1_valid;
  assign io_in_1_ready = ~io_in_0_valid;
  assign io_in_2_ready = ~_io_out_valid_T;
  assign io_out_valid = _io_out_valid_T | io_in_2_valid;
  assign io_out_bits_addr =
    io_in_0_valid
      ? io_in_0_bits_addr
      : io_in_1_valid ? io_in_1_bits_addr : io_in_2_bits_addr;
  assign io_out_bits_data =
    io_in_0_valid
      ? io_in_0_bits_data
      : io_in_1_valid ? io_in_1_bits_data : io_in_2_bits_data;
endmodule

module SCore(
  input          clock,
                 reset,
  input  [31:0]  io_csr_in_value_0,
  output [31:0]  io_csr_out_value_0,
                 io_csr_out_value_1,
                 io_csr_out_value_2,
                 io_csr_out_value_3,
                 io_csr_out_value_4,
                 io_csr_out_value_5,
                 io_csr_out_value_6,
                 io_csr_out_value_7,
                 io_csr_out_value_8,
  output         io_halted,
                 io_fault,
                 io_wfi,
  input          io_irq,
  output         io_ibus_valid,
  output [31:0]  io_ibus_addr,
  input  [127:0] io_ibus_rdata,
  input          io_ibus_fault_valid,
  input  [31:0]  io_ibus_fault_bits_epc,
  output         io_dbus_valid,
                 io_dbus_write,
  output [31:0]  io_dbus_addr,
  output [127:0] io_dbus_wdata,
  output [15:0]  io_dbus_wmask,
  input  [127:0] io_dbus_rdata,
  output         io_ebus_dbus_valid,
  input          io_ebus_dbus_ready,
  output         io_ebus_dbus_write,
  output [31:0]  io_ebus_dbus_pc,
                 io_ebus_dbus_addr,
  output [4:0]   io_ebus_dbus_size,
  output [127:0] io_ebus_dbus_wdata,
  output [15:0]  io_ebus_dbus_wmask,
  input  [127:0] io_ebus_dbus_rdata,
  input          io_ebus_fault_valid,
                 io_ebus_fault_bits_write,
  input  [31:0]  io_ebus_fault_bits_addr,
                 io_ebus_fault_bits_epc,
  output         io_slog_valid,
  output [4:0]   io_slog_addr,
  output [31:0]  io_slog_data,
  output [3:0]   io_debug_en,
  output [31:0]  io_debug_addr_0,
                 io_debug_addr_1,
                 io_debug_inst_0,
                 io_debug_inst_1,
                 io_debug_cycles,
  output         io_debug_dbus_valid,
  output [31:0]  io_debug_dbus_bits_addr,
  output [127:0] io_debug_dbus_bits_wdata,
  output         io_debug_dbus_bits_write,
                 io_debug_dispatch_0_instFire,
  output [31:0]  io_debug_dispatch_0_instAddr,
                 io_debug_dispatch_0_instInst,
  output         io_debug_dispatch_1_instFire,
  output [31:0]  io_debug_dispatch_1_instAddr,
                 io_debug_dispatch_1_instInst,
  output         io_debug_regfile_writeAddr_0_valid,
  output [4:0]   io_debug_regfile_writeAddr_0_bits,
  output         io_debug_regfile_writeAddr_1_valid,
  output [4:0]   io_debug_regfile_writeAddr_1_bits,
  output         io_debug_regfile_writeData_0_valid,
  output [4:0]   io_debug_regfile_writeData_0_bits_addr,
  output [31:0]  io_debug_regfile_writeData_0_bits_data,
  output         io_debug_regfile_writeData_1_valid,
  output [4:0]   io_debug_regfile_writeData_1_bits_addr,
  output [31:0]  io_debug_regfile_writeData_1_bits_data,
  output         io_debug_regfile_writeData_2_valid,
  output [4:0]   io_debug_regfile_writeData_2_bits_addr,
  output [31:0]  io_debug_regfile_writeData_2_bits_data,
  output         io_debug_regfile_writeData_3_valid,
  output [4:0]   io_debug_regfile_writeData_3_bits_addr,
  output [31:0]  io_debug_regfile_writeData_3_bits_data,
  output         io_debug_float_writeAddr_valid,
  output [4:0]   io_debug_float_writeAddr_bits,
  output         io_debug_float_writeData_0_valid,
  output [31:0]  io_debug_float_writeData_0_bits_addr,
                 io_debug_float_writeData_0_bits_data,
  output         io_debug_float_writeData_1_valid,
  output [31:0]  io_debug_float_writeData_1_bits_addr,
                 io_debug_float_writeData_1_bits_data
);

  wire         _arb_io_in_1_ready;
  wire         _arb_io_in_2_ready;
  wire         _arb_io_out_valid;
  wire [4:0]   _arb_io_out_bits_addr;
  wire [31:0]  _arb_io_out_bits_data;
  wire [22:0]  _fRegfile_io_read_ports_0_data_mantissa;
  wire [7:0]   _fRegfile_io_read_ports_0_data_exponent;
  wire         _fRegfile_io_read_ports_0_data_sign;
  wire [22:0]  _fRegfile_io_read_ports_1_data_mantissa;
  wire [7:0]   _fRegfile_io_read_ports_1_data_exponent;
  wire         _fRegfile_io_read_ports_1_data_sign;
  wire [22:0]  _fRegfile_io_read_ports_2_data_mantissa;
  wire [7:0]   _fRegfile_io_read_ports_2_data_exponent;
  wire         _fRegfile_io_read_ports_2_data_sign;
  wire [31:0]  _fRegfile_io_scoreboard;
  wire [31:0]  _fRegfile_io_busPort_data_0;
  wire         _floatCore_io_inst_ready;
  wire         _floatCore_io_read_ports_0_valid;
  wire [4:0]   _floatCore_io_read_ports_0_addr;
  wire         _floatCore_io_read_ports_1_valid;
  wire [4:0]   _floatCore_io_read_ports_1_addr;
  wire         _floatCore_io_read_ports_2_valid;
  wire [4:0]   _floatCore_io_read_ports_2_addr;
  wire         _floatCore_io_write_ports_0_valid;
  wire [4:0]   _floatCore_io_write_ports_0_addr;
  wire [22:0]  _floatCore_io_write_ports_0_data_mantissa;
  wire [7:0]   _floatCore_io_write_ports_0_data_exponent;
  wire         _floatCore_io_write_ports_0_data_sign;
  wire         _floatCore_io_write_ports_1_valid;
  wire [4:0]   _floatCore_io_write_ports_1_addr;
  wire [22:0]  _floatCore_io_write_ports_1_data_mantissa;
  wire [7:0]   _floatCore_io_write_ports_1_data_exponent;
  wire         _floatCore_io_write_ports_1_data_sign;
  wire         _floatCore_io_scalar_rd_valid;
  wire [4:0]   _floatCore_io_scalar_rd_bits_addr;
  wire [31:0]  _floatCore_io_scalar_rd_bits_data;
  wire         _floatCore_io_csr_in_fflags_valid;
  wire [4:0]   _floatCore_io_csr_in_fflags_bits;
  wire         _fault_manager_io_out_valid;
  wire [31:0]  _fault_manager_io_out_bits_mepc;
  wire [31:0]  _fault_manager_io_out_bits_mtval;
  wire [31:0]  _fault_manager_io_out_bits_mcause;
  wire         _dvu_io_req_ready;
  wire         _dvu_io_rd_valid;
  wire [4:0]   _dvu_io_rd_bits_addr;
  wire [31:0]  _dvu_io_rd_bits_data;
  wire         _mlu_io_req_1_ready;
  wire         _mlu_io_rd_valid;
  wire [4:0]   _mlu_io_rd_bits_addr;
  wire [31:0]  _mlu_io_rd_bits_data;
  wire         _lsu_io_req_0_ready;
  wire         _lsu_io_req_1_ready;
  wire         _lsu_io_rd_valid;
  wire [4:0]   _lsu_io_rd_bits_addr;
  wire [31:0]  _lsu_io_rd_bits_data;
  wire         _lsu_io_rd_flt_valid;
  wire [4:0]   _lsu_io_rd_flt_bits_addr;
  wire [31:0]  _lsu_io_rd_flt_bits_data;
  wire         _lsu_io_ibus_valid;
  wire [31:0]  _lsu_io_ibus_addr;
  wire         _lsu_io_dbus_valid;
  wire         _lsu_io_dbus_write;
  wire [31:0]  _lsu_io_dbus_addr;
  wire [127:0] _lsu_io_dbus_wdata;
  wire         _lsu_io_flush_valid;
  wire         _lsu_io_flush_fencei;
  wire [31:0]  _lsu_io_flush_pcNext;
  wire         _lsu_io_fault_valid;
  wire         _lsu_io_fault_bits_write;
  wire [31:0]  _lsu_io_fault_bits_addr;
  wire [31:0]  _lsu_io_fault_bits_epc;
  wire [2:0]   _lsu_io_queueCapacity;
  wire         _lsu_io_active;
  wire         _bru_1_io_rd_valid;
  wire [4:0]   _bru_1_io_rd_bits_addr;
  wire [31:0]  _bru_1_io_rd_bits_data;
  wire         _bru_1_io_taken_valid;
  wire [31:0]  _bru_1_io_taken_value;
  wire         _bru_0_io_csr_in_mode_valid;
  wire [1:0]   _bru_0_io_csr_in_mode_bits;
  wire         _bru_0_io_csr_in_mcause_valid;
  wire [31:0]  _bru_0_io_csr_in_mcause_bits;
  wire         _bru_0_io_csr_in_mepc_valid;
  wire [31:0]  _bru_0_io_csr_in_mepc_bits;
  wire         _bru_0_io_csr_in_mtval_valid;
  wire [31:0]  _bru_0_io_csr_in_mtval_bits;
  wire         _bru_0_io_csr_in_halt;
  wire         _bru_0_io_csr_in_fault;
  wire         _bru_0_io_csr_in_wfi;
  wire         _bru_0_io_rd_valid;
  wire [4:0]   _bru_0_io_rd_bits_addr;
  wire [31:0]  _bru_0_io_rd_bits_data;
  wire         _bru_0_io_taken_valid;
  wire [31:0]  _bru_0_io_taken_value;
  wire         _bru_0_io_interlock;
  wire         _alu_1_io_rd_valid;
  wire [4:0]   _alu_1_io_rd_bits_addr;
  wire [31:0]  _alu_1_io_rd_bits_data;
  wire         _alu_0_io_rd_valid;
  wire [4:0]   _alu_0_io_rd_bits_addr;
  wire [31:0]  _alu_0_io_rd_bits_data;
  wire         _dispatch_io_csrFault_0;
  wire         _dispatch_io_jalFault_0;
  wire         _dispatch_io_jalFault_1;
  wire         _dispatch_io_jalrFault_0;
  wire         _dispatch_io_jalrFault_1;
  wire         _dispatch_io_bxxFault_0;
  wire         _dispatch_io_bxxFault_1;
  wire         _dispatch_io_undefFault_0;
  wire [31:0]  _dispatch_io_bruTarget_0;
  wire [31:0]  _dispatch_io_bruTarget_1;
  wire         _dispatch_io_inst_0_ready;
  wire         _dispatch_io_inst_1_ready;
  wire         _dispatch_io_rs1Read_0_valid;
  wire [4:0]   _dispatch_io_rs1Read_0_addr;
  wire         _dispatch_io_rs1Read_1_valid;
  wire [4:0]   _dispatch_io_rs1Read_1_addr;
  wire         _dispatch_io_rs1Set_0_valid;
  wire [31:0]  _dispatch_io_rs1Set_0_value;
  wire         _dispatch_io_rs1Set_1_valid;
  wire [31:0]  _dispatch_io_rs1Set_1_value;
  wire         _dispatch_io_rs2Read_0_valid;
  wire [4:0]   _dispatch_io_rs2Read_0_addr;
  wire         _dispatch_io_rs2Read_1_valid;
  wire [4:0]   _dispatch_io_rs2Read_1_addr;
  wire         _dispatch_io_rs2Set_0_valid;
  wire [31:0]  _dispatch_io_rs2Set_0_value;
  wire         _dispatch_io_rs2Set_1_valid;
  wire [31:0]  _dispatch_io_rs2Set_1_value;
  wire         _dispatch_io_rdMark_0_valid;
  wire [4:0]   _dispatch_io_rdMark_0_addr;
  wire         _dispatch_io_rdMark_1_valid;
  wire [4:0]   _dispatch_io_rdMark_1_addr;
  wire         _dispatch_io_busRead_0_bypass;
  wire         _dispatch_io_busRead_0_immen;
  wire [31:0]  _dispatch_io_busRead_0_immed;
  wire         _dispatch_io_busRead_1_bypass;
  wire [31:0]  _dispatch_io_busRead_1_immed;
  wire         _dispatch_io_rdMark_flt_valid;
  wire [4:0]   _dispatch_io_rdMark_flt_addr;
  wire         _dispatch_io_alu_0_valid;
  wire [4:0]   _dispatch_io_alu_0_bits_addr;
  wire [4:0]   _dispatch_io_alu_0_bits_op;
  wire         _dispatch_io_alu_1_valid;
  wire [4:0]   _dispatch_io_alu_1_bits_addr;
  wire [4:0]   _dispatch_io_alu_1_bits_op;
  wire         _dispatch_io_bru_0_valid;
  wire         _dispatch_io_bru_0_bits_fwd;
  wire [3:0]   _dispatch_io_bru_0_bits_op;
  wire [31:0]  _dispatch_io_bru_0_bits_pc;
  wire [31:0]  _dispatch_io_bru_0_bits_target;
  wire [4:0]   _dispatch_io_bru_0_bits_link;
  wire         _dispatch_io_bru_1_valid;
  wire         _dispatch_io_bru_1_bits_fwd;
  wire [3:0]   _dispatch_io_bru_1_bits_op;
  wire [31:0]  _dispatch_io_bru_1_bits_pc;
  wire [31:0]  _dispatch_io_bru_1_bits_target;
  wire [4:0]   _dispatch_io_bru_1_bits_link;
  wire         _dispatch_io_csr_valid;
  wire [4:0]   _dispatch_io_csr_bits_addr;
  wire [11:0]  _dispatch_io_csr_bits_index;
  wire [1:0]   _dispatch_io_csr_bits_op;
  wire         _dispatch_io_lsu_0_valid;
  wire         _dispatch_io_lsu_0_bits_store;
  wire [4:0]   _dispatch_io_lsu_0_bits_addr;
  wire [4:0]   _dispatch_io_lsu_0_bits_op;
  wire [31:0]  _dispatch_io_lsu_0_bits_pc;
  wire         _dispatch_io_lsu_1_valid;
  wire         _dispatch_io_lsu_1_bits_store;
  wire [4:0]   _dispatch_io_lsu_1_bits_addr;
  wire [4:0]   _dispatch_io_lsu_1_bits_op;
  wire [31:0]  _dispatch_io_lsu_1_bits_pc;
  wire         _dispatch_io_mlu_0_valid;
  wire [4:0]   _dispatch_io_mlu_0_bits_addr;
  wire [2:0]   _dispatch_io_mlu_0_bits_op;
  wire         _dispatch_io_mlu_1_valid;
  wire [4:0]   _dispatch_io_mlu_1_bits_addr;
  wire [2:0]   _dispatch_io_mlu_1_bits_op;
  wire         _dispatch_io_dvu_0_valid;
  wire [4:0]   _dispatch_io_dvu_0_bits_addr;
  wire [1:0]   _dispatch_io_dvu_0_bits_op;
  wire         _dispatch_io_float_valid;
  wire [2:0]   _dispatch_io_float_bits_opcode;
  wire [4:0]   _dispatch_io_float_bits_funct5;
  wire [4:0]   _dispatch_io_float_bits_rs3;
  wire [4:0]   _dispatch_io_float_bits_rs2;
  wire [4:0]   _dispatch_io_float_bits_rs1;
  wire [2:0]   _dispatch_io_float_bits_rm;
  wire [31:0]  _dispatch_io_float_bits_inst;
  wire [31:0]  _dispatch_io_float_bits_pc;
  wire         _dispatch_io_float_bits_scalar_rd;
  wire         _dispatch_io_float_bits_scalar_rs1;
  wire [4:0]   _dispatch_io_float_bits_rd;
  wire         _dispatch_io_float_bits_uses_rs3;
  wire         _dispatch_io_float_bits_uses_rs2;
  wire [4:0]   _dispatch_io_fbusPortAddr;
  wire         _dispatch_io_slog;
  wire [31:0]  _csr_io_csr_out_value_4;
  wire         _csr_io_rd_valid;
  wire [4:0]   _csr_io_rd_bits_addr;
  wire [31:0]  _csr_io_rd_bits_data;
  wire [1:0]   _csr_io_bru_out_mode;
  wire [31:0]  _csr_io_bru_out_mepc;
  wire [31:0]  _csr_io_bru_out_mtvec;
  wire [2:0]   _csr_io_float_out_frm;
  wire         _csr_io_halted;
  wire         _csr_io_wfi;
  wire         _fetch_io_ibus_valid;
  wire [31:0]  _fetch_io_ibus_addr;
  wire         _fetch_io_inst_lanes_0_valid;
  wire [31:0]  _fetch_io_inst_lanes_0_bits_addr;
  wire [31:0]  _fetch_io_inst_lanes_0_bits_inst;
  wire         _fetch_io_inst_lanes_0_bits_brchFwd;
  wire         _fetch_io_inst_lanes_1_valid;
  wire [31:0]  _fetch_io_inst_lanes_1_bits_addr;
  wire [31:0]  _fetch_io_inst_lanes_1_bits_inst;
  wire         _fetch_io_inst_lanes_1_bits_brchFwd;
  wire [31:0]  _fetch_io_pc;
  wire         _fetch_io_fault;
  wire [31:0]  _regfile_io_target_0_data;
  wire [31:0]  _regfile_io_target_1_data;
  wire [31:0]  _regfile_io_busPort_addr_0;
  wire [31:0]  _regfile_io_busPort_addr_1;
  wire [31:0]  _regfile_io_busPort_data_0;
  wire [31:0]  _regfile_io_busPort_data_1;
  wire         _regfile_io_readData_0_valid;
  wire [31:0]  _regfile_io_readData_0_data;
  wire         _regfile_io_readData_1_valid;
  wire [31:0]  _regfile_io_readData_1_data;
  wire         _regfile_io_readData_2_valid;
  wire [31:0]  _regfile_io_readData_2_data;
  wire         _regfile_io_readData_3_valid;
  wire [31:0]  _regfile_io_readData_3_data;
  wire [31:0]  _regfile_io_scoreboard_regd;
  wire [31:0]  _regfile_io_scoreboard_comb;
  wire [5:0]   _regfile_io_rfwriteCount;
  wire         branchTaken = _bru_0_io_taken_valid | _bru_1_io_taken_valid;
  wire         regfile_io_writeData_0_valid =
    _csr_io_rd_valid | _alu_0_io_rd_valid | _bru_0_io_rd_valid;
  wire [4:0]   regfile_io_writeData_0_bits_addr =
    (_csr_io_rd_valid ? _csr_io_rd_bits_addr : 5'h0)
    | (_alu_0_io_rd_valid ? _alu_0_io_rd_bits_addr : 5'h0)
    | (_bru_0_io_rd_valid ? _bru_0_io_rd_bits_addr : 5'h0);
  wire [31:0]  regfile_io_writeData_0_bits_data =
    (_csr_io_rd_valid ? _csr_io_rd_bits_data : 32'h0)
    | (_alu_0_io_rd_valid ? _alu_0_io_rd_bits_data : 32'h0)
    | (_bru_0_io_rd_valid ? _bru_0_io_rd_bits_data : 32'h0);
  wire         regfile_io_writeData_1_valid = _alu_1_io_rd_valid | _bru_1_io_rd_valid;
  wire [4:0]   regfile_io_writeData_1_bits_addr =
    (_alu_1_io_rd_valid ? _alu_1_io_rd_bits_addr : 5'h0)
    | (_bru_1_io_rd_valid ? _bru_1_io_rd_bits_addr : 5'h0);
  wire [31:0]  regfile_io_writeData_1_bits_data =
    (_alu_1_io_rd_valid ? _alu_1_io_rd_bits_data : 32'h0)
    | (_bru_1_io_rd_valid ? _bru_1_io_rd_bits_data : 32'h0);
  reg          slogValid;
  reg  [1:0]   slogAddr;
  reg  [1:0]   debugEn;
  reg  [31:0]  debugAddr_0;
  reg  [31:0]  debugAddr_1;
  reg  [31:0]  debugInst_0;
  reg  [31:0]  debugInst_1;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      slogValid <= 1'h0;
      slogAddr <= 2'h0;
      debugEn <= 2'h0;
      debugAddr_0 <= 32'h0;
      debugAddr_1 <= 32'h0;
      debugInst_0 <= 32'h0;
      debugInst_1 <= 32'h0;
    end
    else begin
      slogValid <= _dispatch_io_slog;
      if (_dispatch_io_slog)
        slogAddr <= _fetch_io_inst_lanes_0_bits_inst[13:12];
      debugEn <=
        {_fetch_io_inst_lanes_0_valid & _dispatch_io_inst_0_ready & ~branchTaken,
         _fetch_io_inst_lanes_1_valid & _dispatch_io_inst_1_ready & ~branchTaken};
      if (debugEn[0]) begin
        debugAddr_0 <= _fetch_io_inst_lanes_0_bits_addr;
        debugInst_0 <= _fetch_io_inst_lanes_0_bits_inst;
      end
      if (debugEn[1]) begin
        debugAddr_1 <= _fetch_io_inst_lanes_1_bits_addr;
        debugInst_1 <= _fetch_io_inst_lanes_1_bits_inst;
      end
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:4];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h5; i += 3'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        slogValid = _RANDOM[3'h0][0];
        slogAddr = _RANDOM[3'h0][2:1];
        debugEn = _RANDOM[3'h0][4:3];
        debugAddr_0 = {_RANDOM[3'h0][31:5], _RANDOM[3'h1][4:0]};
        debugAddr_1 = {_RANDOM[3'h1][31:5], _RANDOM[3'h2][4:0]};
        debugInst_0 = {_RANDOM[3'h2][31:5], _RANDOM[3'h3][4:0]};
        debugInst_1 = {_RANDOM[3'h3][31:5], _RANDOM[3'h4][4:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        slogValid = 1'h0;
        slogAddr = 2'h0;
        debugEn = 2'h0;
        debugAddr_0 = 32'h0;
        debugAddr_1 = 32'h0;
        debugInst_0 = 32'h0;
        debugInst_1 = 32'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Regfile regfile (
    .clock                    (clock),
    .reset                    (reset),
    .io_readAddr_0_valid      (_dispatch_io_rs1Read_0_valid),
    .io_readAddr_0_addr       (_dispatch_io_rs1Read_0_addr),
    .io_readAddr_1_valid      (_dispatch_io_rs2Read_0_valid),
    .io_readAddr_1_addr       (_dispatch_io_rs2Read_0_addr),
    .io_readAddr_2_valid      (_dispatch_io_rs1Read_1_valid),
    .io_readAddr_2_addr       (_dispatch_io_rs1Read_1_addr),
    .io_readAddr_3_valid      (_dispatch_io_rs2Read_1_valid),
    .io_readAddr_3_addr       (_dispatch_io_rs2Read_1_addr),
    .io_readSet_0_valid       (_dispatch_io_rs1Set_0_valid),
    .io_readSet_0_value       (_dispatch_io_rs1Set_0_value),
    .io_readSet_1_valid       (_dispatch_io_rs2Set_0_valid),
    .io_readSet_1_value       (_dispatch_io_rs2Set_0_value),
    .io_readSet_2_valid       (_dispatch_io_rs1Set_1_valid),
    .io_readSet_2_value       (_dispatch_io_rs1Set_1_value),
    .io_readSet_3_valid       (_dispatch_io_rs2Set_1_valid),
    .io_readSet_3_value       (_dispatch_io_rs2Set_1_value),
    .io_writeAddr_0_valid     (_dispatch_io_rdMark_0_valid),
    .io_writeAddr_0_addr      (_dispatch_io_rdMark_0_addr),
    .io_writeAddr_1_valid     (_dispatch_io_rdMark_1_valid),
    .io_writeAddr_1_addr      (_dispatch_io_rdMark_1_addr),
    .io_busAddr_0_bypass      (_dispatch_io_busRead_0_bypass),
    .io_busAddr_0_immen       (_dispatch_io_busRead_0_immen),
    .io_busAddr_0_immed       (_dispatch_io_busRead_0_immed),
    .io_busAddr_1_bypass      (_dispatch_io_busRead_1_bypass),
    .io_busAddr_1_immed       (_dispatch_io_busRead_1_immed),
    .io_target_0_data         (_regfile_io_target_0_data),
    .io_target_1_data         (_regfile_io_target_1_data),
    .io_busPort_addr_0        (_regfile_io_busPort_addr_0),
    .io_busPort_addr_1        (_regfile_io_busPort_addr_1),
    .io_busPort_data_0        (_regfile_io_busPort_data_0),
    .io_busPort_data_1        (_regfile_io_busPort_data_1),
    .io_readData_0_valid      (_regfile_io_readData_0_valid),
    .io_readData_0_data       (_regfile_io_readData_0_data),
    .io_readData_1_valid      (_regfile_io_readData_1_valid),
    .io_readData_1_data       (_regfile_io_readData_1_data),
    .io_readData_2_valid      (_regfile_io_readData_2_valid),
    .io_readData_2_data       (_regfile_io_readData_2_data),
    .io_readData_3_valid      (_regfile_io_readData_3_valid),
    .io_readData_3_data       (_regfile_io_readData_3_data),
    .io_writeData_0_valid     (regfile_io_writeData_0_valid),
    .io_writeData_0_bits_addr (regfile_io_writeData_0_bits_addr),
    .io_writeData_0_bits_data (regfile_io_writeData_0_bits_data),
    .io_writeData_1_valid     (regfile_io_writeData_1_valid),
    .io_writeData_1_bits_addr (regfile_io_writeData_1_bits_addr),
    .io_writeData_1_bits_data (regfile_io_writeData_1_bits_data),
    .io_writeData_2_valid     (_arb_io_out_valid),
    .io_writeData_2_bits_addr (_arb_io_out_bits_addr),
    .io_writeData_2_bits_data (_arb_io_out_bits_data),
    .io_writeData_3_valid     (_lsu_io_rd_valid),
    .io_writeData_3_bits_addr (_lsu_io_rd_bits_addr),
    .io_writeData_3_bits_data (_lsu_io_rd_bits_data),
    .io_writeMask_1_valid     (_bru_0_io_taken_valid),
    .io_writeMask_3_valid     (_lsu_io_fault_valid),
    .io_scoreboard_regd       (_regfile_io_scoreboard_regd),
    .io_scoreboard_comb       (_regfile_io_scoreboard_comb),
    .io_rfwriteCount          (_regfile_io_rfwriteCount)
  );
  UncachedFetch fetch (
    .clock                        (clock),
    .reset                        (reset),
    .io_csr_value_0               (io_csr_in_value_0),
    .io_ibus_valid                (_fetch_io_ibus_valid),
    .io_ibus_ready                (~_lsu_io_ibus_valid),
    .io_ibus_addr                 (_fetch_io_ibus_addr),
    .io_ibus_rdata                (io_ibus_rdata),
    .io_ibus_fault_valid          (~_lsu_io_ibus_valid & io_ibus_fault_valid),
    .io_inst_lanes_0_ready        (_dispatch_io_inst_0_ready),
    .io_inst_lanes_0_valid        (_fetch_io_inst_lanes_0_valid),
    .io_inst_lanes_0_bits_addr    (_fetch_io_inst_lanes_0_bits_addr),
    .io_inst_lanes_0_bits_inst    (_fetch_io_inst_lanes_0_bits_inst),
    .io_inst_lanes_0_bits_brchFwd (_fetch_io_inst_lanes_0_bits_brchFwd),
    .io_inst_lanes_1_ready        (_dispatch_io_inst_1_ready),
    .io_inst_lanes_1_valid        (_fetch_io_inst_lanes_1_valid),
    .io_inst_lanes_1_bits_addr    (_fetch_io_inst_lanes_1_bits_addr),
    .io_inst_lanes_1_bits_inst    (_fetch_io_inst_lanes_1_bits_inst),
    .io_inst_lanes_1_bits_brchFwd (_fetch_io_inst_lanes_1_bits_brchFwd),
    .io_branch_0_valid            (_bru_0_io_taken_valid),
    .io_branch_0_value            (_bru_0_io_taken_value),
    .io_branch_1_valid            (_bru_1_io_taken_valid),
    .io_branch_1_value            (_bru_1_io_taken_value),
    .io_iflush_valid              (_lsu_io_flush_valid & _lsu_io_flush_fencei),
    .io_iflush_pcNext             (_lsu_io_flush_pcNext),
    .io_pc                        (_fetch_io_pc),
    .io_fault                     (_fetch_io_fault)
  );
  Csr csr (
    .clock                    (clock),
    .reset                    (reset),
    .io_csr_in_value_12       (_fetch_io_pc),
    .io_csr_out_value_0       (io_csr_out_value_0),
    .io_csr_out_value_1       (io_csr_out_value_1),
    .io_csr_out_value_2       (io_csr_out_value_2),
    .io_csr_out_value_3       (io_csr_out_value_3),
    .io_csr_out_value_4       (_csr_io_csr_out_value_4),
    .io_csr_out_value_5       (io_csr_out_value_5),
    .io_csr_out_value_6       (io_csr_out_value_6),
    .io_csr_out_value_7       (io_csr_out_value_7),
    .io_csr_out_value_8       (io_csr_out_value_8),
    .io_req_valid             (_dispatch_io_csr_valid),
    .io_req_bits_addr         (_dispatch_io_csr_bits_addr),
    .io_req_bits_index        (_dispatch_io_csr_bits_index),
    .io_req_bits_op           (_dispatch_io_csr_bits_op),
    .io_rs1_valid             (_regfile_io_readData_0_valid),
    .io_rs1_data              (_regfile_io_readData_0_data),
    .io_rd_valid              (_csr_io_rd_valid),
    .io_rd_bits_addr          (_csr_io_rd_bits_addr),
    .io_rd_bits_data          (_csr_io_rd_bits_data),
    .io_bru_in_mode_valid     (_bru_0_io_csr_in_mode_valid),
    .io_bru_in_mode_bits      (_bru_0_io_csr_in_mode_bits),
    .io_bru_in_mcause_valid   (_bru_0_io_csr_in_mcause_valid),
    .io_bru_in_mcause_bits    (_bru_0_io_csr_in_mcause_bits),
    .io_bru_in_mepc_valid     (_bru_0_io_csr_in_mepc_valid),
    .io_bru_in_mepc_bits      (_bru_0_io_csr_in_mepc_bits),
    .io_bru_in_mtval_valid    (_bru_0_io_csr_in_mtval_valid),
    .io_bru_in_mtval_bits     (_bru_0_io_csr_in_mtval_bits),
    .io_bru_in_halt           (_bru_0_io_csr_in_halt),
    .io_bru_in_fault          (_bru_0_io_csr_in_fault),
    .io_bru_in_wfi            (_bru_0_io_csr_in_wfi),
    .io_bru_out_mode          (_csr_io_bru_out_mode),
    .io_bru_out_mepc          (_csr_io_bru_out_mepc),
    .io_bru_out_mtvec         (_csr_io_bru_out_mtvec),
    .io_float_in_fflags_valid (_floatCore_io_csr_in_fflags_valid),
    .io_float_in_fflags_bits  (_floatCore_io_csr_in_fflags_bits),
    .io_float_out_frm         (_csr_io_float_out_frm),
    .io_counters_rfwriteCount (_regfile_io_rfwriteCount[2:0]),
    .io_counters_branchCount  (_bru_0_io_taken_valid),
    .io_halted                (_csr_io_halted),
    .io_fault                 (io_fault),
    .io_wfi                   (_csr_io_wfi),
    .io_irq                   (io_irq)
  );
  DispatchV2 dispatch (
    .io_halted                (_csr_io_halted | _csr_io_wfi),
    .io_lsuActive             (_lsu_io_active),
    .io_scoreboard_regd       (_regfile_io_scoreboard_regd),
    .io_scoreboard_comb       (_regfile_io_scoreboard_comb),
    .io_fscoreboard           (_fRegfile_io_scoreboard),
    .io_branchTaken           (branchTaken),
    .io_csrFault_0            (_dispatch_io_csrFault_0),
    .io_jalFault_0            (_dispatch_io_jalFault_0),
    .io_jalFault_1            (_dispatch_io_jalFault_1),
    .io_jalrFault_0           (_dispatch_io_jalrFault_0),
    .io_jalrFault_1           (_dispatch_io_jalrFault_1),
    .io_bxxFault_0            (_dispatch_io_bxxFault_0),
    .io_bxxFault_1            (_dispatch_io_bxxFault_1),
    .io_undefFault_0          (_dispatch_io_undefFault_0),
    .io_bruTarget_0           (_dispatch_io_bruTarget_0),
    .io_bruTarget_1           (_dispatch_io_bruTarget_1),
    .io_jalrTarget_0_data     (_regfile_io_target_0_data),
    .io_jalrTarget_1_data     (_regfile_io_target_1_data),
    .io_interlock             (_bru_0_io_interlock | _lsu_io_flush_valid),
    .io_inst_0_ready          (_dispatch_io_inst_0_ready),
    .io_inst_0_valid          (_fetch_io_inst_lanes_0_valid),
    .io_inst_0_bits_addr      (_fetch_io_inst_lanes_0_bits_addr),
    .io_inst_0_bits_inst      (_fetch_io_inst_lanes_0_bits_inst),
    .io_inst_0_bits_brchFwd   (_fetch_io_inst_lanes_0_bits_brchFwd),
    .io_inst_1_ready          (_dispatch_io_inst_1_ready),
    .io_inst_1_valid          (_fetch_io_inst_lanes_1_valid),
    .io_inst_1_bits_addr      (_fetch_io_inst_lanes_1_bits_addr),
    .io_inst_1_bits_inst      (_fetch_io_inst_lanes_1_bits_inst),
    .io_inst_1_bits_brchFwd   (_fetch_io_inst_lanes_1_bits_brchFwd),
    .io_rs1Read_0_valid       (_dispatch_io_rs1Read_0_valid),
    .io_rs1Read_0_addr        (_dispatch_io_rs1Read_0_addr),
    .io_rs1Read_1_valid       (_dispatch_io_rs1Read_1_valid),
    .io_rs1Read_1_addr        (_dispatch_io_rs1Read_1_addr),
    .io_rs1Set_0_valid        (_dispatch_io_rs1Set_0_valid),
    .io_rs1Set_0_value        (_dispatch_io_rs1Set_0_value),
    .io_rs1Set_1_valid        (_dispatch_io_rs1Set_1_valid),
    .io_rs1Set_1_value        (_dispatch_io_rs1Set_1_value),
    .io_rs2Read_0_valid       (_dispatch_io_rs2Read_0_valid),
    .io_rs2Read_0_addr        (_dispatch_io_rs2Read_0_addr),
    .io_rs2Read_1_valid       (_dispatch_io_rs2Read_1_valid),
    .io_rs2Read_1_addr        (_dispatch_io_rs2Read_1_addr),
    .io_rs2Set_0_valid        (_dispatch_io_rs2Set_0_valid),
    .io_rs2Set_0_value        (_dispatch_io_rs2Set_0_value),
    .io_rs2Set_1_valid        (_dispatch_io_rs2Set_1_valid),
    .io_rs2Set_1_value        (_dispatch_io_rs2Set_1_value),
    .io_rdMark_0_valid        (_dispatch_io_rdMark_0_valid),
    .io_rdMark_0_addr         (_dispatch_io_rdMark_0_addr),
    .io_rdMark_1_valid        (_dispatch_io_rdMark_1_valid),
    .io_rdMark_1_addr         (_dispatch_io_rdMark_1_addr),
    .io_busRead_0_bypass      (_dispatch_io_busRead_0_bypass),
    .io_busRead_0_immen       (_dispatch_io_busRead_0_immen),
    .io_busRead_0_immed       (_dispatch_io_busRead_0_immed),
    .io_busRead_1_bypass      (_dispatch_io_busRead_1_bypass),
    .io_busRead_1_immed       (_dispatch_io_busRead_1_immed),
    .io_rdMark_flt_valid      (_dispatch_io_rdMark_flt_valid),
    .io_rdMark_flt_addr       (_dispatch_io_rdMark_flt_addr),
    .io_alu_0_valid           (_dispatch_io_alu_0_valid),
    .io_alu_0_bits_addr       (_dispatch_io_alu_0_bits_addr),
    .io_alu_0_bits_op         (_dispatch_io_alu_0_bits_op),
    .io_alu_1_valid           (_dispatch_io_alu_1_valid),
    .io_alu_1_bits_addr       (_dispatch_io_alu_1_bits_addr),
    .io_alu_1_bits_op         (_dispatch_io_alu_1_bits_op),
    .io_bru_0_valid           (_dispatch_io_bru_0_valid),
    .io_bru_0_bits_fwd        (_dispatch_io_bru_0_bits_fwd),
    .io_bru_0_bits_op         (_dispatch_io_bru_0_bits_op),
    .io_bru_0_bits_pc         (_dispatch_io_bru_0_bits_pc),
    .io_bru_0_bits_target     (_dispatch_io_bru_0_bits_target),
    .io_bru_0_bits_link       (_dispatch_io_bru_0_bits_link),
    .io_bru_1_valid           (_dispatch_io_bru_1_valid),
    .io_bru_1_bits_fwd        (_dispatch_io_bru_1_bits_fwd),
    .io_bru_1_bits_op         (_dispatch_io_bru_1_bits_op),
    .io_bru_1_bits_pc         (_dispatch_io_bru_1_bits_pc),
    .io_bru_1_bits_target     (_dispatch_io_bru_1_bits_target),
    .io_bru_1_bits_link       (_dispatch_io_bru_1_bits_link),
    .io_csr_valid             (_dispatch_io_csr_valid),
    .io_csr_bits_addr         (_dispatch_io_csr_bits_addr),
    .io_csr_bits_index        (_dispatch_io_csr_bits_index),
    .io_csr_bits_op           (_dispatch_io_csr_bits_op),
    .io_lsu_0_ready           (_lsu_io_req_0_ready),
    .io_lsu_0_valid           (_dispatch_io_lsu_0_valid),
    .io_lsu_0_bits_store      (_dispatch_io_lsu_0_bits_store),
    .io_lsu_0_bits_addr       (_dispatch_io_lsu_0_bits_addr),
    .io_lsu_0_bits_op         (_dispatch_io_lsu_0_bits_op),
    .io_lsu_0_bits_pc         (_dispatch_io_lsu_0_bits_pc),
    .io_lsu_1_ready           (_lsu_io_req_1_ready),
    .io_lsu_1_valid           (_dispatch_io_lsu_1_valid),
    .io_lsu_1_bits_store      (_dispatch_io_lsu_1_bits_store),
    .io_lsu_1_bits_addr       (_dispatch_io_lsu_1_bits_addr),
    .io_lsu_1_bits_op         (_dispatch_io_lsu_1_bits_op),
    .io_lsu_1_bits_pc         (_dispatch_io_lsu_1_bits_pc),
    .io_lsuQueueCapacity      (_lsu_io_queueCapacity),
    .io_mlu_0_valid           (_dispatch_io_mlu_0_valid),
    .io_mlu_0_bits_addr       (_dispatch_io_mlu_0_bits_addr),
    .io_mlu_0_bits_op         (_dispatch_io_mlu_0_bits_op),
    .io_mlu_1_ready           (_mlu_io_req_1_ready),
    .io_mlu_1_valid           (_dispatch_io_mlu_1_valid),
    .io_mlu_1_bits_addr       (_dispatch_io_mlu_1_bits_addr),
    .io_mlu_1_bits_op         (_dispatch_io_mlu_1_bits_op),
    .io_dvu_0_ready           (_dvu_io_req_ready),
    .io_dvu_0_valid           (_dispatch_io_dvu_0_valid),
    .io_dvu_0_bits_addr       (_dispatch_io_dvu_0_bits_addr),
    .io_dvu_0_bits_op         (_dispatch_io_dvu_0_bits_op),
    .io_float_ready           (_floatCore_io_inst_ready),
    .io_float_valid           (_dispatch_io_float_valid),
    .io_float_bits_opcode     (_dispatch_io_float_bits_opcode),
    .io_float_bits_funct5     (_dispatch_io_float_bits_funct5),
    .io_float_bits_rs3        (_dispatch_io_float_bits_rs3),
    .io_float_bits_rs2        (_dispatch_io_float_bits_rs2),
    .io_float_bits_rs1        (_dispatch_io_float_bits_rs1),
    .io_float_bits_rm         (_dispatch_io_float_bits_rm),
    .io_float_bits_inst       (_dispatch_io_float_bits_inst),
    .io_float_bits_pc         (_dispatch_io_float_bits_pc),
    .io_float_bits_scalar_rd  (_dispatch_io_float_bits_scalar_rd),
    .io_float_bits_scalar_rs1 (_dispatch_io_float_bits_scalar_rs1),
    .io_float_bits_rd         (_dispatch_io_float_bits_rd),
    .io_float_bits_uses_rs3   (_dispatch_io_float_bits_uses_rs3),
    .io_float_bits_uses_rs2   (_dispatch_io_float_bits_uses_rs2),
    .io_fbusPortAddr          (_dispatch_io_fbusPortAddr),
    .io_slog                  (_dispatch_io_slog)
  );
  Alu alu_0 (
    .clock            (clock),
    .reset            (reset),
    .io_req_valid     (_dispatch_io_alu_0_valid),
    .io_req_bits_addr (_dispatch_io_alu_0_bits_addr),
    .io_req_bits_op   (_dispatch_io_alu_0_bits_op),
    .io_rs1_valid     (_regfile_io_readData_0_valid),
    .io_rs1_data      (_regfile_io_readData_0_data),
    .io_rs2_valid     (_regfile_io_readData_1_valid),
    .io_rs2_data      (_regfile_io_readData_1_data),
    .io_rd_valid      (_alu_0_io_rd_valid),
    .io_rd_bits_addr  (_alu_0_io_rd_bits_addr),
    .io_rd_bits_data  (_alu_0_io_rd_bits_data)
  );
  Alu alu_1 (
    .clock            (clock),
    .reset            (reset),
    .io_req_valid     (_dispatch_io_alu_1_valid),
    .io_req_bits_addr (_dispatch_io_alu_1_bits_addr),
    .io_req_bits_op   (_dispatch_io_alu_1_bits_op),
    .io_rs1_valid     (_regfile_io_readData_2_valid),
    .io_rs1_data      (_regfile_io_readData_2_data),
    .io_rs2_valid     (_regfile_io_readData_3_valid),
    .io_rs2_data      (_regfile_io_readData_3_data),
    .io_rd_valid      (_alu_1_io_rd_valid),
    .io_rd_bits_addr  (_alu_1_io_rd_bits_addr),
    .io_rd_bits_data  (_alu_1_io_rd_bits_data)
  );
  Bru bru_0 (
    .clock                        (clock),
    .reset                        (reset),
    .io_req_valid                 (_dispatch_io_bru_0_valid),
    .io_req_bits_fwd              (_dispatch_io_bru_0_bits_fwd),
    .io_req_bits_op               (_dispatch_io_bru_0_bits_op),
    .io_req_bits_pc               (_dispatch_io_bru_0_bits_pc),
    .io_req_bits_target           (_dispatch_io_bru_0_bits_target),
    .io_req_bits_link             (_dispatch_io_bru_0_bits_link),
    .io_csr_in_mode_valid         (_bru_0_io_csr_in_mode_valid),
    .io_csr_in_mode_bits          (_bru_0_io_csr_in_mode_bits),
    .io_csr_in_mcause_valid       (_bru_0_io_csr_in_mcause_valid),
    .io_csr_in_mcause_bits        (_bru_0_io_csr_in_mcause_bits),
    .io_csr_in_mepc_valid         (_bru_0_io_csr_in_mepc_valid),
    .io_csr_in_mepc_bits          (_bru_0_io_csr_in_mepc_bits),
    .io_csr_in_mtval_valid        (_bru_0_io_csr_in_mtval_valid),
    .io_csr_in_mtval_bits         (_bru_0_io_csr_in_mtval_bits),
    .io_csr_in_halt               (_bru_0_io_csr_in_halt),
    .io_csr_in_fault              (_bru_0_io_csr_in_fault),
    .io_csr_in_wfi                (_bru_0_io_csr_in_wfi),
    .io_csr_out_mode              (_csr_io_bru_out_mode),
    .io_csr_out_mepc              (_csr_io_bru_out_mepc),
    .io_csr_out_mtvec             (_csr_io_bru_out_mtvec),
    .io_rs1_valid                 (_regfile_io_readData_0_valid),
    .io_rs1_data                  (_regfile_io_readData_0_data),
    .io_rs2_valid                 (_regfile_io_readData_1_valid),
    .io_rs2_data                  (_regfile_io_readData_1_data),
    .io_rd_valid                  (_bru_0_io_rd_valid),
    .io_rd_bits_addr              (_bru_0_io_rd_bits_addr),
    .io_rd_bits_data              (_bru_0_io_rd_bits_data),
    .io_taken_valid               (_bru_0_io_taken_valid),
    .io_taken_value               (_bru_0_io_taken_value),
    .io_target_data               (_regfile_io_target_0_data),
    .io_interlock                 (_bru_0_io_interlock),
    .io_fault_manager_valid       (_fault_manager_io_out_valid),
    .io_fault_manager_bits_mepc   (_fault_manager_io_out_bits_mepc),
    .io_fault_manager_bits_mtval  (_fault_manager_io_out_bits_mtval),
    .io_fault_manager_bits_mcause (_fault_manager_io_out_bits_mcause)
  );
  Bru_1 bru_1 (
    .clock              (clock),
    .reset              (reset),
    .io_req_valid       (_dispatch_io_bru_1_valid),
    .io_req_bits_fwd    (_dispatch_io_bru_1_bits_fwd),
    .io_req_bits_op     (_dispatch_io_bru_1_bits_op),
    .io_req_bits_pc     (_dispatch_io_bru_1_bits_pc),
    .io_req_bits_target (_dispatch_io_bru_1_bits_target),
    .io_req_bits_link   (_dispatch_io_bru_1_bits_link),
    .io_rs1_valid       (_regfile_io_readData_2_valid),
    .io_rs1_data        (_regfile_io_readData_2_data),
    .io_rs2_valid       (_regfile_io_readData_3_valid),
    .io_rs2_data        (_regfile_io_readData_3_data),
    .io_rd_valid        (_bru_1_io_rd_valid),
    .io_rd_bits_addr    (_bru_1_io_rd_bits_addr),
    .io_rd_bits_data    (_bru_1_io_rd_bits_data),
    .io_taken_valid     (_bru_1_io_taken_valid),
    .io_taken_value     (_bru_1_io_taken_value),
    .io_target_data     (_regfile_io_target_1_data)
  );
  LsuV2 lsu (
    .clock                    (clock),
    .reset                    (reset),
    .io_req_0_ready           (_lsu_io_req_0_ready),
    .io_req_0_valid           (_dispatch_io_lsu_0_valid),
    .io_req_0_bits_store      (_dispatch_io_lsu_0_bits_store),
    .io_req_0_bits_addr       (_dispatch_io_lsu_0_bits_addr),
    .io_req_0_bits_op         (_dispatch_io_lsu_0_bits_op),
    .io_req_0_bits_pc         (_dispatch_io_lsu_0_bits_pc),
    .io_req_1_ready           (_lsu_io_req_1_ready),
    .io_req_1_valid           (_dispatch_io_lsu_1_valid),
    .io_req_1_bits_store      (_dispatch_io_lsu_1_bits_store),
    .io_req_1_bits_addr       (_dispatch_io_lsu_1_bits_addr),
    .io_req_1_bits_op         (_dispatch_io_lsu_1_bits_op),
    .io_req_1_bits_pc         (_dispatch_io_lsu_1_bits_pc),
    .io_busPort_addr_0        (_regfile_io_busPort_addr_0),
    .io_busPort_addr_1        (_regfile_io_busPort_addr_1),
    .io_busPort_data_0        (_regfile_io_busPort_data_0),
    .io_busPort_data_1        (_regfile_io_busPort_data_1),
    .io_busPort_flt_data_0    (_fRegfile_io_busPort_data_0),
    .io_rd_valid              (_lsu_io_rd_valid),
    .io_rd_bits_addr          (_lsu_io_rd_bits_addr),
    .io_rd_bits_data          (_lsu_io_rd_bits_data),
    .io_rd_flt_valid          (_lsu_io_rd_flt_valid),
    .io_rd_flt_bits_addr      (_lsu_io_rd_flt_bits_addr),
    .io_rd_flt_bits_data      (_lsu_io_rd_flt_bits_data),
    .io_ibus_valid            (_lsu_io_ibus_valid),
    .io_ibus_ready            (_lsu_io_ibus_valid),
    .io_ibus_addr             (_lsu_io_ibus_addr),
    .io_ibus_rdata            (io_ibus_rdata),
    .io_dbus_valid            (_lsu_io_dbus_valid),
    .io_dbus_write            (_lsu_io_dbus_write),
    .io_dbus_addr             (_lsu_io_dbus_addr),
    .io_dbus_wdata            (_lsu_io_dbus_wdata),
    .io_dbus_wmask            (io_dbus_wmask),
    .io_dbus_rdata            (io_dbus_rdata),
    .io_flush_valid           (_lsu_io_flush_valid),
    .io_flush_ready           (_lsu_io_flush_valid),
    .io_flush_fencei          (_lsu_io_flush_fencei),
    .io_flush_pcNext          (_lsu_io_flush_pcNext),
    .io_fault_valid           (_lsu_io_fault_valid),
    .io_fault_bits_write      (_lsu_io_fault_bits_write),
    .io_fault_bits_addr       (_lsu_io_fault_bits_addr),
    .io_fault_bits_epc        (_lsu_io_fault_bits_epc),
    .io_ebus_dbus_valid       (io_ebus_dbus_valid),
    .io_ebus_dbus_ready       (io_ebus_dbus_ready),
    .io_ebus_dbus_write       (io_ebus_dbus_write),
    .io_ebus_dbus_pc          (io_ebus_dbus_pc),
    .io_ebus_dbus_addr        (io_ebus_dbus_addr),
    .io_ebus_dbus_size        (io_ebus_dbus_size),
    .io_ebus_dbus_wdata       (io_ebus_dbus_wdata),
    .io_ebus_dbus_wmask       (io_ebus_dbus_wmask),
    .io_ebus_dbus_rdata       (io_ebus_dbus_rdata),
    .io_ebus_fault_valid      (io_ebus_fault_valid),
    .io_ebus_fault_bits_write (io_ebus_fault_bits_write),
    .io_ebus_fault_bits_addr  (io_ebus_fault_bits_addr),
    .io_ebus_fault_bits_epc   (io_ebus_fault_bits_epc),
    .io_queueCapacity         (_lsu_io_queueCapacity),
    .io_active                (_lsu_io_active)
  );
  Mlu mlu (
    .clock              (clock),
    .reset              (reset),
    .io_req_0_valid     (_dispatch_io_mlu_0_valid),
    .io_req_0_bits_addr (_dispatch_io_mlu_0_bits_addr),
    .io_req_0_bits_op   (_dispatch_io_mlu_0_bits_op),
    .io_req_1_ready     (_mlu_io_req_1_ready),
    .io_req_1_valid     (_dispatch_io_mlu_1_valid),
    .io_req_1_bits_addr (_dispatch_io_mlu_1_bits_addr),
    .io_req_1_bits_op   (_dispatch_io_mlu_1_bits_op),
    .io_rs1_0_valid     (_regfile_io_readData_0_valid),
    .io_rs1_0_data      (_regfile_io_readData_0_data),
    .io_rs1_1_valid     (_regfile_io_readData_2_valid),
    .io_rs1_1_data      (_regfile_io_readData_2_data),
    .io_rs2_0_valid     (_regfile_io_readData_1_valid),
    .io_rs2_0_data      (_regfile_io_readData_1_data),
    .io_rs2_1_valid     (_regfile_io_readData_3_valid),
    .io_rs2_1_data      (_regfile_io_readData_3_data),
    .io_rd_valid        (_mlu_io_rd_valid),
    .io_rd_bits_addr    (_mlu_io_rd_bits_addr),
    .io_rd_bits_data    (_mlu_io_rd_bits_data)
  );
  Dvu dvu (
    .clock            (clock),
    .reset            (reset),
    .io_req_ready     (_dvu_io_req_ready),
    .io_req_valid     (_dispatch_io_dvu_0_valid),
    .io_req_bits_addr (_dispatch_io_dvu_0_bits_addr),
    .io_req_bits_op   (_dispatch_io_dvu_0_bits_op),
    .io_rs1_data      (_regfile_io_readData_0_data),
    .io_rs2_data      (_regfile_io_readData_1_data),
    .io_rd_ready      (_arb_io_in_1_ready),
    .io_rd_valid      (_dvu_io_rd_valid),
    .io_rd_bits_addr  (_dvu_io_rd_bits_addr),
    .io_rd_bits_data  (_dvu_io_rd_bits_data)
  );
  FaultManager fault_manager (
    .io_in_fault_0_csr             (_dispatch_io_csrFault_0),
    .io_in_fault_0_jal             (_dispatch_io_jalFault_0),
    .io_in_fault_0_jalr            (_dispatch_io_jalrFault_0),
    .io_in_fault_0_bxx             (_dispatch_io_bxxFault_0),
    .io_in_fault_0_undef           (_dispatch_io_undefFault_0),
    .io_in_fault_1_jal             (_dispatch_io_jalFault_1),
    .io_in_fault_1_jalr            (_dispatch_io_jalrFault_1),
    .io_in_fault_1_bxx             (_dispatch_io_bxxFault_1),
    .io_in_pc_0_pc                 (_fetch_io_inst_lanes_0_bits_addr),
    .io_in_pc_1_pc                 (_fetch_io_inst_lanes_1_bits_addr),
    .io_in_memory_fault_valid
      (io_ibus_fault_valid ? io_ibus_fault_valid : _lsu_io_fault_valid),
    .io_in_memory_fault_bits_write
      (~io_ibus_fault_valid & _lsu_io_fault_valid & _lsu_io_fault_bits_write),
    .io_in_memory_fault_bits_addr
      (io_ibus_fault_valid | ~_lsu_io_fault_valid ? 32'h0 : _lsu_io_fault_bits_addr),
    .io_in_memory_fault_bits_epc
      (io_ibus_fault_valid
         ? io_ibus_fault_bits_epc
         : _lsu_io_fault_valid ? _lsu_io_fault_bits_epc : 32'h0),
    .io_in_ibus_fault              (io_ibus_fault_valid),
    .io_in_undef_0_inst            (_fetch_io_inst_lanes_0_bits_inst),
    .io_in_undef_1_inst            (_fetch_io_inst_lanes_1_bits_inst),
    .io_in_jal_0_target            (_dispatch_io_bruTarget_0),
    .io_in_jal_1_target            (_dispatch_io_bruTarget_1),
    .io_in_jalr_0_target           (_regfile_io_target_0_data),
    .io_in_jalr_1_target           (_regfile_io_target_1_data),
    .io_in_fetchFault
      (_fetch_io_fault & ~branchTaken & _regfile_io_scoreboard_regd == 32'h0
       & _fRegfile_io_scoreboard == 32'h0 & ~_lsu_io_active
       & ~(_fetch_io_inst_lanes_0_valid | _fetch_io_inst_lanes_1_valid)),
    .io_out_valid                  (_fault_manager_io_out_valid),
    .io_out_bits_mepc              (_fault_manager_io_out_bits_mepc),
    .io_out_bits_mtval             (_fault_manager_io_out_bits_mtval),
    .io_out_bits_mcause            (_fault_manager_io_out_bits_mcause)
  );
  FloatCore floatCore (
    .clock                          (clock),
    .reset                          (reset),
    .io_inst_ready                  (_floatCore_io_inst_ready),
    .io_inst_valid                  (_dispatch_io_float_valid),
    .io_inst_bits_opcode            (_dispatch_io_float_bits_opcode),
    .io_inst_bits_funct5            (_dispatch_io_float_bits_funct5),
    .io_inst_bits_rs3               (_dispatch_io_float_bits_rs3),
    .io_inst_bits_rs2               (_dispatch_io_float_bits_rs2),
    .io_inst_bits_rs1               (_dispatch_io_float_bits_rs1),
    .io_inst_bits_rm                (_dispatch_io_float_bits_rm),
    .io_inst_bits_inst              (_dispatch_io_float_bits_inst),
    .io_inst_bits_pc                (_dispatch_io_float_bits_pc),
    .io_inst_bits_scalar_rd         (_dispatch_io_float_bits_scalar_rd),
    .io_inst_bits_scalar_rs1        (_dispatch_io_float_bits_scalar_rs1),
    .io_inst_bits_rd                (_dispatch_io_float_bits_rd),
    .io_inst_bits_uses_rs3          (_dispatch_io_float_bits_uses_rs3),
    .io_inst_bits_uses_rs2          (_dispatch_io_float_bits_uses_rs2),
    .io_read_ports_0_valid          (_floatCore_io_read_ports_0_valid),
    .io_read_ports_0_addr           (_floatCore_io_read_ports_0_addr),
    .io_read_ports_0_data_mantissa  (_fRegfile_io_read_ports_0_data_mantissa),
    .io_read_ports_0_data_exponent  (_fRegfile_io_read_ports_0_data_exponent),
    .io_read_ports_0_data_sign      (_fRegfile_io_read_ports_0_data_sign),
    .io_read_ports_1_valid          (_floatCore_io_read_ports_1_valid),
    .io_read_ports_1_addr           (_floatCore_io_read_ports_1_addr),
    .io_read_ports_1_data_mantissa  (_fRegfile_io_read_ports_1_data_mantissa),
    .io_read_ports_1_data_exponent  (_fRegfile_io_read_ports_1_data_exponent),
    .io_read_ports_1_data_sign      (_fRegfile_io_read_ports_1_data_sign),
    .io_read_ports_2_valid          (_floatCore_io_read_ports_2_valid),
    .io_read_ports_2_addr           (_floatCore_io_read_ports_2_addr),
    .io_read_ports_2_data_mantissa  (_fRegfile_io_read_ports_2_data_mantissa),
    .io_read_ports_2_data_exponent  (_fRegfile_io_read_ports_2_data_exponent),
    .io_read_ports_2_data_sign      (_fRegfile_io_read_ports_2_data_sign),
    .io_write_ports_0_valid         (_floatCore_io_write_ports_0_valid),
    .io_write_ports_0_addr          (_floatCore_io_write_ports_0_addr),
    .io_write_ports_0_data_mantissa (_floatCore_io_write_ports_0_data_mantissa),
    .io_write_ports_0_data_exponent (_floatCore_io_write_ports_0_data_exponent),
    .io_write_ports_0_data_sign     (_floatCore_io_write_ports_0_data_sign),
    .io_write_ports_1_valid         (_floatCore_io_write_ports_1_valid),
    .io_write_ports_1_addr          (_floatCore_io_write_ports_1_addr),
    .io_write_ports_1_data_mantissa (_floatCore_io_write_ports_1_data_mantissa),
    .io_write_ports_1_data_exponent (_floatCore_io_write_ports_1_data_exponent),
    .io_write_ports_1_data_sign     (_floatCore_io_write_ports_1_data_sign),
    .io_rs1_data                    (_regfile_io_readData_0_data),
    .io_scalar_rd_ready             (_arb_io_in_2_ready),
    .io_scalar_rd_valid             (_floatCore_io_scalar_rd_valid),
    .io_scalar_rd_bits_addr         (_floatCore_io_scalar_rd_bits_addr),
    .io_scalar_rd_bits_data         (_floatCore_io_scalar_rd_bits_data),
    .io_csr_in_fflags_valid         (_floatCore_io_csr_in_fflags_valid),
    .io_csr_in_fflags_bits          (_floatCore_io_csr_in_fflags_bits),
    .io_csr_out_frm                 (_csr_io_float_out_frm),
    .io_lsu_rd_valid                (_lsu_io_rd_flt_valid),
    .io_lsu_rd_bits_addr            (_lsu_io_rd_flt_bits_addr),
    .io_lsu_rd_bits_data            (_lsu_io_rd_flt_bits_data)
  );
  FRegfile fRegfile (
    .clock                          (clock),
    .reset                          (reset),
    .io_read_ports_0_valid          (_floatCore_io_read_ports_0_valid),
    .io_read_ports_0_addr           (_floatCore_io_read_ports_0_addr),
    .io_read_ports_0_data_mantissa  (_fRegfile_io_read_ports_0_data_mantissa),
    .io_read_ports_0_data_exponent  (_fRegfile_io_read_ports_0_data_exponent),
    .io_read_ports_0_data_sign      (_fRegfile_io_read_ports_0_data_sign),
    .io_read_ports_1_valid          (_floatCore_io_read_ports_1_valid),
    .io_read_ports_1_addr           (_floatCore_io_read_ports_1_addr),
    .io_read_ports_1_data_mantissa  (_fRegfile_io_read_ports_1_data_mantissa),
    .io_read_ports_1_data_exponent  (_fRegfile_io_read_ports_1_data_exponent),
    .io_read_ports_1_data_sign      (_fRegfile_io_read_ports_1_data_sign),
    .io_read_ports_2_valid          (_floatCore_io_read_ports_2_valid),
    .io_read_ports_2_addr           (_floatCore_io_read_ports_2_addr),
    .io_read_ports_2_data_mantissa  (_fRegfile_io_read_ports_2_data_mantissa),
    .io_read_ports_2_data_exponent  (_fRegfile_io_read_ports_2_data_exponent),
    .io_read_ports_2_data_sign      (_fRegfile_io_read_ports_2_data_sign),
    .io_write_ports_0_valid         (_floatCore_io_write_ports_0_valid),
    .io_write_ports_0_addr          (_floatCore_io_write_ports_0_addr),
    .io_write_ports_0_data_mantissa (_floatCore_io_write_ports_0_data_mantissa),
    .io_write_ports_0_data_exponent (_floatCore_io_write_ports_0_data_exponent),
    .io_write_ports_0_data_sign     (_floatCore_io_write_ports_0_data_sign),
    .io_write_ports_1_valid         (_floatCore_io_write_ports_1_valid),
    .io_write_ports_1_addr          (_floatCore_io_write_ports_1_addr),
    .io_write_ports_1_data_mantissa (_floatCore_io_write_ports_1_data_mantissa),
    .io_write_ports_1_data_exponent (_floatCore_io_write_ports_1_data_exponent),
    .io_write_ports_1_data_sign     (_floatCore_io_write_ports_1_data_sign),
    .io_scoreboard_set
      (_dispatch_io_rdMark_flt_valid ? 32'h1 << _dispatch_io_rdMark_flt_addr : 32'h0),
    .io_scoreboard                  (_fRegfile_io_scoreboard),
    .io_busPort_data_0              (_fRegfile_io_busPort_data_0),
    .io_busPortAddr                 (_dispatch_io_fbusPortAddr)
  );
  Arbiter3_RegfileWriteDataIO arb (
    .io_in_0_valid     (_mlu_io_rd_valid),
    .io_in_0_bits_addr (_mlu_io_rd_bits_addr),
    .io_in_0_bits_data (_mlu_io_rd_bits_data),
    .io_in_1_ready     (_arb_io_in_1_ready),
    .io_in_1_valid     (_dvu_io_rd_valid),
    .io_in_1_bits_addr (_dvu_io_rd_bits_addr),
    .io_in_1_bits_data (_dvu_io_rd_bits_data),
    .io_in_2_ready     (_arb_io_in_2_ready),
    .io_in_2_valid     (_floatCore_io_scalar_rd_valid),
    .io_in_2_bits_addr (_floatCore_io_scalar_rd_bits_addr),
    .io_in_2_bits_data (_floatCore_io_scalar_rd_bits_data),
    .io_out_valid      (_arb_io_out_valid),
    .io_out_bits_addr  (_arb_io_out_bits_addr),
    .io_out_bits_data  (_arb_io_out_bits_data)
  );
  assign io_csr_out_value_4 = _csr_io_csr_out_value_4;
  assign io_halted = _csr_io_halted;
  assign io_wfi = _csr_io_wfi;
  assign io_ibus_valid = _lsu_io_ibus_valid ? _lsu_io_ibus_valid : _fetch_io_ibus_valid;
  assign io_ibus_addr = _lsu_io_ibus_valid ? _lsu_io_ibus_addr : _fetch_io_ibus_addr;
  assign io_dbus_valid = _lsu_io_dbus_valid;
  assign io_dbus_write = _lsu_io_dbus_write;
  assign io_dbus_addr = _lsu_io_dbus_addr;
  assign io_dbus_wdata = _lsu_io_dbus_wdata;
  assign io_slog_valid = slogValid;
  assign io_slog_addr = {3'h0, slogValid ? slogAddr : 2'h0};
  assign io_slog_data = slogValid ? _regfile_io_readData_0_data : 32'h0;
  assign io_debug_en = {2'h0, {~_bru_1_io_taken_valid, 1'h1} & debugEn};
  assign io_debug_addr_0 = debugAddr_0;
  assign io_debug_addr_1 = debugAddr_1;
  assign io_debug_inst_0 = debugInst_0;
  assign io_debug_inst_1 = debugInst_1;
  assign io_debug_cycles = _csr_io_csr_out_value_4;
  assign io_debug_dbus_valid = _lsu_io_dbus_valid;
  assign io_debug_dbus_bits_addr = _lsu_io_dbus_addr;
  assign io_debug_dbus_bits_wdata = _lsu_io_dbus_wdata;
  assign io_debug_dbus_bits_write = _lsu_io_dbus_write;
  assign io_debug_dispatch_0_instFire =
    _dispatch_io_inst_0_ready & _fetch_io_inst_lanes_0_valid;
  assign io_debug_dispatch_0_instAddr = _fetch_io_inst_lanes_0_bits_addr;
  assign io_debug_dispatch_0_instInst = _fetch_io_inst_lanes_0_bits_inst;
  assign io_debug_dispatch_1_instFire =
    _dispatch_io_inst_1_ready & _fetch_io_inst_lanes_1_valid;
  assign io_debug_dispatch_1_instAddr = _fetch_io_inst_lanes_1_bits_addr;
  assign io_debug_dispatch_1_instInst = _fetch_io_inst_lanes_1_bits_inst;
  assign io_debug_regfile_writeAddr_0_valid = _dispatch_io_rdMark_0_valid;
  assign io_debug_regfile_writeAddr_0_bits = _dispatch_io_rdMark_0_addr;
  assign io_debug_regfile_writeAddr_1_valid = _dispatch_io_rdMark_1_valid;
  assign io_debug_regfile_writeAddr_1_bits = _dispatch_io_rdMark_1_addr;
  assign io_debug_regfile_writeData_0_valid = regfile_io_writeData_0_valid;
  assign io_debug_regfile_writeData_0_bits_addr = regfile_io_writeData_0_bits_addr;
  assign io_debug_regfile_writeData_0_bits_data = regfile_io_writeData_0_bits_data;
  assign io_debug_regfile_writeData_1_valid = regfile_io_writeData_1_valid;
  assign io_debug_regfile_writeData_1_bits_addr = regfile_io_writeData_1_bits_addr;
  assign io_debug_regfile_writeData_1_bits_data = regfile_io_writeData_1_bits_data;
  assign io_debug_regfile_writeData_2_valid = _arb_io_out_valid;
  assign io_debug_regfile_writeData_2_bits_addr = _arb_io_out_bits_addr;
  assign io_debug_regfile_writeData_2_bits_data = _arb_io_out_bits_data;
  assign io_debug_regfile_writeData_3_valid = _lsu_io_rd_valid;
  assign io_debug_regfile_writeData_3_bits_addr = _lsu_io_rd_bits_addr;
  assign io_debug_regfile_writeData_3_bits_data = _lsu_io_rd_bits_data;
  assign io_debug_float_writeAddr_valid = _dispatch_io_rdMark_flt_valid;
  assign io_debug_float_writeAddr_bits = _dispatch_io_rdMark_flt_addr;
  assign io_debug_float_writeData_0_valid = _floatCore_io_write_ports_0_valid;
  assign io_debug_float_writeData_0_bits_addr = {27'h0, _floatCore_io_write_ports_0_addr};
  assign io_debug_float_writeData_0_bits_data =
    {_floatCore_io_write_ports_0_data_sign,
     _floatCore_io_write_ports_0_data_exponent,
     _floatCore_io_write_ports_0_data_mantissa};
  assign io_debug_float_writeData_1_valid = _floatCore_io_write_ports_1_valid;
  assign io_debug_float_writeData_1_bits_addr = {27'h0, _floatCore_io_write_ports_1_addr};
  assign io_debug_float_writeData_1_bits_data =
    {_floatCore_io_write_ports_1_data_sign,
     _floatCore_io_write_ports_1_data_exponent,
     _floatCore_io_write_ports_1_data_mantissa};
endmodule

module CoreMini(
  input          clock,
                 reset,
  input  [31:0]  io_csr_in_value_0,
  output [31:0]  io_csr_out_value_0,
                 io_csr_out_value_1,
                 io_csr_out_value_2,
                 io_csr_out_value_3,
                 io_csr_out_value_4,
                 io_csr_out_value_5,
                 io_csr_out_value_6,
                 io_csr_out_value_7,
                 io_csr_out_value_8,
  output         io_halted,
                 io_fault,
                 io_wfi,
  input          io_irq,
  output         io_ibus_valid,
  output [31:0]  io_ibus_addr,
  input  [127:0] io_ibus_rdata,
  input          io_ibus_fault_valid,
  input  [31:0]  io_ibus_fault_bits_epc,
  output         io_dbus_valid,
                 io_dbus_write,
  output [31:0]  io_dbus_addr,
  output [127:0] io_dbus_wdata,
  output [15:0]  io_dbus_wmask,
  input  [127:0] io_dbus_rdata,
  output         io_ebus_dbus_valid,
  input          io_ebus_dbus_ready,
  output         io_ebus_dbus_write,
  output [31:0]  io_ebus_dbus_pc,
                 io_ebus_dbus_addr,
  output [4:0]   io_ebus_dbus_size,
  output [127:0] io_ebus_dbus_wdata,
  output [15:0]  io_ebus_dbus_wmask,
  input  [127:0] io_ebus_dbus_rdata,
  input          io_ebus_fault_valid,
                 io_ebus_fault_bits_write,
  input  [31:0]  io_ebus_fault_bits_addr,
                 io_ebus_fault_bits_epc,
  output         io_slog_valid,
  output [4:0]   io_slog_addr,
  output [31:0]  io_slog_data,
  output [3:0]   io_debug_en,
  output [31:0]  io_debug_addr_0,
                 io_debug_addr_1,
                 io_debug_inst_0,
                 io_debug_inst_1,
                 io_debug_cycles,
  output         io_debug_dbus_valid,
  output [31:0]  io_debug_dbus_bits_addr,
  output [127:0] io_debug_dbus_bits_wdata,
  output         io_debug_dbus_bits_write,
                 io_debug_dispatch_0_instFire,
  output [31:0]  io_debug_dispatch_0_instAddr,
                 io_debug_dispatch_0_instInst,
  output         io_debug_dispatch_1_instFire,
  output [31:0]  io_debug_dispatch_1_instAddr,
                 io_debug_dispatch_1_instInst,
  output         io_debug_regfile_writeAddr_0_valid,
  output [4:0]   io_debug_regfile_writeAddr_0_bits,
  output         io_debug_regfile_writeAddr_1_valid,
  output [4:0]   io_debug_regfile_writeAddr_1_bits,
  output         io_debug_regfile_writeData_0_valid,
  output [4:0]   io_debug_regfile_writeData_0_bits_addr,
  output [31:0]  io_debug_regfile_writeData_0_bits_data,
  output         io_debug_regfile_writeData_1_valid,
  output [4:0]   io_debug_regfile_writeData_1_bits_addr,
  output [31:0]  io_debug_regfile_writeData_1_bits_data,
  output         io_debug_regfile_writeData_2_valid,
  output [4:0]   io_debug_regfile_writeData_2_bits_addr,
  output [31:0]  io_debug_regfile_writeData_2_bits_data,
  output         io_debug_regfile_writeData_3_valid,
  output [4:0]   io_debug_regfile_writeData_3_bits_addr,
  output [31:0]  io_debug_regfile_writeData_3_bits_data,
  output         io_debug_float_writeAddr_valid,
  output [4:0]   io_debug_float_writeAddr_bits,
  output         io_debug_float_writeData_0_valid,
  output [31:0]  io_debug_float_writeData_0_bits_addr,
                 io_debug_float_writeData_0_bits_data,
  output         io_debug_float_writeData_1_valid,
  output [31:0]  io_debug_float_writeData_1_bits_addr,
                 io_debug_float_writeData_1_bits_data
);

  SCore score (
    .clock                                  (clock),
    .reset                                  (reset),
    .io_csr_in_value_0                      (io_csr_in_value_0),
    .io_csr_out_value_0                     (io_csr_out_value_0),
    .io_csr_out_value_1                     (io_csr_out_value_1),
    .io_csr_out_value_2                     (io_csr_out_value_2),
    .io_csr_out_value_3                     (io_csr_out_value_3),
    .io_csr_out_value_4                     (io_csr_out_value_4),
    .io_csr_out_value_5                     (io_csr_out_value_5),
    .io_csr_out_value_6                     (io_csr_out_value_6),
    .io_csr_out_value_7                     (io_csr_out_value_7),
    .io_csr_out_value_8                     (io_csr_out_value_8),
    .io_halted                              (io_halted),
    .io_fault                               (io_fault),
    .io_wfi                                 (io_wfi),
    .io_irq                                 (io_irq),
    .io_ibus_valid                          (io_ibus_valid),
    .io_ibus_addr                           (io_ibus_addr),
    .io_ibus_rdata                          (io_ibus_rdata),
    .io_ibus_fault_valid                    (io_ibus_fault_valid),
    .io_ibus_fault_bits_epc                 (io_ibus_fault_bits_epc),
    .io_dbus_valid                          (io_dbus_valid),
    .io_dbus_write                          (io_dbus_write),
    .io_dbus_addr                           (io_dbus_addr),
    .io_dbus_wdata                          (io_dbus_wdata),
    .io_dbus_wmask                          (io_dbus_wmask),
    .io_dbus_rdata                          (io_dbus_rdata),
    .io_ebus_dbus_valid                     (io_ebus_dbus_valid),
    .io_ebus_dbus_ready                     (io_ebus_dbus_ready),
    .io_ebus_dbus_write                     (io_ebus_dbus_write),
    .io_ebus_dbus_pc                        (io_ebus_dbus_pc),
    .io_ebus_dbus_addr                      (io_ebus_dbus_addr),
    .io_ebus_dbus_size                      (io_ebus_dbus_size),
    .io_ebus_dbus_wdata                     (io_ebus_dbus_wdata),
    .io_ebus_dbus_wmask                     (io_ebus_dbus_wmask),
    .io_ebus_dbus_rdata                     (io_ebus_dbus_rdata),
    .io_ebus_fault_valid                    (io_ebus_fault_valid),
    .io_ebus_fault_bits_write               (io_ebus_fault_bits_write),
    .io_ebus_fault_bits_addr                (io_ebus_fault_bits_addr),
    .io_ebus_fault_bits_epc                 (io_ebus_fault_bits_epc),
    .io_slog_valid                          (io_slog_valid),
    .io_slog_addr                           (io_slog_addr),
    .io_slog_data                           (io_slog_data),
    .io_debug_en                            (io_debug_en),
    .io_debug_addr_0                        (io_debug_addr_0),
    .io_debug_addr_1                        (io_debug_addr_1),
    .io_debug_inst_0                        (io_debug_inst_0),
    .io_debug_inst_1                        (io_debug_inst_1),
    .io_debug_cycles                        (io_debug_cycles),
    .io_debug_dbus_valid                    (io_debug_dbus_valid),
    .io_debug_dbus_bits_addr                (io_debug_dbus_bits_addr),
    .io_debug_dbus_bits_wdata               (io_debug_dbus_bits_wdata),
    .io_debug_dbus_bits_write               (io_debug_dbus_bits_write),
    .io_debug_dispatch_0_instFire           (io_debug_dispatch_0_instFire),
    .io_debug_dispatch_0_instAddr           (io_debug_dispatch_0_instAddr),
    .io_debug_dispatch_0_instInst           (io_debug_dispatch_0_instInst),
    .io_debug_dispatch_1_instFire           (io_debug_dispatch_1_instFire),
    .io_debug_dispatch_1_instAddr           (io_debug_dispatch_1_instAddr),
    .io_debug_dispatch_1_instInst           (io_debug_dispatch_1_instInst),
    .io_debug_regfile_writeAddr_0_valid     (io_debug_regfile_writeAddr_0_valid),
    .io_debug_regfile_writeAddr_0_bits      (io_debug_regfile_writeAddr_0_bits),
    .io_debug_regfile_writeAddr_1_valid     (io_debug_regfile_writeAddr_1_valid),
    .io_debug_regfile_writeAddr_1_bits      (io_debug_regfile_writeAddr_1_bits),
    .io_debug_regfile_writeData_0_valid     (io_debug_regfile_writeData_0_valid),
    .io_debug_regfile_writeData_0_bits_addr (io_debug_regfile_writeData_0_bits_addr),
    .io_debug_regfile_writeData_0_bits_data (io_debug_regfile_writeData_0_bits_data),
    .io_debug_regfile_writeData_1_valid     (io_debug_regfile_writeData_1_valid),
    .io_debug_regfile_writeData_1_bits_addr (io_debug_regfile_writeData_1_bits_addr),
    .io_debug_regfile_writeData_1_bits_data (io_debug_regfile_writeData_1_bits_data),
    .io_debug_regfile_writeData_2_valid     (io_debug_regfile_writeData_2_valid),
    .io_debug_regfile_writeData_2_bits_addr (io_debug_regfile_writeData_2_bits_addr),
    .io_debug_regfile_writeData_2_bits_data (io_debug_regfile_writeData_2_bits_data),
    .io_debug_regfile_writeData_3_valid     (io_debug_regfile_writeData_3_valid),
    .io_debug_regfile_writeData_3_bits_addr (io_debug_regfile_writeData_3_bits_addr),
    .io_debug_regfile_writeData_3_bits_data (io_debug_regfile_writeData_3_bits_data),
    .io_debug_float_writeAddr_valid         (io_debug_float_writeAddr_valid),
    .io_debug_float_writeAddr_bits          (io_debug_float_writeAddr_bits),
    .io_debug_float_writeData_0_valid       (io_debug_float_writeData_0_valid),
    .io_debug_float_writeData_0_bits_addr   (io_debug_float_writeData_0_bits_addr),
    .io_debug_float_writeData_0_bits_data   (io_debug_float_writeData_0_bits_data),
    .io_debug_float_writeData_1_valid       (io_debug_float_writeData_1_valid),
    .io_debug_float_writeData_1_bits_addr   (io_debug_float_writeData_1_bits_addr),
    .io_debug_float_writeData_1_bits_data   (io_debug_float_writeData_1_bits_data)
  );
endmodule

module SRAM_256x128(
  input          clock,
                 reset,
  input  [7:0]   io_addr,
  input          io_enable,
                 io_write,
  input  [127:0] io_wdata,
  input  [15:0]  io_wmask,
  output [127:0] io_rdata
);

  wire [127:0] _sramModules_1_rdata;
  wire [127:0] _sramModules_0_rdata;
  reg          selectedSramRead;
  always @(posedge clock or posedge reset) begin
    if (reset)
      selectedSramRead <= 1'h0;
    else
      selectedSramRead <= io_addr[7];
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        selectedSramRead = _RANDOM[/*Zero width*/ 1'b0][0];
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        selectedSramRead = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Sram_12ffcp_128x128 sramModules_0 (
    .clock  (clock),
    .enable (~(io_addr[7]) & io_enable),
    .write  (io_write),
    .addr   (io_addr[6:0]),
    .wdata  (io_wdata),
    .wmask  (io_wmask),
    .rdata  (_sramModules_0_rdata)
  );
  Sram_12ffcp_128x128 sramModules_1 (
    .clock  (clock),
    .enable (io_addr[7] & io_enable),
    .write  (io_write),
    .addr   (io_addr[6:0]),
    .wdata  (io_wdata),
    .wmask  (io_wmask),
    .rdata  (_sramModules_1_rdata)
  );
  assign io_rdata = selectedSramRead ? _sramModules_1_rdata : _sramModules_0_rdata;
endmodule

module TCM128(
  input        clock,
               reset,
  input  [7:0] io_addr,
  input        io_enable,
               io_write,
  input  [7:0] io_wdata_0,
               io_wdata_1,
               io_wdata_2,
               io_wdata_3,
               io_wdata_4,
               io_wdata_5,
               io_wdata_6,
               io_wdata_7,
               io_wdata_8,
               io_wdata_9,
               io_wdata_10,
               io_wdata_11,
               io_wdata_12,
               io_wdata_13,
               io_wdata_14,
               io_wdata_15,
  input        io_wmask_0,
               io_wmask_1,
               io_wmask_2,
               io_wmask_3,
               io_wmask_4,
               io_wmask_5,
               io_wmask_6,
               io_wmask_7,
               io_wmask_8,
               io_wmask_9,
               io_wmask_10,
               io_wmask_11,
               io_wmask_12,
               io_wmask_13,
               io_wmask_14,
               io_wmask_15,
  output [7:0] io_rdata_0,
               io_rdata_1,
               io_rdata_2,
               io_rdata_3,
               io_rdata_4,
               io_rdata_5,
               io_rdata_6,
               io_rdata_7,
               io_rdata_8,
               io_rdata_9,
               io_rdata_10,
               io_rdata_11,
               io_rdata_12,
               io_rdata_13,
               io_rdata_14,
               io_rdata_15
);

  wire [127:0] _sram_io_rdata;
  SRAM_256x128 sram (
    .clock     (clock),
    .reset     (reset),
    .io_addr   (io_addr),
    .io_enable (io_enable),
    .io_write  (io_write),
    .io_wdata
      ({io_wdata_15,
        io_wdata_14,
        io_wdata_13,
        io_wdata_12,
        io_wdata_11,
        io_wdata_10,
        io_wdata_9,
        io_wdata_8,
        io_wdata_7,
        io_wdata_6,
        io_wdata_5,
        io_wdata_4,
        io_wdata_3,
        io_wdata_2,
        io_wdata_1,
        io_wdata_0}),
    .io_wmask
      ({io_wmask_15,
        io_wmask_14,
        io_wmask_13,
        io_wmask_12,
        io_wmask_11,
        io_wmask_10,
        io_wmask_9,
        io_wmask_8,
        io_wmask_7,
        io_wmask_6,
        io_wmask_5,
        io_wmask_4,
        io_wmask_3,
        io_wmask_2,
        io_wmask_1,
        io_wmask_0}),
    .io_rdata  (_sram_io_rdata)
  );
  assign io_rdata_0 = _sram_io_rdata[127:120];
  assign io_rdata_1 = _sram_io_rdata[119:112];
  assign io_rdata_2 = _sram_io_rdata[111:104];
  assign io_rdata_3 = _sram_io_rdata[103:96];
  assign io_rdata_4 = _sram_io_rdata[95:88];
  assign io_rdata_5 = _sram_io_rdata[87:80];
  assign io_rdata_6 = _sram_io_rdata[79:72];
  assign io_rdata_7 = _sram_io_rdata[71:64];
  assign io_rdata_8 = _sram_io_rdata[63:56];
  assign io_rdata_9 = _sram_io_rdata[55:48];
  assign io_rdata_10 = _sram_io_rdata[47:40];
  assign io_rdata_11 = _sram_io_rdata[39:32];
  assign io_rdata_12 = _sram_io_rdata[31:24];
  assign io_rdata_13 = _sram_io_rdata[23:16];
  assign io_rdata_14 = _sram_io_rdata[15:8];
  assign io_rdata_15 = _sram_io_rdata[7:0];
endmodule

module SRAM(
  input          clock,
                 reset,
                 io_fabric_readDataAddr_valid,
  input  [31:0]  io_fabric_readDataAddr_bits,
  output         io_fabric_readData_valid,
  output [127:0] io_fabric_readData_bits,
  input          io_fabric_writeDataAddr_valid,
  input  [31:0]  io_fabric_writeDataAddr_bits,
  input  [127:0] io_fabric_writeDataBits,
  input  [15:0]  io_fabric_writeDataStrb,
  output [7:0]   io_sram_address,
  output         io_sram_enable,
                 io_sram_isWrite,
  input  [7:0]   io_sram_readData_0,
                 io_sram_readData_1,
                 io_sram_readData_2,
                 io_sram_readData_3,
                 io_sram_readData_4,
                 io_sram_readData_5,
                 io_sram_readData_6,
                 io_sram_readData_7,
                 io_sram_readData_8,
                 io_sram_readData_9,
                 io_sram_readData_10,
                 io_sram_readData_11,
                 io_sram_readData_12,
                 io_sram_readData_13,
                 io_sram_readData_14,
                 io_sram_readData_15,
  output [7:0]   io_sram_writeData_0,
                 io_sram_writeData_1,
                 io_sram_writeData_2,
                 io_sram_writeData_3,
                 io_sram_writeData_4,
                 io_sram_writeData_5,
                 io_sram_writeData_6,
                 io_sram_writeData_7,
                 io_sram_writeData_8,
                 io_sram_writeData_9,
                 io_sram_writeData_10,
                 io_sram_writeData_11,
                 io_sram_writeData_12,
                 io_sram_writeData_13,
                 io_sram_writeData_14,
                 io_sram_writeData_15,
  output         io_sram_mask_0,
                 io_sram_mask_1,
                 io_sram_mask_2,
                 io_sram_mask_3,
                 io_sram_mask_4,
                 io_sram_mask_5,
                 io_sram_mask_6,
                 io_sram_mask_7,
                 io_sram_mask_8,
                 io_sram_mask_9,
                 io_sram_mask_10,
                 io_sram_mask_11,
                 io_sram_mask_12,
                 io_sram_mask_13,
                 io_sram_mask_14,
                 io_sram_mask_15
);

  reg readIssued;
  always @(posedge clock or posedge reset) begin
    if (reset)
      readIssued <= 1'h0;
    else
      readIssued <= io_fabric_readDataAddr_valid & ~io_fabric_writeDataAddr_valid;
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        readIssued = _RANDOM[/*Zero width*/ 1'b0][0];
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        readIssued = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_fabric_readData_valid = readIssued;
  assign io_fabric_readData_bits =
    readIssued
      ? {io_sram_readData_0,
         io_sram_readData_1,
         io_sram_readData_2,
         io_sram_readData_3,
         io_sram_readData_4,
         io_sram_readData_5,
         io_sram_readData_6,
         io_sram_readData_7,
         io_sram_readData_8,
         io_sram_readData_9,
         io_sram_readData_10,
         io_sram_readData_11,
         io_sram_readData_12,
         io_sram_readData_13,
         io_sram_readData_14,
         io_sram_readData_15}
      : 128'h0;
  assign io_sram_address =
    io_fabric_writeDataAddr_valid
      ? io_fabric_writeDataAddr_bits[11:4]
      : io_fabric_readDataAddr_valid ? io_fabric_readDataAddr_bits[11:4] : 8'h0;
  assign io_sram_enable = io_fabric_readDataAddr_valid | io_fabric_writeDataAddr_valid;
  assign io_sram_isWrite = io_fabric_writeDataAddr_valid;
  assign io_sram_writeData_0 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[7:0] : 8'h0;
  assign io_sram_writeData_1 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[15:8] : 8'h0;
  assign io_sram_writeData_2 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[23:16] : 8'h0;
  assign io_sram_writeData_3 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[31:24] : 8'h0;
  assign io_sram_writeData_4 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[39:32] : 8'h0;
  assign io_sram_writeData_5 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[47:40] : 8'h0;
  assign io_sram_writeData_6 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[55:48] : 8'h0;
  assign io_sram_writeData_7 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[63:56] : 8'h0;
  assign io_sram_writeData_8 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[71:64] : 8'h0;
  assign io_sram_writeData_9 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[79:72] : 8'h0;
  assign io_sram_writeData_10 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[87:80] : 8'h0;
  assign io_sram_writeData_11 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[95:88] : 8'h0;
  assign io_sram_writeData_12 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[103:96] : 8'h0;
  assign io_sram_writeData_13 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[111:104] : 8'h0;
  assign io_sram_writeData_14 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[119:112] : 8'h0;
  assign io_sram_writeData_15 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[127:120] : 8'h0;
  assign io_sram_mask_0 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[0];
  assign io_sram_mask_1 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[1];
  assign io_sram_mask_2 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[2];
  assign io_sram_mask_3 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[3];
  assign io_sram_mask_4 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[4];
  assign io_sram_mask_5 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[5];
  assign io_sram_mask_6 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[6];
  assign io_sram_mask_7 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[7];
  assign io_sram_mask_8 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[8];
  assign io_sram_mask_9 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[9];
  assign io_sram_mask_10 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[10];
  assign io_sram_mask_11 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[11];
  assign io_sram_mask_12 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[12];
  assign io_sram_mask_13 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[13];
  assign io_sram_mask_14 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[14];
  assign io_sram_mask_15 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[15];
endmodule

module FabricArbiter(
  input          clock,
                 reset,
                 io_source_0_readDataAddr_valid,
  input  [31:0]  io_source_0_readDataAddr_bits,
  output [127:0] io_source_0_readData_bits,
  input          io_source_0_writeDataAddr_valid,
  input  [31:0]  io_source_0_writeDataAddr_bits,
  input  [127:0] io_source_0_writeDataBits,
  input  [15:0]  io_source_0_writeDataStrb,
  input          io_source_1_readDataAddr_valid,
  input  [31:0]  io_source_1_readDataAddr_bits,
  output         io_source_1_readData_valid,
  output [127:0] io_source_1_readData_bits,
  input          io_source_1_writeDataAddr_valid,
  input  [31:0]  io_source_1_writeDataAddr_bits,
  input  [127:0] io_source_1_writeDataBits,
  input  [15:0]  io_source_1_writeDataStrb,
  output         io_fabricBusy,
                 io_port_readDataAddr_valid,
  output [31:0]  io_port_readDataAddr_bits,
  input          io_port_readData_valid,
  input  [127:0] io_port_readData_bits,
  output         io_port_writeDataAddr_valid,
  output [31:0]  io_port_writeDataAddr_bits,
  output [127:0] io_port_writeDataBits,
  output [15:0]  io_port_writeDataStrb
);

  wire source0Valid = io_source_0_readDataAddr_valid | io_source_0_writeDataAddr_valid;
  assign io_source_0_readData_bits = io_port_readData_bits;
  assign io_source_1_readData_valid = io_port_readData_valid;
  assign io_source_1_readData_bits = io_port_readData_bits;
  assign io_fabricBusy = source0Valid;
  assign io_port_readDataAddr_valid =
    source0Valid ? io_source_0_readDataAddr_valid : io_source_1_readDataAddr_valid;
  assign io_port_readDataAddr_bits =
    source0Valid ? io_source_0_readDataAddr_bits : io_source_1_readDataAddr_bits;
  assign io_port_writeDataAddr_valid =
    source0Valid ? io_source_0_writeDataAddr_valid : io_source_1_writeDataAddr_valid;
  assign io_port_writeDataAddr_bits =
    source0Valid ? io_source_0_writeDataAddr_bits : io_source_1_writeDataAddr_bits;
  assign io_port_writeDataBits =
    source0Valid ? io_source_0_writeDataBits : io_source_1_writeDataBits;
  assign io_port_writeDataStrb =
    source0Valid ? io_source_0_writeDataStrb : io_source_1_writeDataStrb;
endmodule

module SRAM_512x128(
  input          clock,
  input  [8:0]   io_addr,
  input          io_enable,
                 io_write,
  input  [127:0] io_wdata,
  input  [15:0]  io_wmask,
  output [127:0] io_rdata
);

  Sram_512x128 sramModules_0 (
    .clock  (clock),
    .enable (io_enable),
    .write  (io_write),
    .addr   (io_addr),
    .wdata  (io_wdata),
    .wmask  (io_wmask),
    .rdata  (io_rdata)
  );
endmodule

module TCM128_1(
  input        clock,
  input  [8:0] io_addr,
  input        io_enable,
               io_write,
  input  [7:0] io_wdata_0,
               io_wdata_1,
               io_wdata_2,
               io_wdata_3,
               io_wdata_4,
               io_wdata_5,
               io_wdata_6,
               io_wdata_7,
               io_wdata_8,
               io_wdata_9,
               io_wdata_10,
               io_wdata_11,
               io_wdata_12,
               io_wdata_13,
               io_wdata_14,
               io_wdata_15,
  input        io_wmask_0,
               io_wmask_1,
               io_wmask_2,
               io_wmask_3,
               io_wmask_4,
               io_wmask_5,
               io_wmask_6,
               io_wmask_7,
               io_wmask_8,
               io_wmask_9,
               io_wmask_10,
               io_wmask_11,
               io_wmask_12,
               io_wmask_13,
               io_wmask_14,
               io_wmask_15,
  output [7:0] io_rdata_0,
               io_rdata_1,
               io_rdata_2,
               io_rdata_3,
               io_rdata_4,
               io_rdata_5,
               io_rdata_6,
               io_rdata_7,
               io_rdata_8,
               io_rdata_9,
               io_rdata_10,
               io_rdata_11,
               io_rdata_12,
               io_rdata_13,
               io_rdata_14,
               io_rdata_15
);

  wire [127:0] _sram_io_rdata;
  SRAM_512x128 sram (
    .clock     (clock),
    .io_addr   (io_addr),
    .io_enable (io_enable),
    .io_write  (io_write),
    .io_wdata
      ({io_wdata_15,
        io_wdata_14,
        io_wdata_13,
        io_wdata_12,
        io_wdata_11,
        io_wdata_10,
        io_wdata_9,
        io_wdata_8,
        io_wdata_7,
        io_wdata_6,
        io_wdata_5,
        io_wdata_4,
        io_wdata_3,
        io_wdata_2,
        io_wdata_1,
        io_wdata_0}),
    .io_wmask
      ({io_wmask_15,
        io_wmask_14,
        io_wmask_13,
        io_wmask_12,
        io_wmask_11,
        io_wmask_10,
        io_wmask_9,
        io_wmask_8,
        io_wmask_7,
        io_wmask_6,
        io_wmask_5,
        io_wmask_4,
        io_wmask_3,
        io_wmask_2,
        io_wmask_1,
        io_wmask_0}),
    .io_rdata  (_sram_io_rdata)
  );
  assign io_rdata_0 = _sram_io_rdata[127:120];
  assign io_rdata_1 = _sram_io_rdata[119:112];
  assign io_rdata_2 = _sram_io_rdata[111:104];
  assign io_rdata_3 = _sram_io_rdata[103:96];
  assign io_rdata_4 = _sram_io_rdata[95:88];
  assign io_rdata_5 = _sram_io_rdata[87:80];
  assign io_rdata_6 = _sram_io_rdata[79:72];
  assign io_rdata_7 = _sram_io_rdata[71:64];
  assign io_rdata_8 = _sram_io_rdata[63:56];
  assign io_rdata_9 = _sram_io_rdata[55:48];
  assign io_rdata_10 = _sram_io_rdata[47:40];
  assign io_rdata_11 = _sram_io_rdata[39:32];
  assign io_rdata_12 = _sram_io_rdata[31:24];
  assign io_rdata_13 = _sram_io_rdata[23:16];
  assign io_rdata_14 = _sram_io_rdata[15:8];
  assign io_rdata_15 = _sram_io_rdata[7:0];
endmodule

module SRAM_1(
  input          clock,
                 reset,
                 io_fabric_readDataAddr_valid,
  input  [31:0]  io_fabric_readDataAddr_bits,
  output         io_fabric_readData_valid,
  output [127:0] io_fabric_readData_bits,
  input          io_fabric_writeDataAddr_valid,
  input  [31:0]  io_fabric_writeDataAddr_bits,
  input  [127:0] io_fabric_writeDataBits,
  input  [15:0]  io_fabric_writeDataStrb,
  output [8:0]   io_sram_address,
  output         io_sram_enable,
                 io_sram_isWrite,
  input  [7:0]   io_sram_readData_0,
                 io_sram_readData_1,
                 io_sram_readData_2,
                 io_sram_readData_3,
                 io_sram_readData_4,
                 io_sram_readData_5,
                 io_sram_readData_6,
                 io_sram_readData_7,
                 io_sram_readData_8,
                 io_sram_readData_9,
                 io_sram_readData_10,
                 io_sram_readData_11,
                 io_sram_readData_12,
                 io_sram_readData_13,
                 io_sram_readData_14,
                 io_sram_readData_15,
  output [7:0]   io_sram_writeData_0,
                 io_sram_writeData_1,
                 io_sram_writeData_2,
                 io_sram_writeData_3,
                 io_sram_writeData_4,
                 io_sram_writeData_5,
                 io_sram_writeData_6,
                 io_sram_writeData_7,
                 io_sram_writeData_8,
                 io_sram_writeData_9,
                 io_sram_writeData_10,
                 io_sram_writeData_11,
                 io_sram_writeData_12,
                 io_sram_writeData_13,
                 io_sram_writeData_14,
                 io_sram_writeData_15,
  output         io_sram_mask_0,
                 io_sram_mask_1,
                 io_sram_mask_2,
                 io_sram_mask_3,
                 io_sram_mask_4,
                 io_sram_mask_5,
                 io_sram_mask_6,
                 io_sram_mask_7,
                 io_sram_mask_8,
                 io_sram_mask_9,
                 io_sram_mask_10,
                 io_sram_mask_11,
                 io_sram_mask_12,
                 io_sram_mask_13,
                 io_sram_mask_14,
                 io_sram_mask_15
);

  reg readIssued;
  always @(posedge clock or posedge reset) begin
    if (reset)
      readIssued <= 1'h0;
    else
      readIssued <= io_fabric_readDataAddr_valid & ~io_fabric_writeDataAddr_valid;
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        readIssued = _RANDOM[/*Zero width*/ 1'b0][0];
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        readIssued = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_fabric_readData_valid = readIssued;
  assign io_fabric_readData_bits =
    readIssued
      ? {io_sram_readData_0,
         io_sram_readData_1,
         io_sram_readData_2,
         io_sram_readData_3,
         io_sram_readData_4,
         io_sram_readData_5,
         io_sram_readData_6,
         io_sram_readData_7,
         io_sram_readData_8,
         io_sram_readData_9,
         io_sram_readData_10,
         io_sram_readData_11,
         io_sram_readData_12,
         io_sram_readData_13,
         io_sram_readData_14,
         io_sram_readData_15}
      : 128'h0;
  assign io_sram_address =
    io_fabric_writeDataAddr_valid
      ? io_fabric_writeDataAddr_bits[12:4]
      : io_fabric_readDataAddr_valid ? io_fabric_readDataAddr_bits[12:4] : 9'h0;
  assign io_sram_enable = io_fabric_readDataAddr_valid | io_fabric_writeDataAddr_valid;
  assign io_sram_isWrite = io_fabric_writeDataAddr_valid;
  assign io_sram_writeData_0 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[7:0] : 8'h0;
  assign io_sram_writeData_1 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[15:8] : 8'h0;
  assign io_sram_writeData_2 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[23:16] : 8'h0;
  assign io_sram_writeData_3 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[31:24] : 8'h0;
  assign io_sram_writeData_4 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[39:32] : 8'h0;
  assign io_sram_writeData_5 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[47:40] : 8'h0;
  assign io_sram_writeData_6 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[55:48] : 8'h0;
  assign io_sram_writeData_7 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[63:56] : 8'h0;
  assign io_sram_writeData_8 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[71:64] : 8'h0;
  assign io_sram_writeData_9 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[79:72] : 8'h0;
  assign io_sram_writeData_10 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[87:80] : 8'h0;
  assign io_sram_writeData_11 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[95:88] : 8'h0;
  assign io_sram_writeData_12 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[103:96] : 8'h0;
  assign io_sram_writeData_13 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[111:104] : 8'h0;
  assign io_sram_writeData_14 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[119:112] : 8'h0;
  assign io_sram_writeData_15 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[127:120] : 8'h0;
  assign io_sram_mask_0 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[0];
  assign io_sram_mask_1 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[1];
  assign io_sram_mask_2 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[2];
  assign io_sram_mask_3 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[3];
  assign io_sram_mask_4 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[4];
  assign io_sram_mask_5 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[5];
  assign io_sram_mask_6 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[6];
  assign io_sram_mask_7 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[7];
  assign io_sram_mask_8 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[8];
  assign io_sram_mask_9 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[9];
  assign io_sram_mask_10 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[10];
  assign io_sram_mask_11 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[11];
  assign io_sram_mask_12 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[12];
  assign io_sram_mask_13 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[13];
  assign io_sram_mask_14 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[14];
  assign io_sram_mask_15 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[15];
endmodule

module FabricMux(
  input          clock,
                 reset,
                 io_source_readDataAddr_valid,
  input  [31:0]  io_source_readDataAddr_bits,
  output         io_source_readData_valid,
  output [127:0] io_source_readData_bits,
  input          io_source_writeDataAddr_valid,
  input  [31:0]  io_source_writeDataAddr_bits,
  input  [127:0] io_source_writeDataBits,
  input  [15:0]  io_source_writeDataStrb,
  output         io_source_writeResp,
                 io_fabricBusy,
                 io_ports_0_readDataAddr_valid,
  output [31:0]  io_ports_0_readDataAddr_bits,
  input          io_ports_0_readData_valid,
  input  [127:0] io_ports_0_readData_bits,
  output         io_ports_0_writeDataAddr_valid,
  output [31:0]  io_ports_0_writeDataAddr_bits,
  output [127:0] io_ports_0_writeDataBits,
  output [15:0]  io_ports_0_writeDataStrb,
  output         io_ports_1_readDataAddr_valid,
  output [31:0]  io_ports_1_readDataAddr_bits,
  input          io_ports_1_readData_valid,
  input  [127:0] io_ports_1_readData_bits,
  output         io_ports_1_writeDataAddr_valid,
  output [31:0]  io_ports_1_writeDataAddr_bits,
  output [127:0] io_ports_1_writeDataBits,
  output [15:0]  io_ports_1_writeDataStrb,
  output [31:0]  io_ports_2_readDataAddr_bits,
  input          io_ports_2_readData_valid,
  input  [127:0] io_ports_2_readData_bits,
  output         io_ports_2_writeDataAddr_valid,
  output [31:0]  io_ports_2_writeDataAddr_bits,
  output [127:0] io_ports_2_writeDataBits,
  input          io_ports_2_writeResp,
                 io_periBusy_0,
                 io_periBusy_1
);

  wire        sourceValid = io_source_readDataAddr_valid | io_source_writeDataAddr_valid;
  wire [31:0] addr =
    io_source_readDataAddr_valid
      ? io_source_readDataAddr_bits
      : io_source_writeDataAddr_valid ? io_source_writeDataAddr_bits : 32'h0;
  wire        _selected_T_5 = sourceValid & addr < 32'h1000;
  wire        _selected_T_11 = sourceValid & (|(addr[31:16])) & addr < 32'h12000;
  wire        _selected_T_18_valid = sourceValid & addr > 32'h2FFFF & addr < 32'h31000;
  wire        selected_valid = _selected_T_5 | _selected_T_11 | _selected_T_18_valid;
  wire [1:0]  selected_bits =
    _selected_T_5 ? 2'h0 : _selected_T_11 ? 2'h1 : {_selected_T_18_valid, 1'h0};
  wire        _io_fabricBusy_T = selected_bits == 2'h0;
  wire        portSelected_0 = selected_valid & _io_fabricBusy_T & ~io_periBusy_0;
  wire        _io_fabricBusy_T_2 = selected_bits == 2'h1;
  wire        portSelected_1 = selected_valid & _io_fabricBusy_T_2 & ~io_periBusy_1;
  wire        _portSelected_T_7 = selected_valid & selected_bits == 2'h2;
  wire        io_ports_0_readDataAddr_valid_0 =
    portSelected_0 & io_source_readDataAddr_valid;
  wire        io_ports_1_readDataAddr_valid_0 =
    portSelected_1 & io_source_readDataAddr_valid;
  reg         lastReadSelected_valid;
  reg  [1:0]  lastReadSelected_bits;
  wire        _io_source_readData_T_1 =
    lastReadSelected_valid & lastReadSelected_bits == 2'h0;
  wire        _io_source_readData_T_3 =
    lastReadSelected_valid & lastReadSelected_bits == 2'h1;
  wire        _io_source_readData_T_5 =
    lastReadSelected_valid & lastReadSelected_bits == 2'h2;
  wire        _lastReadSelected_T_3_valid =
    _portSelected_T_7 & io_source_readDataAddr_valid;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      lastReadSelected_valid <= 1'h0;
      lastReadSelected_bits <= 2'h0;
    end
    else begin
      lastReadSelected_valid <=
        io_ports_0_readDataAddr_valid_0 | io_ports_1_readDataAddr_valid_0
        | _lastReadSelected_T_3_valid;
      lastReadSelected_bits <=
        io_ports_0_readDataAddr_valid_0
          ? 2'h0
          : io_ports_1_readDataAddr_valid_0 ? 2'h1 : {_lastReadSelected_T_3_valid, 1'h0};
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        lastReadSelected_valid = _RANDOM[/*Zero width*/ 1'b0][0];
        lastReadSelected_bits = _RANDOM[/*Zero width*/ 1'b0][2:1];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        lastReadSelected_valid = 1'h0;
        lastReadSelected_bits = 2'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_source_readData_valid =
    _io_source_readData_T_1
      ? io_ports_0_readData_valid
      : _io_source_readData_T_3
          ? io_ports_1_readData_valid
          : _io_source_readData_T_5 & io_ports_2_readData_valid;
  assign io_source_readData_bits =
    _io_source_readData_T_1
      ? io_ports_0_readData_bits
      : _io_source_readData_T_3
          ? io_ports_1_readData_bits
          : _io_source_readData_T_5 ? io_ports_2_readData_bits : 128'h0;
  assign io_source_writeResp =
    portSelected_0 | portSelected_1 | _portSelected_T_7 & io_ports_2_writeResp;
  assign io_fabricBusy =
    selected_valid & _io_fabricBusy_T
      ? io_periBusy_0
      : selected_valid & _io_fabricBusy_T_2 & io_periBusy_1;
  assign io_ports_0_readDataAddr_valid = io_ports_0_readDataAddr_valid_0;
  assign io_ports_0_readDataAddr_bits =
    portSelected_0 ? io_source_readDataAddr_bits : 32'h0;
  assign io_ports_0_writeDataAddr_valid = portSelected_0 & io_source_writeDataAddr_valid;
  assign io_ports_0_writeDataAddr_bits =
    portSelected_0 ? io_source_writeDataAddr_bits : 32'h0;
  assign io_ports_0_writeDataBits = portSelected_0 ? io_source_writeDataBits : 128'h0;
  assign io_ports_0_writeDataStrb = portSelected_0 ? io_source_writeDataStrb : 16'h0;
  assign io_ports_1_readDataAddr_valid = io_ports_1_readDataAddr_valid_0;
  assign io_ports_1_readDataAddr_bits =
    portSelected_1 ? io_source_readDataAddr_bits & 32'hFFFEFFFF : 32'h0;
  assign io_ports_1_writeDataAddr_valid = portSelected_1 & io_source_writeDataAddr_valid;
  assign io_ports_1_writeDataAddr_bits =
    portSelected_1 ? io_source_writeDataAddr_bits & 32'hFFFEFFFF : 32'h0;
  assign io_ports_1_writeDataBits = portSelected_1 ? io_source_writeDataBits : 128'h0;
  assign io_ports_1_writeDataStrb = portSelected_1 ? io_source_writeDataStrb : 16'h0;
  assign io_ports_2_readDataAddr_bits =
    _portSelected_T_7 ? io_source_readDataAddr_bits & 32'hFFFCFFFF : 32'h0;
  assign io_ports_2_writeDataAddr_valid =
    _portSelected_T_7 & io_source_writeDataAddr_valid;
  assign io_ports_2_writeDataAddr_bits =
    _portSelected_T_7 ? io_source_writeDataAddr_bits & 32'hFFFCFFFF : 32'h0;
  assign io_ports_2_writeDataBits = _portSelected_T_7 ? io_source_writeDataBits : 128'h0;
endmodule

module CoralNPURRArbiter(
  input         clock,
                reset,
  output        io_in_0_ready,
  input         io_in_0_valid,
  input  [31:0] io_in_0_bits_addr,
  input  [2:0]  io_in_0_bits_prot,
  input  [5:0]  io_in_0_bits_id,
  input  [7:0]  io_in_0_bits_len,
  input  [2:0]  io_in_0_bits_size,
  input  [1:0]  io_in_0_bits_burst,
  input         io_in_0_bits_lock,
  input  [3:0]  io_in_0_bits_cache,
                io_in_0_bits_qos,
                io_in_0_bits_region,
  output        io_in_1_ready,
  input         io_in_1_valid,
  input  [31:0] io_in_1_bits_addr,
  input  [2:0]  io_in_1_bits_prot,
  input  [5:0]  io_in_1_bits_id,
  input  [7:0]  io_in_1_bits_len,
  input  [2:0]  io_in_1_bits_size,
  input  [1:0]  io_in_1_bits_burst,
  input         io_in_1_bits_lock,
  input  [3:0]  io_in_1_bits_cache,
                io_in_1_bits_qos,
                io_in_1_bits_region,
  input         io_out_ready,
  output        io_out_valid,
  output [31:0] io_out_bits_addr,
  output [2:0]  io_out_bits_prot,
  output [5:0]  io_out_bits_id,
  output [7:0]  io_out_bits_len,
  output [2:0]  io_out_bits_size,
  output [1:0]  io_out_bits_burst,
  output        io_out_bits_lock,
  output [3:0]  io_out_bits_cache,
                io_out_bits_qos,
                io_out_bits_region,
  output        io_chosen
);

  wire io_chosen_choice;
  wire io_out_valid_0 = io_chosen_choice ? io_in_1_valid : io_in_0_valid;
  reg  ctrl_validMask_grantMask_lastGrant;
  wire ctrl_validMask_1 = io_in_1_valid & ~ctrl_validMask_grantMask_lastGrant;
  assign io_chosen_choice = ctrl_validMask_1 | ~io_in_0_valid;
  always @(posedge clock or posedge reset) begin
    if (reset)
      ctrl_validMask_grantMask_lastGrant <= 1'h0;
    else if (io_out_ready & io_out_valid_0)
      ctrl_validMask_grantMask_lastGrant <= io_chosen_choice;
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        ctrl_validMask_grantMask_lastGrant = _RANDOM[/*Zero width*/ 1'b0][0];
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        ctrl_validMask_grantMask_lastGrant = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_in_0_ready = ~ctrl_validMask_1 & io_out_ready;
  assign io_in_1_ready =
    (~ctrl_validMask_grantMask_lastGrant | ~(ctrl_validMask_1 | io_in_0_valid))
    & io_out_ready;
  assign io_out_valid = io_out_valid_0;
  assign io_out_bits_addr = io_chosen_choice ? io_in_1_bits_addr : io_in_0_bits_addr;
  assign io_out_bits_prot = io_chosen_choice ? io_in_1_bits_prot : io_in_0_bits_prot;
  assign io_out_bits_id = io_chosen_choice ? io_in_1_bits_id : io_in_0_bits_id;
  assign io_out_bits_len = io_chosen_choice ? io_in_1_bits_len : io_in_0_bits_len;
  assign io_out_bits_size = io_chosen_choice ? io_in_1_bits_size : io_in_0_bits_size;
  assign io_out_bits_burst = io_chosen_choice ? io_in_1_bits_burst : io_in_0_bits_burst;
  assign io_out_bits_lock = io_chosen_choice ? io_in_1_bits_lock : io_in_0_bits_lock;
  assign io_out_bits_cache = io_chosen_choice ? io_in_1_bits_cache : io_in_0_bits_cache;
  assign io_out_bits_qos = io_chosen_choice ? io_in_1_bits_qos : io_in_0_bits_qos;
  assign io_out_bits_region =
    io_chosen_choice ? io_in_1_bits_region : io_in_0_bits_region;
  assign io_chosen = io_chosen_choice;
endmodule

// VCS coverage exclude_module
module ram_2x67(
  input         R0_addr,
                R0_en,
                R0_clk,
  output [66:0] R0_data,
  input         W0_addr,
                W0_en,
                W0_clk,
  input  [66:0] W0_data
);

  reg [66:0] Memory[0:1];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [95:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          for (logic [6:0] j = 7'h0; j < 7'h60; j += 7'h20) begin
            _RANDOM_MEM[j +: 32] = `RANDOM;
          end
          Memory[i[0]] = _RANDOM_MEM[66:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 67'bx;
endmodule

module Queue2_AxiAddress(
  input         clock,
                reset,
  output        io_enq_ready,
  input         io_enq_valid,
  input  [31:0] io_enq_bits_addr,
  input  [2:0]  io_enq_bits_prot,
  input  [5:0]  io_enq_bits_id,
  input  [7:0]  io_enq_bits_len,
  input  [2:0]  io_enq_bits_size,
  input  [1:0]  io_enq_bits_burst,
  input         io_enq_bits_lock,
  input  [3:0]  io_enq_bits_cache,
                io_enq_bits_qos,
                io_enq_bits_region,
  input         io_deq_ready,
  output        io_deq_valid,
  output [31:0] io_deq_bits_addr,
  output [2:0]  io_deq_bits_prot,
  output [5:0]  io_deq_bits_id,
  output [7:0]  io_deq_bits_len,
  output [2:0]  io_deq_bits_size,
  output [1:0]  io_deq_bits_burst,
  output        io_deq_bits_lock,
  output [3:0]  io_deq_bits_cache,
                io_deq_bits_qos,
                io_deq_bits_region
);

  wire [66:0] _ram_ext_R0_data;
  reg         wrap;
  reg         wrap_1;
  reg         maybe_full;
  wire        ptr_match = wrap == wrap_1;
  wire        empty = ptr_match & ~maybe_full;
  wire        full = ptr_match & maybe_full;
  wire        do_enq = ~full & io_enq_valid;
  wire        do_deq = io_deq_ready & ~empty;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      wrap <= 1'h0;
      wrap_1 <= 1'h0;
      maybe_full <= 1'h0;
    end
    else begin
      if (do_enq)
        wrap <= wrap - 1'h1;
      if (do_deq)
        wrap_1 <= wrap_1 - 1'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        wrap = _RANDOM[/*Zero width*/ 1'b0][0];
        wrap_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][2];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        wrap = 1'h0;
        wrap_1 = 1'h0;
        maybe_full = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_2x67 ram_ext (
    .R0_addr (wrap_1),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (wrap),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data
      ({io_enq_bits_addr,
        io_enq_bits_prot,
        io_enq_bits_id,
        io_enq_bits_len,
        io_enq_bits_size,
        io_enq_bits_burst,
        io_enq_bits_lock,
        io_enq_bits_cache,
        io_enq_bits_qos,
        io_enq_bits_region})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_addr = _ram_ext_R0_data[66:35];
  assign io_deq_bits_prot = _ram_ext_R0_data[34:32];
  assign io_deq_bits_id = _ram_ext_R0_data[31:26];
  assign io_deq_bits_len = _ram_ext_R0_data[25:18];
  assign io_deq_bits_size = _ram_ext_R0_data[17:15];
  assign io_deq_bits_burst = _ram_ext_R0_data[14:13];
  assign io_deq_bits_lock = _ram_ext_R0_data[12];
  assign io_deq_bits_cache = _ram_ext_R0_data[11:8];
  assign io_deq_bits_qos = _ram_ext_R0_data[7:4];
  assign io_deq_bits_region = _ram_ext_R0_data[3:0];
endmodule

module Queue1_RWAxiAddress(
  input         clock,
                reset,
  output        io_enq_ready,
  input         io_enq_valid,
  input  [31:0] io_enq_bits_addr_addr,
  input  [2:0]  io_enq_bits_addr_prot,
  input  [5:0]  io_enq_bits_addr_id,
  input  [7:0]  io_enq_bits_addr_len,
  input  [2:0]  io_enq_bits_addr_size,
  input  [1:0]  io_enq_bits_addr_burst,
  input         io_enq_bits_addr_lock,
  input  [3:0]  io_enq_bits_addr_cache,
                io_enq_bits_addr_qos,
                io_enq_bits_addr_region,
  input         io_enq_bits_write,
                io_deq_ready,
  output        io_deq_valid,
  output [31:0] io_deq_bits_addr_addr,
  output [5:0]  io_deq_bits_addr_id,
  output [7:0]  io_deq_bits_addr_len,
  output [2:0]  io_deq_bits_addr_size,
  output [1:0]  io_deq_bits_addr_burst,
  output        io_deq_bits_write
);

  reg  [67:0] ram;
  wire        io_enq_ready_0;
  reg         full;
  wire        do_enq = io_enq_ready_0 & io_enq_valid;
  assign io_enq_ready_0 = io_deq_ready | ~full;
  always @(posedge clock or posedge reset) begin
    if (reset)
      full <= 1'h0;
    else if (~(do_enq == (io_deq_ready & full)))
      full <= do_enq;
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (do_enq)
      ram <=
        {io_enq_bits_addr_addr,
         io_enq_bits_addr_prot,
         io_enq_bits_addr_id,
         io_enq_bits_addr_len,
         io_enq_bits_addr_size,
         io_enq_bits_addr_burst,
         io_enq_bits_addr_lock,
         io_enq_bits_addr_cache,
         io_enq_bits_addr_qos,
         io_enq_bits_addr_region,
         io_enq_bits_write};
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:2];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        full = _RANDOM[2'h0][0];
        ram = {_RANDOM[2'h0][31:1], _RANDOM[2'h1], _RANDOM[2'h2][4:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        full = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_enq_ready = io_enq_ready_0;
  assign io_deq_valid = full;
  assign io_deq_bits_addr_addr = ram[67:36];
  assign io_deq_bits_addr_id = ram[32:27];
  assign io_deq_bits_addr_len = ram[26:19];
  assign io_deq_bits_addr_size = ram[18:16];
  assign io_deq_bits_addr_burst = ram[15:14];
  assign io_deq_bits_write = ram[0];
endmodule

// VCS coverage exclude_module
module ram_3x145(
  input  [1:0]   R0_addr,
  input          R0_en,
                 R0_clk,
  output [144:0] R0_data,
  input  [1:0]   W0_addr,
  input          W0_en,
                 W0_clk,
  input  [144:0] W0_data
);

  reg [144:0] Memory[0:2];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [159:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin
          for (logic [7:0] j = 8'h0; j < 8'hA0; j += 8'h20) begin
            _RANDOM_MEM[j +: 32] = `RANDOM;
          end
          Memory[i] = _RANDOM_MEM[144:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 145'bx;
endmodule

module Queue3_AxiWriteData(
  input          clock,
                 reset,
  output         io_enq_ready,
  input          io_enq_valid,
  input  [127:0] io_enq_bits_data,
  input          io_enq_bits_last,
  input  [15:0]  io_enq_bits_strb,
  input          io_deq_ready,
  output         io_deq_valid,
  output [127:0] io_deq_bits_data,
  output         io_deq_bits_last,
  output [15:0]  io_deq_bits_strb
);

  wire [144:0] _ram_ext_R0_data;
  reg  [1:0]   enq_ptr_value;
  reg  [1:0]   deq_ptr_value;
  reg          maybe_full;
  wire         ptr_match = enq_ptr_value == deq_ptr_value;
  wire         empty = ptr_match & ~maybe_full;
  wire         full = ptr_match & maybe_full;
  wire         do_enq = ~full & io_enq_valid;
  wire         do_deq = io_deq_ready & ~empty;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      enq_ptr_value <= 2'h0;
      deq_ptr_value <= 2'h0;
      maybe_full <= 1'h0;
    end
    else begin
      if (do_enq)
        enq_ptr_value <= enq_ptr_value == 2'h2 ? 2'h0 : enq_ptr_value + 2'h1;
      if (do_deq)
        deq_ptr_value <= deq_ptr_value == 2'h2 ? 2'h0 : deq_ptr_value + 2'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        enq_ptr_value = _RANDOM[/*Zero width*/ 1'b0][1:0];
        deq_ptr_value = _RANDOM[/*Zero width*/ 1'b0][3:2];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][4];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        enq_ptr_value = 2'h0;
        deq_ptr_value = 2'h0;
        maybe_full = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_3x145 ram_ext (
    .R0_addr (deq_ptr_value),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (enq_ptr_value),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({io_enq_bits_data, io_enq_bits_last, io_enq_bits_strb})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_data = _ram_ext_R0_data[144:17];
  assign io_deq_bits_last = _ram_ext_R0_data[16];
  assign io_deq_bits_strb = _ram_ext_R0_data[15:0];
endmodule

// VCS coverage exclude_module
module ram_2x8(
  input        R0_addr,
               R0_en,
               R0_clk,
  output [7:0] R0_data,
  input        W0_addr,
               W0_en,
               W0_clk,
  input  [7:0] W0_data
);

  reg [7:0] Memory[0:1];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [31:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          _RANDOM_MEM = `RANDOM;
          Memory[i[0]] = _RANDOM_MEM[7:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 8'bx;
endmodule

module Queue2_AxiWriteResponse(
  input        clock,
               reset,
  output       io_enq_ready,
  input        io_enq_valid,
  input  [5:0] io_enq_bits_id,
  input  [1:0] io_enq_bits_resp,
  input        io_deq_ready,
  output       io_deq_valid,
  output [5:0] io_deq_bits_id,
  output [1:0] io_deq_bits_resp
);

  wire [7:0] _ram_ext_R0_data;
  reg        wrap;
  reg        wrap_1;
  reg        maybe_full;
  wire       ptr_match = wrap == wrap_1;
  wire       empty = ptr_match & ~maybe_full;
  wire       full = ptr_match & maybe_full;
  wire       do_enq = ~full & io_enq_valid;
  wire       do_deq = io_deq_ready & ~empty;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      wrap <= 1'h0;
      wrap_1 <= 1'h0;
      maybe_full <= 1'h0;
    end
    else begin
      if (do_enq)
        wrap <= wrap - 1'h1;
      if (do_deq)
        wrap_1 <= wrap_1 - 1'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        wrap = _RANDOM[/*Zero width*/ 1'b0][0];
        wrap_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][2];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        wrap = 1'h0;
        wrap_1 = 1'h0;
        maybe_full = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_2x8 ram_ext (
    .R0_addr (wrap_1),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (wrap),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({io_enq_bits_id, io_enq_bits_resp})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_id = _ram_ext_R0_data[7:2];
  assign io_deq_bits_resp = _ram_ext_R0_data[1:0];
endmodule

// VCS coverage exclude_module
module ram_3x137(
  input  [1:0]   R0_addr,
  input          R0_en,
                 R0_clk,
  output [136:0] R0_data,
  input  [1:0]   W0_addr,
  input          W0_en,
                 W0_clk,
  input  [136:0] W0_data
);

  reg [136:0] Memory[0:2];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [159:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin
          for (logic [7:0] j = 8'h0; j < 8'hA0; j += 8'h20) begin
            _RANDOM_MEM[j +: 32] = `RANDOM;
          end
          Memory[i] = _RANDOM_MEM[136:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 137'bx;
endmodule

module Queue3_AxiReadData(
  input          clock,
                 reset,
  output         io_enq_ready,
  input          io_enq_valid,
  input  [127:0] io_enq_bits_data,
  input  [5:0]   io_enq_bits_id,
  input  [1:0]   io_enq_bits_resp,
  input          io_enq_bits_last,
                 io_deq_ready,
  output         io_deq_valid,
  output [127:0] io_deq_bits_data,
  output [5:0]   io_deq_bits_id,
  output [1:0]   io_deq_bits_resp,
  output         io_deq_bits_last,
  output [1:0]   io_count
);

  wire [136:0] _ram_ext_R0_data;
  reg  [1:0]   enq_ptr_value;
  reg  [1:0]   deq_ptr_value;
  reg          maybe_full;
  wire         ptr_match = enq_ptr_value == deq_ptr_value;
  wire         empty = ptr_match & ~maybe_full;
  wire         full = ptr_match & maybe_full;
  wire         do_enq = ~full & io_enq_valid;
  wire [1:0]   _ptr_diff_T = enq_ptr_value - deq_ptr_value;
  wire         do_deq = io_deq_ready & ~empty;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      enq_ptr_value <= 2'h0;
      deq_ptr_value <= 2'h0;
      maybe_full <= 1'h0;
    end
    else begin
      if (do_enq)
        enq_ptr_value <= enq_ptr_value == 2'h2 ? 2'h0 : enq_ptr_value + 2'h1;
      if (do_deq)
        deq_ptr_value <= deq_ptr_value == 2'h2 ? 2'h0 : deq_ptr_value + 2'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        enq_ptr_value = _RANDOM[/*Zero width*/ 1'b0][1:0];
        deq_ptr_value = _RANDOM[/*Zero width*/ 1'b0][3:2];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][4];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        enq_ptr_value = 2'h0;
        deq_ptr_value = 2'h0;
        maybe_full = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_3x137 ram_ext (
    .R0_addr (deq_ptr_value),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (enq_ptr_value),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({io_enq_bits_data, io_enq_bits_id, io_enq_bits_resp, io_enq_bits_last})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_data = _ram_ext_R0_data[136:9];
  assign io_deq_bits_id = _ram_ext_R0_data[8:3];
  assign io_deq_bits_resp = _ram_ext_R0_data[2:1];
  assign io_deq_bits_last = _ram_ext_R0_data[0];
  assign io_count =
    ptr_match
      ? {2{maybe_full}}
      : deq_ptr_value > enq_ptr_value ? _ptr_diff_T - 2'h1 : _ptr_diff_T;
endmodule

module AxiSlave(
  input          clock,
                 reset,
  output         io_axi_write_addr_ready,
  input          io_axi_write_addr_valid,
  input  [31:0]  io_axi_write_addr_bits_addr,
  input  [2:0]   io_axi_write_addr_bits_prot,
  input  [5:0]   io_axi_write_addr_bits_id,
  input  [7:0]   io_axi_write_addr_bits_len,
  input  [2:0]   io_axi_write_addr_bits_size,
  input  [1:0]   io_axi_write_addr_bits_burst,
  input          io_axi_write_addr_bits_lock,
  input  [3:0]   io_axi_write_addr_bits_cache,
                 io_axi_write_addr_bits_qos,
                 io_axi_write_addr_bits_region,
  output         io_axi_write_data_ready,
  input          io_axi_write_data_valid,
  input  [127:0] io_axi_write_data_bits_data,
  input          io_axi_write_data_bits_last,
  input  [15:0]  io_axi_write_data_bits_strb,
  input          io_axi_write_resp_ready,
  output         io_axi_write_resp_valid,
  output [5:0]   io_axi_write_resp_bits_id,
  output [1:0]   io_axi_write_resp_bits_resp,
  output         io_axi_read_addr_ready,
  input          io_axi_read_addr_valid,
  input  [31:0]  io_axi_read_addr_bits_addr,
  input  [2:0]   io_axi_read_addr_bits_prot,
  input  [5:0]   io_axi_read_addr_bits_id,
  input  [7:0]   io_axi_read_addr_bits_len,
  input  [2:0]   io_axi_read_addr_bits_size,
  input  [1:0]   io_axi_read_addr_bits_burst,
  input          io_axi_read_addr_bits_lock,
  input  [3:0]   io_axi_read_addr_bits_cache,
                 io_axi_read_addr_bits_qos,
                 io_axi_read_addr_bits_region,
  input          io_axi_read_data_ready,
  output         io_axi_read_data_valid,
  output [127:0] io_axi_read_data_bits_data,
  output [5:0]   io_axi_read_data_bits_id,
  output [1:0]   io_axi_read_data_bits_resp,
  output         io_axi_read_data_bits_last,
                 io_fabric_readDataAddr_valid,
  output [31:0]  io_fabric_readDataAddr_bits,
  input          io_fabric_readData_valid,
  input  [127:0] io_fabric_readData_bits,
  output         io_fabric_writeDataAddr_valid,
  output [31:0]  io_fabric_writeDataAddr_bits,
  output [127:0] io_fabric_writeDataBits,
  output [15:0]  io_fabric_writeDataStrb,
  input          io_fabric_writeResp,
                 io_periBusy
);

  wire        _readDataQueue_io_enq_ready;
  wire [1:0]  _readDataQueue_io_count;
  wire        _io_axi_write_resp_q_io_enq_ready;
  wire        _writeData_q_io_deq_valid;
  wire        _writeData_q_io_deq_bits_last;
  wire        _axiAddrCmd_q_io_enq_ready;
  wire        _axiAddrCmd_q_io_deq_valid;
  wire [31:0] _axiAddrCmd_q_io_deq_bits_addr_addr;
  wire [5:0]  _axiAddrCmd_q_io_deq_bits_addr_id;
  wire [7:0]  _axiAddrCmd_q_io_deq_bits_addr_len;
  wire [2:0]  _axiAddrCmd_q_io_deq_bits_addr_size;
  wire [1:0]  _axiAddrCmd_q_io_deq_bits_addr_burst;
  wire        _axiAddrCmd_q_io_deq_bits_write;
  wire        _addrArbiter_io_in_1_q_io_deq_valid;
  wire [31:0] _addrArbiter_io_in_1_q_io_deq_bits_addr;
  wire [2:0]  _addrArbiter_io_in_1_q_io_deq_bits_prot;
  wire [5:0]  _addrArbiter_io_in_1_q_io_deq_bits_id;
  wire [7:0]  _addrArbiter_io_in_1_q_io_deq_bits_len;
  wire [2:0]  _addrArbiter_io_in_1_q_io_deq_bits_size;
  wire [1:0]  _addrArbiter_io_in_1_q_io_deq_bits_burst;
  wire        _addrArbiter_io_in_1_q_io_deq_bits_lock;
  wire [3:0]  _addrArbiter_io_in_1_q_io_deq_bits_cache;
  wire [3:0]  _addrArbiter_io_in_1_q_io_deq_bits_qos;
  wire [3:0]  _addrArbiter_io_in_1_q_io_deq_bits_region;
  wire        _addrArbiter_io_in_0_q_io_deq_valid;
  wire [31:0] _addrArbiter_io_in_0_q_io_deq_bits_addr;
  wire [2:0]  _addrArbiter_io_in_0_q_io_deq_bits_prot;
  wire [5:0]  _addrArbiter_io_in_0_q_io_deq_bits_id;
  wire [7:0]  _addrArbiter_io_in_0_q_io_deq_bits_len;
  wire [2:0]  _addrArbiter_io_in_0_q_io_deq_bits_size;
  wire [1:0]  _addrArbiter_io_in_0_q_io_deq_bits_burst;
  wire        _addrArbiter_io_in_0_q_io_deq_bits_lock;
  wire [3:0]  _addrArbiter_io_in_0_q_io_deq_bits_cache;
  wire [3:0]  _addrArbiter_io_in_0_q_io_deq_bits_qos;
  wire [3:0]  _addrArbiter_io_in_0_q_io_deq_bits_region;
  wire        _addrArbiter_io_in_0_ready;
  wire        _addrArbiter_io_in_1_ready;
  wire        _addrArbiter_io_out_valid;
  wire [31:0] _addrArbiter_io_out_bits_addr;
  wire [2:0]  _addrArbiter_io_out_bits_prot;
  wire [5:0]  _addrArbiter_io_out_bits_id;
  wire [7:0]  _addrArbiter_io_out_bits_len;
  wire [2:0]  _addrArbiter_io_out_bits_size;
  wire [1:0]  _addrArbiter_io_out_bits_burst;
  wire        _addrArbiter_io_out_bits_lock;
  wire [3:0]  _addrArbiter_io_out_bits_cache;
  wire [3:0]  _addrArbiter_io_out_bits_qos;
  wire [3:0]  _addrArbiter_io_out_bits_region;
  wire        _addrArbiter_io_chosen;
  wire        writeActive = _axiAddrCmd_q_io_deq_valid & _axiAddrCmd_q_io_deq_bits_write;
  wire        readActive = _axiAddrCmd_q_io_deq_valid & ~_axiAddrCmd_q_io_deq_bits_write;
  reg  [31:0] cmdAddr;
  wire        maybeWriteData =
    writeActive & _writeData_q_io_deq_valid & _io_axi_write_resp_q_io_enq_ready;
  wire        writeData_q_io_deq_ready = maybeWriteData & ~io_periBusy;
  wire        writeResponse_valid =
    writeData_q_io_deq_ready & _writeData_q_io_deq_bits_last;
  reg         readIssued_valid;
  reg  [5:0]  readIssued_bits_id;
  reg         readIssued_bits_last;
  reg  [8:0]  readsIssued;
  wire [1:0]  _maybeIssueRead_T = 2'h3 - _readDataQueue_io_count;
  wire        maybeIssueRead = readActive & _maybeIssueRead_T[1];
  wire        issueRead = maybeIssueRead & ~io_periBusy;
  wire        lastRead = readsIssued == {1'h0, _axiAddrCmd_q_io_deq_bits_addr_len};
  wire        axiAddrCmd_q_io_deq_ready =
    writeActive ? writeResponse_valid : readActive & issueRead & lastRead;
  wire [31:0] cmdAddrBase =
    _axiAddrCmd_q_io_deq_bits_addr_addr
    & {25'h1FFFFFF,
       _axiAddrCmd_q_io_deq_bits_addr_size != 3'h7,
       _axiAddrCmd_q_io_deq_bits_addr_size[2:1] != 2'h3,
       _axiAddrCmd_q_io_deq_bits_addr_size < 3'h5,
       ~(_axiAddrCmd_q_io_deq_bits_addr_size[2]),
       _axiAddrCmd_q_io_deq_bits_addr_size < 3'h3,
       _axiAddrCmd_q_io_deq_bits_addr_size < 3'h2,
       _axiAddrCmd_q_io_deq_bits_addr_size == 3'h0};
  wire [31:0] _GEN = {24'h0, 8'h1 << _axiAddrCmd_q_io_deq_bits_addr_size};
  wire [31:0] _addrNext_newAddr_T_1 = cmdAddr + _GEN;
  wire        _addrNext_T = _axiAddrCmd_q_io_deq_bits_addr_burst == 2'h0;
  wire        _addrNext_T_2 = _axiAddrCmd_q_io_deq_bits_addr_burst == 2'h1;
  wire        _addrNext_T_7 = _axiAddrCmd_q_io_deq_bits_addr_burst == 2'h2;
  wire        validBurst =
    _axiAddrCmd_q_io_deq_valid & (_addrNext_T | _addrNext_T_2 | _addrNext_T_7);
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      cmdAddr <= 32'h0;
      readIssued_valid <= 1'h0;
      readIssued_bits_id <= 6'h0;
      readIssued_bits_last <= 1'h0;
      readsIssued <= 9'h0;
    end
    else begin
      if (_axiAddrCmd_q_io_enq_ready & _addrArbiter_io_out_valid)
        cmdAddr <= _addrArbiter_io_out_bits_addr;
      else if (~(maybeWriteData & ~io_periBusy | maybeIssueRead & ~io_periBusy)
               | validBurst & _addrNext_T) begin
      end
      else if (validBurst & _addrNext_T_2)
        cmdAddr <= cmdAddr + _GEN;
      else if (validBurst & _addrNext_T_7)
        cmdAddr <=
          _addrNext_newAddr_T_1 >= cmdAddrBase + 32'h10
            ? cmdAddrBase
            : _addrNext_newAddr_T_1;
      readIssued_valid <= issueRead;
      readIssued_bits_id <= _axiAddrCmd_q_io_deq_bits_addr_id;
      readIssued_bits_last <= lastRead;
      readsIssued <=
        axiAddrCmd_q_io_deq_ready & _axiAddrCmd_q_io_deq_valid
          ? 9'h0
          : readsIssued + {8'h0, issueRead};
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:1];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          _RANDOM[i[0]] = `RANDOM;
        end
        cmdAddr = _RANDOM[1'h0];
        readIssued_valid = _RANDOM[1'h1][0];
        readIssued_bits_id = _RANDOM[1'h1][6:1];
        readIssued_bits_last = _RANDOM[1'h1][7];
        readsIssued = _RANDOM[1'h1][16:8];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        cmdAddr = 32'h0;
        readIssued_valid = 1'h0;
        readIssued_bits_id = 6'h0;
        readIssued_bits_last = 1'h0;
        readsIssued = 9'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  CoralNPURRArbiter addrArbiter (
    .clock               (clock),
    .reset               (reset),
    .io_in_0_ready       (_addrArbiter_io_in_0_ready),
    .io_in_0_valid       (_addrArbiter_io_in_0_q_io_deq_valid),
    .io_in_0_bits_addr   (_addrArbiter_io_in_0_q_io_deq_bits_addr),
    .io_in_0_bits_prot   (_addrArbiter_io_in_0_q_io_deq_bits_prot),
    .io_in_0_bits_id     (_addrArbiter_io_in_0_q_io_deq_bits_id),
    .io_in_0_bits_len    (_addrArbiter_io_in_0_q_io_deq_bits_len),
    .io_in_0_bits_size   (_addrArbiter_io_in_0_q_io_deq_bits_size),
    .io_in_0_bits_burst  (_addrArbiter_io_in_0_q_io_deq_bits_burst),
    .io_in_0_bits_lock   (_addrArbiter_io_in_0_q_io_deq_bits_lock),
    .io_in_0_bits_cache  (_addrArbiter_io_in_0_q_io_deq_bits_cache),
    .io_in_0_bits_qos    (_addrArbiter_io_in_0_q_io_deq_bits_qos),
    .io_in_0_bits_region (_addrArbiter_io_in_0_q_io_deq_bits_region),
    .io_in_1_ready       (_addrArbiter_io_in_1_ready),
    .io_in_1_valid       (_addrArbiter_io_in_1_q_io_deq_valid),
    .io_in_1_bits_addr   (_addrArbiter_io_in_1_q_io_deq_bits_addr),
    .io_in_1_bits_prot   (_addrArbiter_io_in_1_q_io_deq_bits_prot),
    .io_in_1_bits_id     (_addrArbiter_io_in_1_q_io_deq_bits_id),
    .io_in_1_bits_len    (_addrArbiter_io_in_1_q_io_deq_bits_len),
    .io_in_1_bits_size   (_addrArbiter_io_in_1_q_io_deq_bits_size),
    .io_in_1_bits_burst  (_addrArbiter_io_in_1_q_io_deq_bits_burst),
    .io_in_1_bits_lock   (_addrArbiter_io_in_1_q_io_deq_bits_lock),
    .io_in_1_bits_cache  (_addrArbiter_io_in_1_q_io_deq_bits_cache),
    .io_in_1_bits_qos    (_addrArbiter_io_in_1_q_io_deq_bits_qos),
    .io_in_1_bits_region (_addrArbiter_io_in_1_q_io_deq_bits_region),
    .io_out_ready        (_axiAddrCmd_q_io_enq_ready),
    .io_out_valid        (_addrArbiter_io_out_valid),
    .io_out_bits_addr    (_addrArbiter_io_out_bits_addr),
    .io_out_bits_prot    (_addrArbiter_io_out_bits_prot),
    .io_out_bits_id      (_addrArbiter_io_out_bits_id),
    .io_out_bits_len     (_addrArbiter_io_out_bits_len),
    .io_out_bits_size    (_addrArbiter_io_out_bits_size),
    .io_out_bits_burst   (_addrArbiter_io_out_bits_burst),
    .io_out_bits_lock    (_addrArbiter_io_out_bits_lock),
    .io_out_bits_cache   (_addrArbiter_io_out_bits_cache),
    .io_out_bits_qos     (_addrArbiter_io_out_bits_qos),
    .io_out_bits_region  (_addrArbiter_io_out_bits_region),
    .io_chosen           (_addrArbiter_io_chosen)
  );
  Queue2_AxiAddress addrArbiter_io_in_0_q (
    .clock              (clock),
    .reset              (reset),
    .io_enq_ready       (io_axi_read_addr_ready),
    .io_enq_valid       (io_axi_read_addr_valid),
    .io_enq_bits_addr   (io_axi_read_addr_bits_addr),
    .io_enq_bits_prot   (io_axi_read_addr_bits_prot),
    .io_enq_bits_id     (io_axi_read_addr_bits_id),
    .io_enq_bits_len    (io_axi_read_addr_bits_len),
    .io_enq_bits_size   (io_axi_read_addr_bits_size),
    .io_enq_bits_burst  (io_axi_read_addr_bits_burst),
    .io_enq_bits_lock   (io_axi_read_addr_bits_lock),
    .io_enq_bits_cache  (io_axi_read_addr_bits_cache),
    .io_enq_bits_qos    (io_axi_read_addr_bits_qos),
    .io_enq_bits_region (io_axi_read_addr_bits_region),
    .io_deq_ready       (_addrArbiter_io_in_0_ready),
    .io_deq_valid       (_addrArbiter_io_in_0_q_io_deq_valid),
    .io_deq_bits_addr   (_addrArbiter_io_in_0_q_io_deq_bits_addr),
    .io_deq_bits_prot   (_addrArbiter_io_in_0_q_io_deq_bits_prot),
    .io_deq_bits_id     (_addrArbiter_io_in_0_q_io_deq_bits_id),
    .io_deq_bits_len    (_addrArbiter_io_in_0_q_io_deq_bits_len),
    .io_deq_bits_size   (_addrArbiter_io_in_0_q_io_deq_bits_size),
    .io_deq_bits_burst  (_addrArbiter_io_in_0_q_io_deq_bits_burst),
    .io_deq_bits_lock   (_addrArbiter_io_in_0_q_io_deq_bits_lock),
    .io_deq_bits_cache  (_addrArbiter_io_in_0_q_io_deq_bits_cache),
    .io_deq_bits_qos    (_addrArbiter_io_in_0_q_io_deq_bits_qos),
    .io_deq_bits_region (_addrArbiter_io_in_0_q_io_deq_bits_region)
  );
  Queue2_AxiAddress addrArbiter_io_in_1_q (
    .clock              (clock),
    .reset              (reset),
    .io_enq_ready       (io_axi_write_addr_ready),
    .io_enq_valid       (io_axi_write_addr_valid),
    .io_enq_bits_addr   (io_axi_write_addr_bits_addr),
    .io_enq_bits_prot   (io_axi_write_addr_bits_prot),
    .io_enq_bits_id     (io_axi_write_addr_bits_id),
    .io_enq_bits_len    (io_axi_write_addr_bits_len),
    .io_enq_bits_size   (io_axi_write_addr_bits_size),
    .io_enq_bits_burst  (io_axi_write_addr_bits_burst),
    .io_enq_bits_lock   (io_axi_write_addr_bits_lock),
    .io_enq_bits_cache  (io_axi_write_addr_bits_cache),
    .io_enq_bits_qos    (io_axi_write_addr_bits_qos),
    .io_enq_bits_region (io_axi_write_addr_bits_region),
    .io_deq_ready       (_addrArbiter_io_in_1_ready),
    .io_deq_valid       (_addrArbiter_io_in_1_q_io_deq_valid),
    .io_deq_bits_addr   (_addrArbiter_io_in_1_q_io_deq_bits_addr),
    .io_deq_bits_prot   (_addrArbiter_io_in_1_q_io_deq_bits_prot),
    .io_deq_bits_id     (_addrArbiter_io_in_1_q_io_deq_bits_id),
    .io_deq_bits_len    (_addrArbiter_io_in_1_q_io_deq_bits_len),
    .io_deq_bits_size   (_addrArbiter_io_in_1_q_io_deq_bits_size),
    .io_deq_bits_burst  (_addrArbiter_io_in_1_q_io_deq_bits_burst),
    .io_deq_bits_lock   (_addrArbiter_io_in_1_q_io_deq_bits_lock),
    .io_deq_bits_cache  (_addrArbiter_io_in_1_q_io_deq_bits_cache),
    .io_deq_bits_qos    (_addrArbiter_io_in_1_q_io_deq_bits_qos),
    .io_deq_bits_region (_addrArbiter_io_in_1_q_io_deq_bits_region)
  );
  Queue1_RWAxiAddress axiAddrCmd_q (
    .clock                   (clock),
    .reset                   (reset),
    .io_enq_ready            (_axiAddrCmd_q_io_enq_ready),
    .io_enq_valid            (_addrArbiter_io_out_valid),
    .io_enq_bits_addr_addr   (_addrArbiter_io_out_bits_addr),
    .io_enq_bits_addr_prot   (_addrArbiter_io_out_bits_prot),
    .io_enq_bits_addr_id     (_addrArbiter_io_out_bits_id),
    .io_enq_bits_addr_len    (_addrArbiter_io_out_bits_len),
    .io_enq_bits_addr_size   (_addrArbiter_io_out_bits_size),
    .io_enq_bits_addr_burst  (_addrArbiter_io_out_bits_burst),
    .io_enq_bits_addr_lock   (_addrArbiter_io_out_bits_lock),
    .io_enq_bits_addr_cache  (_addrArbiter_io_out_bits_cache),
    .io_enq_bits_addr_qos    (_addrArbiter_io_out_bits_qos),
    .io_enq_bits_addr_region (_addrArbiter_io_out_bits_region),
    .io_enq_bits_write       (_addrArbiter_io_chosen),
    .io_deq_ready            (axiAddrCmd_q_io_deq_ready),
    .io_deq_valid            (_axiAddrCmd_q_io_deq_valid),
    .io_deq_bits_addr_addr   (_axiAddrCmd_q_io_deq_bits_addr_addr),
    .io_deq_bits_addr_id     (_axiAddrCmd_q_io_deq_bits_addr_id),
    .io_deq_bits_addr_len    (_axiAddrCmd_q_io_deq_bits_addr_len),
    .io_deq_bits_addr_size   (_axiAddrCmd_q_io_deq_bits_addr_size),
    .io_deq_bits_addr_burst  (_axiAddrCmd_q_io_deq_bits_addr_burst),
    .io_deq_bits_write       (_axiAddrCmd_q_io_deq_bits_write)
  );
  Queue3_AxiWriteData writeData_q (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (io_axi_write_data_ready),
    .io_enq_valid     (io_axi_write_data_valid),
    .io_enq_bits_data (io_axi_write_data_bits_data),
    .io_enq_bits_last (io_axi_write_data_bits_last),
    .io_enq_bits_strb (io_axi_write_data_bits_strb),
    .io_deq_ready     (writeData_q_io_deq_ready),
    .io_deq_valid     (_writeData_q_io_deq_valid),
    .io_deq_bits_data (io_fabric_writeDataBits),
    .io_deq_bits_last (_writeData_q_io_deq_bits_last),
    .io_deq_bits_strb (io_fabric_writeDataStrb)
  );
  Queue2_AxiWriteResponse io_axi_write_resp_q (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (_io_axi_write_resp_q_io_enq_ready),
    .io_enq_valid     (writeResponse_valid),
    .io_enq_bits_id   (_axiAddrCmd_q_io_deq_bits_addr_id),
    .io_enq_bits_resp ({~io_fabric_writeResp, 1'h0}),
    .io_deq_ready     (io_axi_write_resp_ready),
    .io_deq_valid     (io_axi_write_resp_valid),
    .io_deq_bits_id   (io_axi_write_resp_bits_id),
    .io_deq_bits_resp (io_axi_write_resp_bits_resp)
  );
  Queue3_AxiReadData readDataQueue (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (_readDataQueue_io_enq_ready),
    .io_enq_valid     (readIssued_valid),
    .io_enq_bits_data (io_fabric_readData_bits),
    .io_enq_bits_id   (readIssued_bits_id),
    .io_enq_bits_resp ({~io_fabric_readData_valid, 1'h0}),
    .io_enq_bits_last (readIssued_bits_last),
    .io_deq_ready     (io_axi_read_data_ready),
    .io_deq_valid     (io_axi_read_data_valid),
    .io_deq_bits_data (io_axi_read_data_bits_data),
    .io_deq_bits_id   (io_axi_read_data_bits_id),
    .io_deq_bits_resp (io_axi_read_data_bits_resp),
    .io_deq_bits_last (io_axi_read_data_bits_last),
    .io_count         (_readDataQueue_io_count)
  );
  assign io_fabric_readDataAddr_valid = maybeIssueRead;
  assign io_fabric_readDataAddr_bits = cmdAddr;
  assign io_fabric_writeDataAddr_valid = maybeWriteData;
  assign io_fabric_writeDataAddr_bits = cmdAddr;
endmodule

// VCS coverage exclude_module
module ram_2x145(
  input          R0_addr,
                 R0_en,
                 R0_clk,
  output [144:0] R0_data,
  input          W0_addr,
                 W0_en,
                 W0_clk,
  input  [144:0] W0_data
);

  reg [144:0] Memory[0:1];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [159:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          for (logic [7:0] j = 8'h0; j < 8'hA0; j += 8'h20) begin
            _RANDOM_MEM[j +: 32] = `RANDOM;
          end
          Memory[i[0]] = _RANDOM_MEM[144:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 145'bx;
endmodule

module Queue2_AxiWriteData(
  input          clock,
                 reset,
  output         io_enq_ready,
  input          io_enq_valid,
  input  [127:0] io_enq_bits_data,
  input  [15:0]  io_enq_bits_strb,
  input          io_deq_ready,
  output         io_deq_valid,
  output [127:0] io_deq_bits_data,
  output         io_deq_bits_last,
  output [15:0]  io_deq_bits_strb
);

  wire [144:0] _ram_ext_R0_data;
  reg          wrap;
  reg          wrap_1;
  reg          maybe_full;
  wire         ptr_match = wrap == wrap_1;
  wire         empty = ptr_match & ~maybe_full;
  wire         full = ptr_match & maybe_full;
  wire         do_enq = ~full & io_enq_valid;
  wire         do_deq = io_deq_ready & ~empty;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      wrap <= 1'h0;
      wrap_1 <= 1'h0;
      maybe_full <= 1'h0;
    end
    else begin
      if (do_enq)
        wrap <= wrap - 1'h1;
      if (do_deq)
        wrap_1 <= wrap_1 - 1'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        wrap = _RANDOM[/*Zero width*/ 1'b0][0];
        wrap_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][2];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        wrap = 1'h0;
        wrap_1 = 1'h0;
        maybe_full = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_2x145 ram_ext (
    .R0_addr (wrap_1),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (wrap),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({io_enq_bits_data, 1'h1, io_enq_bits_strb})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_data = _ram_ext_R0_data[144:17];
  assign io_deq_bits_last = _ram_ext_R0_data[16];
  assign io_deq_bits_strb = _ram_ext_R0_data[15:0];
endmodule

module DBus2AxiV2(
  input          clock,
                 reset,
                 io_dbus_valid,
  output         io_dbus_ready,
  input          io_dbus_write,
  input  [31:0]  io_dbus_pc,
                 io_dbus_addr,
  input  [4:0]   io_dbus_size,
  input  [127:0] io_dbus_wdata,
  input  [15:0]  io_dbus_wmask,
  output [127:0] io_dbus_rdata,
  input          io_axi_write_addr_ready,
  output         io_axi_write_addr_valid,
  output [31:0]  io_axi_write_addr_bits_addr,
  output [2:0]   io_axi_write_addr_bits_size,
  input          io_axi_write_data_ready,
  output         io_axi_write_data_valid,
  output [127:0] io_axi_write_data_bits_data,
  output         io_axi_write_data_bits_last,
  output [15:0]  io_axi_write_data_bits_strb,
  output         io_axi_write_resp_ready,
  input          io_axi_write_resp_valid,
  input  [1:0]   io_axi_write_resp_bits_resp,
  input          io_axi_read_addr_ready,
  output         io_axi_read_addr_valid,
  output [31:0]  io_axi_read_addr_bits_addr,
  output [2:0]   io_axi_read_addr_bits_size,
  output         io_axi_read_data_ready,
  input          io_axi_read_data_valid,
  input  [127:0] io_axi_read_data_bits_data,
  input  [1:0]   io_axi_read_data_bits_resp,
  output         io_fault_valid,
                 io_fault_bits_write,
  output [31:0]  io_fault_bits_addr,
                 io_fault_bits_epc
);

  wire         _wdataQueue_io_enq_ready;
  reg          waddrFired;
  wire         io_axi_write_addr_valid_0 = ~waddrFired & io_dbus_valid & io_dbus_write;
  reg          wdataFired;
  wire         wdataQueue_io_enq_valid = ~wdataFired & io_dbus_valid & io_dbus_write;
  reg          wrespReceived;
  wire         io_axi_write_resp_ready_0 = ~wrespReceived & io_dbus_valid & io_dbus_write;
  wire         _waddrFired_T = io_axi_write_addr_ready & io_axi_write_addr_valid_0;
  wire         _wdataFired_T = _wdataQueue_io_enq_ready & wdataQueue_io_enq_valid;
  wire         _wrespReceived_T = io_axi_write_resp_ready_0 & io_axi_write_resp_valid;
  wire         writeFinished =
    (_waddrFired_T | waddrFired) & (_wdataFired_T | wdataFired)
    & (_wrespReceived_T | wrespReceived);
  reg          raddrFired;
  wire         io_axi_read_addr_valid_0 = ~raddrFired & io_dbus_valid & ~io_dbus_write;
  reg          rdataReceived_valid;
  reg  [127:0] rdataReceived_bits;
  wire         io_axi_read_data_ready_0 =
    ~rdataReceived_valid & io_dbus_valid & ~io_dbus_write;
  wire         _raddrFired_T = io_axi_read_addr_ready & io_axi_read_addr_valid_0;
  wire         _readNext_T = io_axi_read_data_ready_0 & io_axi_read_data_valid;
  wire         readFinished =
    (_raddrFired_T | raddrFired) & (_readNext_T | rdataReceived_valid);
  reg  [127:0] readNext;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      waddrFired <= 1'h0;
      wdataFired <= 1'h0;
      wrespReceived <= 1'h0;
      raddrFired <= 1'h0;
      rdataReceived_valid <= 1'h0;
      rdataReceived_bits <= 128'h0;
      readNext <= 128'h0;
    end
    else begin
      waddrFired <= ~writeFinished & (_waddrFired_T | waddrFired);
      wdataFired <= ~writeFinished & (_wdataFired_T | wdataFired);
      wrespReceived <= ~writeFinished & (_wrespReceived_T | wrespReceived);
      raddrFired <= ~readFinished & (_raddrFired_T | raddrFired);
      rdataReceived_valid <= ~readFinished & (_readNext_T | rdataReceived_valid);
      if (readFinished) begin
        rdataReceived_bits <= 128'h0;
        readNext <= _readNext_T ? io_axi_read_data_bits_data : rdataReceived_bits;
      end
      else if (_readNext_T)
        rdataReceived_bits <= io_axi_read_data_bits_data;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:8];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [3:0] i = 4'h0; i < 4'h9; i += 4'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        waddrFired = _RANDOM[4'h0][0];
        wdataFired = _RANDOM[4'h0][1];
        wrespReceived = _RANDOM[4'h0][2];
        raddrFired = _RANDOM[4'h0][3];
        rdataReceived_valid = _RANDOM[4'h0][4];
        rdataReceived_bits =
          {_RANDOM[4'h0][31:5],
           _RANDOM[4'h1],
           _RANDOM[4'h2],
           _RANDOM[4'h3],
           _RANDOM[4'h4][4:0]};
        readNext =
          {_RANDOM[4'h4][31:5],
           _RANDOM[4'h5],
           _RANDOM[4'h6],
           _RANDOM[4'h7],
           _RANDOM[4'h8][4:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        waddrFired = 1'h0;
        wdataFired = 1'h0;
        wrespReceived = 1'h0;
        raddrFired = 1'h0;
        rdataReceived_valid = 1'h0;
        rdataReceived_bits = 128'h0;
        readNext = 128'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Queue2_AxiWriteData wdataQueue (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (_wdataQueue_io_enq_ready),
    .io_enq_valid     (wdataQueue_io_enq_valid),
    .io_enq_bits_data (io_dbus_wdata),
    .io_enq_bits_strb (io_dbus_wmask),
    .io_deq_ready     (io_axi_write_data_ready),
    .io_deq_valid     (io_axi_write_data_valid),
    .io_deq_bits_data (io_axi_write_data_bits_data),
    .io_deq_bits_last (io_axi_write_data_bits_last),
    .io_deq_bits_strb (io_axi_write_data_bits_strb)
  );
  assign io_dbus_ready = io_dbus_write ? writeFinished : readFinished;
  assign io_dbus_rdata = readNext;
  assign io_axi_write_addr_valid = io_axi_write_addr_valid_0;
  assign io_axi_write_addr_bits_addr = io_dbus_addr;
  assign io_axi_write_addr_bits_size =
    io_dbus_size[0]
      ? 3'h0
      : io_dbus_size[1]
          ? 3'h1
          : io_dbus_size[2] ? 3'h2 : io_dbus_size[3] ? 3'h3 : {2'h2, ~(io_dbus_size[4])};
  assign io_axi_write_resp_ready = io_axi_write_resp_ready_0;
  assign io_axi_read_addr_valid = io_axi_read_addr_valid_0;
  assign io_axi_read_addr_bits_addr = io_dbus_addr;
  assign io_axi_read_addr_bits_size =
    io_dbus_size[0]
      ? 3'h0
      : io_dbus_size[1]
          ? 3'h1
          : io_dbus_size[2] ? 3'h2 : io_dbus_size[3] ? 3'h3 : {2'h2, ~(io_dbus_size[4])};
  assign io_axi_read_data_ready = io_axi_read_data_ready_0;
  assign io_fault_valid =
    io_dbus_valid
    & (io_dbus_write
         ? io_axi_write_resp_valid & (|io_axi_write_resp_bits_resp)
         : io_axi_read_data_valid & (|io_axi_read_data_bits_resp));
  assign io_fault_bits_write = io_dbus_write;
  assign io_fault_bits_addr = io_dbus_addr;
  assign io_fault_bits_epc = io_dbus_pc;
endmodule

module CoreMiniAxi(
  input          io_aclk,
                 io_aresetn,
  output         io_axi_slave_write_addr_ready,
  input          io_axi_slave_write_addr_valid,
  input  [31:0]  io_axi_slave_write_addr_bits_addr,
  input  [2:0]   io_axi_slave_write_addr_bits_prot,
  input  [5:0]   io_axi_slave_write_addr_bits_id,
  input  [7:0]   io_axi_slave_write_addr_bits_len,
  input  [2:0]   io_axi_slave_write_addr_bits_size,
  input  [1:0]   io_axi_slave_write_addr_bits_burst,
  input          io_axi_slave_write_addr_bits_lock,
  input  [3:0]   io_axi_slave_write_addr_bits_cache,
                 io_axi_slave_write_addr_bits_qos,
                 io_axi_slave_write_addr_bits_region,
  output         io_axi_slave_write_data_ready,
  input          io_axi_slave_write_data_valid,
  input  [127:0] io_axi_slave_write_data_bits_data,
  input          io_axi_slave_write_data_bits_last,
  input  [15:0]  io_axi_slave_write_data_bits_strb,
  input          io_axi_slave_write_resp_ready,
  output         io_axi_slave_write_resp_valid,
  output [5:0]   io_axi_slave_write_resp_bits_id,
  output [1:0]   io_axi_slave_write_resp_bits_resp,
  output         io_axi_slave_read_addr_ready,
  input          io_axi_slave_read_addr_valid,
  input  [31:0]  io_axi_slave_read_addr_bits_addr,
  input  [2:0]   io_axi_slave_read_addr_bits_prot,
  input  [5:0]   io_axi_slave_read_addr_bits_id,
  input  [7:0]   io_axi_slave_read_addr_bits_len,
  input  [2:0]   io_axi_slave_read_addr_bits_size,
  input  [1:0]   io_axi_slave_read_addr_bits_burst,
  input          io_axi_slave_read_addr_bits_lock,
  input  [3:0]   io_axi_slave_read_addr_bits_cache,
                 io_axi_slave_read_addr_bits_qos,
                 io_axi_slave_read_addr_bits_region,
  input          io_axi_slave_read_data_ready,
  output         io_axi_slave_read_data_valid,
  output [127:0] io_axi_slave_read_data_bits_data,
  output [5:0]   io_axi_slave_read_data_bits_id,
  output [1:0]   io_axi_slave_read_data_bits_resp,
  output         io_axi_slave_read_data_bits_last,
  input          io_axi_master_write_addr_ready,
  output         io_axi_master_write_addr_valid,
  output [31:0]  io_axi_master_write_addr_bits_addr,
  output [2:0]   io_axi_master_write_addr_bits_prot,
  output [5:0]   io_axi_master_write_addr_bits_id,
  output [7:0]   io_axi_master_write_addr_bits_len,
  output [2:0]   io_axi_master_write_addr_bits_size,
  output [1:0]   io_axi_master_write_addr_bits_burst,
  output         io_axi_master_write_addr_bits_lock,
  output [3:0]   io_axi_master_write_addr_bits_cache,
                 io_axi_master_write_addr_bits_qos,
                 io_axi_master_write_addr_bits_region,
  input          io_axi_master_write_data_ready,
  output         io_axi_master_write_data_valid,
  output [127:0] io_axi_master_write_data_bits_data,
  output         io_axi_master_write_data_bits_last,
  output [15:0]  io_axi_master_write_data_bits_strb,
  output         io_axi_master_write_resp_ready,
  input          io_axi_master_write_resp_valid,
  input  [5:0]   io_axi_master_write_resp_bits_id,
  input  [1:0]   io_axi_master_write_resp_bits_resp,
  input          io_axi_master_read_addr_ready,
  output         io_axi_master_read_addr_valid,
  output [31:0]  io_axi_master_read_addr_bits_addr,
  output [2:0]   io_axi_master_read_addr_bits_prot,
  output [5:0]   io_axi_master_read_addr_bits_id,
  output [7:0]   io_axi_master_read_addr_bits_len,
  output [2:0]   io_axi_master_read_addr_bits_size,
  output [1:0]   io_axi_master_read_addr_bits_burst,
  output         io_axi_master_read_addr_bits_lock,
  output [3:0]   io_axi_master_read_addr_bits_cache,
                 io_axi_master_read_addr_bits_qos,
                 io_axi_master_read_addr_bits_region,
  output         io_axi_master_read_data_ready,
  input          io_axi_master_read_data_valid,
  input  [127:0] io_axi_master_read_data_bits_data,
  input  [5:0]   io_axi_master_read_data_bits_id,
  input  [1:0]   io_axi_master_read_data_bits_resp,
  input          io_axi_master_read_data_bits_last,
  output         io_halted,
                 io_fault,
                 io_wfi,
  input          io_irq,
  output [3:0]   io_debug_en,
  output [31:0]  io_debug_addr_0,
                 io_debug_addr_1,
                 io_debug_inst_0,
                 io_debug_inst_1,
                 io_debug_cycles,
  output         io_debug_dbus_valid,
  output [31:0]  io_debug_dbus_bits_addr,
  output [127:0] io_debug_dbus_bits_wdata,
  output         io_debug_dbus_bits_write,
                 io_debug_dispatch_0_instFire,
  output [31:0]  io_debug_dispatch_0_instAddr,
                 io_debug_dispatch_0_instInst,
  output         io_debug_dispatch_1_instFire,
  output [31:0]  io_debug_dispatch_1_instAddr,
                 io_debug_dispatch_1_instInst,
  output         io_debug_regfile_writeAddr_0_valid,
  output [4:0]   io_debug_regfile_writeAddr_0_bits,
  output         io_debug_regfile_writeAddr_1_valid,
  output [4:0]   io_debug_regfile_writeAddr_1_bits,
  output         io_debug_regfile_writeData_0_valid,
  output [4:0]   io_debug_regfile_writeData_0_bits_addr,
  output [31:0]  io_debug_regfile_writeData_0_bits_data,
  output         io_debug_regfile_writeData_1_valid,
  output [4:0]   io_debug_regfile_writeData_1_bits_addr,
  output [31:0]  io_debug_regfile_writeData_1_bits_data,
  output         io_debug_regfile_writeData_2_valid,
  output [4:0]   io_debug_regfile_writeData_2_bits_addr,
  output [31:0]  io_debug_regfile_writeData_2_bits_data,
  output         io_debug_regfile_writeData_3_valid,
  output [4:0]   io_debug_regfile_writeData_3_bits_addr,
  output [31:0]  io_debug_regfile_writeData_3_bits_data,
  output         io_debug_float_writeAddr_valid,
  output [4:0]   io_debug_float_writeAddr_bits,
  output         io_debug_float_writeData_0_valid,
  output [31:0]  io_debug_float_writeData_0_bits_addr,
                 io_debug_float_writeData_0_bits_data,
  output         io_debug_float_writeData_1_valid,
  output [31:0]  io_debug_float_writeData_1_bits_addr,
                 io_debug_float_writeData_1_bits_data,
  output         io_slog_valid,
  output [4:0]   io_slog_addr,
  output [31:0]  io_slog_data,
  input          io_te
);

  wire         _ebus2axi_io_dbus_ready;
  wire [127:0] _ebus2axi_io_dbus_rdata;
  wire         _ebus2axi_io_fault_valid;
  wire         _ebus2axi_io_fault_bits_write;
  wire [31:0]  _ebus2axi_io_fault_bits_addr;
  wire [31:0]  _ebus2axi_io_fault_bits_epc;
  wire         _axiSlave_io_axi_write_addr_ready;
  wire         _axiSlave_io_axi_write_data_ready;
  wire         _axiSlave_io_axi_write_resp_valid;
  wire         _axiSlave_io_axi_read_addr_ready;
  wire         _axiSlave_io_axi_read_data_valid;
  wire         _axiSlave_io_fabric_readDataAddr_valid;
  wire [31:0]  _axiSlave_io_fabric_readDataAddr_bits;
  wire         _axiSlave_io_fabric_writeDataAddr_valid;
  wire [31:0]  _axiSlave_io_fabric_writeDataAddr_bits;
  wire [127:0] _axiSlave_io_fabric_writeDataBits;
  wire [15:0]  _axiSlave_io_fabric_writeDataStrb;
  wire         _fabricMux_io_source_readData_valid;
  wire [127:0] _fabricMux_io_source_readData_bits;
  wire         _fabricMux_io_source_writeResp;
  wire         _fabricMux_io_fabricBusy;
  wire         _fabricMux_io_ports_0_readDataAddr_valid;
  wire [31:0]  _fabricMux_io_ports_0_readDataAddr_bits;
  wire         _fabricMux_io_ports_0_writeDataAddr_valid;
  wire [31:0]  _fabricMux_io_ports_0_writeDataAddr_bits;
  wire [127:0] _fabricMux_io_ports_0_writeDataBits;
  wire [15:0]  _fabricMux_io_ports_0_writeDataStrb;
  wire         _fabricMux_io_ports_1_readDataAddr_valid;
  wire [31:0]  _fabricMux_io_ports_1_readDataAddr_bits;
  wire         _fabricMux_io_ports_1_writeDataAddr_valid;
  wire [31:0]  _fabricMux_io_ports_1_writeDataAddr_bits;
  wire [127:0] _fabricMux_io_ports_1_writeDataBits;
  wire [15:0]  _fabricMux_io_ports_1_writeDataStrb;
  wire [31:0]  _fabricMux_io_ports_2_readDataAddr_bits;
  wire         _fabricMux_io_ports_2_writeDataAddr_valid;
  wire [31:0]  _fabricMux_io_ports_2_writeDataAddr_bits;
  wire [127:0] _fabricMux_io_ports_2_writeDataBits;
  wire [127:0] _dtcmArbiter_io_source_0_readData_bits;
  wire         _dtcmArbiter_io_source_1_readData_valid;
  wire [127:0] _dtcmArbiter_io_source_1_readData_bits;
  wire         _dtcmArbiter_io_fabricBusy;
  wire         _dtcmArbiter_io_port_readDataAddr_valid;
  wire [31:0]  _dtcmArbiter_io_port_readDataAddr_bits;
  wire         _dtcmArbiter_io_port_writeDataAddr_valid;
  wire [31:0]  _dtcmArbiter_io_port_writeDataAddr_bits;
  wire [127:0] _dtcmArbiter_io_port_writeDataBits;
  wire [15:0]  _dtcmArbiter_io_port_writeDataStrb;
  wire         _dtcmWrapper_io_fabric_readData_valid;
  wire [127:0] _dtcmWrapper_io_fabric_readData_bits;
  wire [8:0]   _dtcmWrapper_io_sram_address;
  wire         _dtcmWrapper_io_sram_enable;
  wire         _dtcmWrapper_io_sram_isWrite;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_0;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_1;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_2;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_3;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_4;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_5;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_6;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_7;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_8;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_9;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_10;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_11;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_12;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_13;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_14;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_15;
  wire         _dtcmWrapper_io_sram_mask_0;
  wire         _dtcmWrapper_io_sram_mask_1;
  wire         _dtcmWrapper_io_sram_mask_2;
  wire         _dtcmWrapper_io_sram_mask_3;
  wire         _dtcmWrapper_io_sram_mask_4;
  wire         _dtcmWrapper_io_sram_mask_5;
  wire         _dtcmWrapper_io_sram_mask_6;
  wire         _dtcmWrapper_io_sram_mask_7;
  wire         _dtcmWrapper_io_sram_mask_8;
  wire         _dtcmWrapper_io_sram_mask_9;
  wire         _dtcmWrapper_io_sram_mask_10;
  wire         _dtcmWrapper_io_sram_mask_11;
  wire         _dtcmWrapper_io_sram_mask_12;
  wire         _dtcmWrapper_io_sram_mask_13;
  wire         _dtcmWrapper_io_sram_mask_14;
  wire         _dtcmWrapper_io_sram_mask_15;
  wire [7:0]   _dtcm_io_rdata_0;
  wire [7:0]   _dtcm_io_rdata_1;
  wire [7:0]   _dtcm_io_rdata_2;
  wire [7:0]   _dtcm_io_rdata_3;
  wire [7:0]   _dtcm_io_rdata_4;
  wire [7:0]   _dtcm_io_rdata_5;
  wire [7:0]   _dtcm_io_rdata_6;
  wire [7:0]   _dtcm_io_rdata_7;
  wire [7:0]   _dtcm_io_rdata_8;
  wire [7:0]   _dtcm_io_rdata_9;
  wire [7:0]   _dtcm_io_rdata_10;
  wire [7:0]   _dtcm_io_rdata_11;
  wire [7:0]   _dtcm_io_rdata_12;
  wire [7:0]   _dtcm_io_rdata_13;
  wire [7:0]   _dtcm_io_rdata_14;
  wire [7:0]   _dtcm_io_rdata_15;
  wire [127:0] _itcmArbiter_io_source_0_readData_bits;
  wire         _itcmArbiter_io_source_1_readData_valid;
  wire [127:0] _itcmArbiter_io_source_1_readData_bits;
  wire         _itcmArbiter_io_fabricBusy;
  wire         _itcmArbiter_io_port_readDataAddr_valid;
  wire [31:0]  _itcmArbiter_io_port_readDataAddr_bits;
  wire         _itcmArbiter_io_port_writeDataAddr_valid;
  wire [31:0]  _itcmArbiter_io_port_writeDataAddr_bits;
  wire [127:0] _itcmArbiter_io_port_writeDataBits;
  wire [15:0]  _itcmArbiter_io_port_writeDataStrb;
  wire         _itcmWrapper_io_fabric_readData_valid;
  wire [127:0] _itcmWrapper_io_fabric_readData_bits;
  wire [7:0]   _itcmWrapper_io_sram_address;
  wire         _itcmWrapper_io_sram_enable;
  wire         _itcmWrapper_io_sram_isWrite;
  wire [7:0]   _itcmWrapper_io_sram_writeData_0;
  wire [7:0]   _itcmWrapper_io_sram_writeData_1;
  wire [7:0]   _itcmWrapper_io_sram_writeData_2;
  wire [7:0]   _itcmWrapper_io_sram_writeData_3;
  wire [7:0]   _itcmWrapper_io_sram_writeData_4;
  wire [7:0]   _itcmWrapper_io_sram_writeData_5;
  wire [7:0]   _itcmWrapper_io_sram_writeData_6;
  wire [7:0]   _itcmWrapper_io_sram_writeData_7;
  wire [7:0]   _itcmWrapper_io_sram_writeData_8;
  wire [7:0]   _itcmWrapper_io_sram_writeData_9;
  wire [7:0]   _itcmWrapper_io_sram_writeData_10;
  wire [7:0]   _itcmWrapper_io_sram_writeData_11;
  wire [7:0]   _itcmWrapper_io_sram_writeData_12;
  wire [7:0]   _itcmWrapper_io_sram_writeData_13;
  wire [7:0]   _itcmWrapper_io_sram_writeData_14;
  wire [7:0]   _itcmWrapper_io_sram_writeData_15;
  wire         _itcmWrapper_io_sram_mask_0;
  wire         _itcmWrapper_io_sram_mask_1;
  wire         _itcmWrapper_io_sram_mask_2;
  wire         _itcmWrapper_io_sram_mask_3;
  wire         _itcmWrapper_io_sram_mask_4;
  wire         _itcmWrapper_io_sram_mask_5;
  wire         _itcmWrapper_io_sram_mask_6;
  wire         _itcmWrapper_io_sram_mask_7;
  wire         _itcmWrapper_io_sram_mask_8;
  wire         _itcmWrapper_io_sram_mask_9;
  wire         _itcmWrapper_io_sram_mask_10;
  wire         _itcmWrapper_io_sram_mask_11;
  wire         _itcmWrapper_io_sram_mask_12;
  wire         _itcmWrapper_io_sram_mask_13;
  wire         _itcmWrapper_io_sram_mask_14;
  wire         _itcmWrapper_io_sram_mask_15;
  wire [7:0]   _itcm_io_rdata_0;
  wire [7:0]   _itcm_io_rdata_1;
  wire [7:0]   _itcm_io_rdata_2;
  wire [7:0]   _itcm_io_rdata_3;
  wire [7:0]   _itcm_io_rdata_4;
  wire [7:0]   _itcm_io_rdata_5;
  wire [7:0]   _itcm_io_rdata_6;
  wire [7:0]   _itcm_io_rdata_7;
  wire [7:0]   _itcm_io_rdata_8;
  wire [7:0]   _itcm_io_rdata_9;
  wire [7:0]   _itcm_io_rdata_10;
  wire [7:0]   _itcm_io_rdata_11;
  wire [7:0]   _itcm_io_rdata_12;
  wire [7:0]   _itcm_io_rdata_13;
  wire [7:0]   _itcm_io_rdata_14;
  wire [7:0]   _itcm_io_rdata_15;
  wire [31:0]  _core_io_csr_out_value_0;
  wire [31:0]  _core_io_csr_out_value_1;
  wire [31:0]  _core_io_csr_out_value_2;
  wire [31:0]  _core_io_csr_out_value_3;
  wire [31:0]  _core_io_csr_out_value_4;
  wire [31:0]  _core_io_csr_out_value_5;
  wire [31:0]  _core_io_csr_out_value_6;
  wire [31:0]  _core_io_csr_out_value_7;
  wire [31:0]  _core_io_csr_out_value_8;
  wire         _core_io_halted;
  wire         _core_io_fault;
  wire         _core_io_wfi;
  wire         _core_io_ibus_valid;
  wire [31:0]  _core_io_ibus_addr;
  wire         _core_io_dbus_valid;
  wire         _core_io_dbus_write;
  wire [31:0]  _core_io_dbus_addr;
  wire [127:0] _core_io_dbus_wdata;
  wire [15:0]  _core_io_dbus_wmask;
  wire         _core_io_ebus_dbus_valid;
  wire         _core_io_ebus_dbus_write;
  wire [31:0]  _core_io_ebus_dbus_pc;
  wire [31:0]  _core_io_ebus_dbus_addr;
  wire [4:0]   _core_io_ebus_dbus_size;
  wire [127:0] _core_io_ebus_dbus_wdata;
  wire [15:0]  _core_io_ebus_dbus_wmask;
  wire         _cg_clk_o;
  wire         _csr_io_fabric_readData_valid;
  wire [127:0] _csr_io_fabric_readData_bits;
  wire         _csr_io_fabric_writeResp;
  wire         _csr_io_reset;
  wire         _csr_io_cg;
  wire [31:0]  _csr_io_pcStart;
  wire         _rst_sync_clk_o;
  wire         _rst_sync_rstn_o;
  wire         _global_reset_T_2 = ~(io_te ? io_aresetn : _rst_sync_rstn_o);
  reg          axiSlaveEnable;
  always @(posedge _rst_sync_clk_o or posedge _global_reset_T_2) begin
    if (_global_reset_T_2)
      axiSlaveEnable <= 1'h0;
    else
      axiSlaveEnable <= 1'h1;
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        axiSlaveEnable = _RANDOM[/*Zero width*/ 1'b0][0];
      `endif // RANDOMIZE_REG_INIT
      if (_global_reset_T_2)
        axiSlaveEnable = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  RstSync rst_sync (
    .clk_i  (io_aclk),
    .rstn_i (io_aresetn),
    .clk_en (1'h1),
    .te     (io_te),
    .clk_o  (_rst_sync_clk_o),
    .rstn_o (_rst_sync_rstn_o)
  );
  CoreCSR csr (
    .clock                         (_rst_sync_clk_o),
    .reset                         (_global_reset_T_2),
    .io_fabric_readDataAddr_bits   (_fabricMux_io_ports_2_readDataAddr_bits),
    .io_fabric_readData_valid      (_csr_io_fabric_readData_valid),
    .io_fabric_readData_bits       (_csr_io_fabric_readData_bits),
    .io_fabric_writeDataAddr_valid (_fabricMux_io_ports_2_writeDataAddr_valid),
    .io_fabric_writeDataAddr_bits  (_fabricMux_io_ports_2_writeDataAddr_bits),
    .io_fabric_writeDataBits       (_fabricMux_io_ports_2_writeDataBits),
    .io_fabric_writeResp           (_csr_io_fabric_writeResp),
    .io_reset                      (_csr_io_reset),
    .io_cg                         (_csr_io_cg),
    .io_pcStart                    (_csr_io_pcStart),
    .io_halted                     (_core_io_halted),
    .io_fault                      (_core_io_fault),
    .io_coralnpu_csr_value_0       (_core_io_csr_out_value_0),
    .io_coralnpu_csr_value_1       (_core_io_csr_out_value_1),
    .io_coralnpu_csr_value_2       (_core_io_csr_out_value_2),
    .io_coralnpu_csr_value_3       (_core_io_csr_out_value_3),
    .io_coralnpu_csr_value_4       (_core_io_csr_out_value_4),
    .io_coralnpu_csr_value_5       (_core_io_csr_out_value_5),
    .io_coralnpu_csr_value_6       (_core_io_csr_out_value_6),
    .io_coralnpu_csr_value_7       (_core_io_csr_out_value_7),
    .io_coralnpu_csr_value_8       (_core_io_csr_out_value_8)
  );
  ClockGate cg (
    .clk_i  (_rst_sync_clk_o),
    .enable (io_irq | ~_csr_io_cg & ~_core_io_wfi),
    .te     (io_te),
    .clk_o  (_cg_clk_o)
  );
  CoreMini core (
    .clock                                  (_cg_clk_o),
    .reset                                  (io_te ? ~io_aresetn : _csr_io_reset),
    .io_csr_in_value_0                      (_csr_io_pcStart),
    .io_csr_out_value_0                     (_core_io_csr_out_value_0),
    .io_csr_out_value_1                     (_core_io_csr_out_value_1),
    .io_csr_out_value_2                     (_core_io_csr_out_value_2),
    .io_csr_out_value_3                     (_core_io_csr_out_value_3),
    .io_csr_out_value_4                     (_core_io_csr_out_value_4),
    .io_csr_out_value_5                     (_core_io_csr_out_value_5),
    .io_csr_out_value_6                     (_core_io_csr_out_value_6),
    .io_csr_out_value_7                     (_core_io_csr_out_value_7),
    .io_csr_out_value_8                     (_core_io_csr_out_value_8),
    .io_halted                              (_core_io_halted),
    .io_fault                               (_core_io_fault),
    .io_wfi                                 (_core_io_wfi),
    .io_irq                                 (io_irq),
    .io_ibus_valid                          (_core_io_ibus_valid),
    .io_ibus_addr                           (_core_io_ibus_addr),
    .io_ibus_rdata                          (_itcmArbiter_io_source_0_readData_bits),
    .io_ibus_fault_valid
      (_core_io_ibus_valid & (|(_core_io_ibus_addr[31:12]))),
    .io_ibus_fault_bits_epc                 (_core_io_ibus_addr),
    .io_dbus_valid                          (_core_io_dbus_valid),
    .io_dbus_write                          (_core_io_dbus_write),
    .io_dbus_addr                           (_core_io_dbus_addr),
    .io_dbus_wdata                          (_core_io_dbus_wdata),
    .io_dbus_wmask                          (_core_io_dbus_wmask),
    .io_dbus_rdata                          (_dtcmArbiter_io_source_0_readData_bits),
    .io_ebus_dbus_valid                     (_core_io_ebus_dbus_valid),
    .io_ebus_dbus_ready                     (_ebus2axi_io_dbus_ready),
    .io_ebus_dbus_write                     (_core_io_ebus_dbus_write),
    .io_ebus_dbus_pc                        (_core_io_ebus_dbus_pc),
    .io_ebus_dbus_addr                      (_core_io_ebus_dbus_addr),
    .io_ebus_dbus_size                      (_core_io_ebus_dbus_size),
    .io_ebus_dbus_wdata                     (_core_io_ebus_dbus_wdata),
    .io_ebus_dbus_wmask                     (_core_io_ebus_dbus_wmask),
    .io_ebus_dbus_rdata                     (_ebus2axi_io_dbus_rdata),
    .io_ebus_fault_valid                    (_ebus2axi_io_fault_valid),
    .io_ebus_fault_bits_write               (_ebus2axi_io_fault_bits_write),
    .io_ebus_fault_bits_addr                (_ebus2axi_io_fault_bits_addr),
    .io_ebus_fault_bits_epc                 (_ebus2axi_io_fault_bits_epc),
    .io_slog_valid                          (io_slog_valid),
    .io_slog_addr                           (io_slog_addr),
    .io_slog_data                           (io_slog_data),
    .io_debug_en                            (io_debug_en),
    .io_debug_addr_0                        (io_debug_addr_0),
    .io_debug_addr_1                        (io_debug_addr_1),
    .io_debug_inst_0                        (io_debug_inst_0),
    .io_debug_inst_1                        (io_debug_inst_1),
    .io_debug_cycles                        (io_debug_cycles),
    .io_debug_dbus_valid                    (io_debug_dbus_valid),
    .io_debug_dbus_bits_addr                (io_debug_dbus_bits_addr),
    .io_debug_dbus_bits_wdata               (io_debug_dbus_bits_wdata),
    .io_debug_dbus_bits_write               (io_debug_dbus_bits_write),
    .io_debug_dispatch_0_instFire           (io_debug_dispatch_0_instFire),
    .io_debug_dispatch_0_instAddr           (io_debug_dispatch_0_instAddr),
    .io_debug_dispatch_0_instInst           (io_debug_dispatch_0_instInst),
    .io_debug_dispatch_1_instFire           (io_debug_dispatch_1_instFire),
    .io_debug_dispatch_1_instAddr           (io_debug_dispatch_1_instAddr),
    .io_debug_dispatch_1_instInst           (io_debug_dispatch_1_instInst),
    .io_debug_regfile_writeAddr_0_valid     (io_debug_regfile_writeAddr_0_valid),
    .io_debug_regfile_writeAddr_0_bits      (io_debug_regfile_writeAddr_0_bits),
    .io_debug_regfile_writeAddr_1_valid     (io_debug_regfile_writeAddr_1_valid),
    .io_debug_regfile_writeAddr_1_bits      (io_debug_regfile_writeAddr_1_bits),
    .io_debug_regfile_writeData_0_valid     (io_debug_regfile_writeData_0_valid),
    .io_debug_regfile_writeData_0_bits_addr (io_debug_regfile_writeData_0_bits_addr),
    .io_debug_regfile_writeData_0_bits_data (io_debug_regfile_writeData_0_bits_data),
    .io_debug_regfile_writeData_1_valid     (io_debug_regfile_writeData_1_valid),
    .io_debug_regfile_writeData_1_bits_addr (io_debug_regfile_writeData_1_bits_addr),
    .io_debug_regfile_writeData_1_bits_data (io_debug_regfile_writeData_1_bits_data),
    .io_debug_regfile_writeData_2_valid     (io_debug_regfile_writeData_2_valid),
    .io_debug_regfile_writeData_2_bits_addr (io_debug_regfile_writeData_2_bits_addr),
    .io_debug_regfile_writeData_2_bits_data (io_debug_regfile_writeData_2_bits_data),
    .io_debug_regfile_writeData_3_valid     (io_debug_regfile_writeData_3_valid),
    .io_debug_regfile_writeData_3_bits_addr (io_debug_regfile_writeData_3_bits_addr),
    .io_debug_regfile_writeData_3_bits_data (io_debug_regfile_writeData_3_bits_data),
    .io_debug_float_writeAddr_valid         (io_debug_float_writeAddr_valid),
    .io_debug_float_writeAddr_bits          (io_debug_float_writeAddr_bits),
    .io_debug_float_writeData_0_valid       (io_debug_float_writeData_0_valid),
    .io_debug_float_writeData_0_bits_addr   (io_debug_float_writeData_0_bits_addr),
    .io_debug_float_writeData_0_bits_data   (io_debug_float_writeData_0_bits_data),
    .io_debug_float_writeData_1_valid       (io_debug_float_writeData_1_valid),
    .io_debug_float_writeData_1_bits_addr   (io_debug_float_writeData_1_bits_addr),
    .io_debug_float_writeData_1_bits_data   (io_debug_float_writeData_1_bits_data)
  );
  TCM128 itcm (
    .clock       (_rst_sync_clk_o),
    .reset       (_global_reset_T_2),
    .io_addr     (_itcmWrapper_io_sram_address),
    .io_enable   (_itcmWrapper_io_sram_enable),
    .io_write    (_itcmWrapper_io_sram_isWrite),
    .io_wdata_0  (_itcmWrapper_io_sram_writeData_0),
    .io_wdata_1  (_itcmWrapper_io_sram_writeData_1),
    .io_wdata_2  (_itcmWrapper_io_sram_writeData_2),
    .io_wdata_3  (_itcmWrapper_io_sram_writeData_3),
    .io_wdata_4  (_itcmWrapper_io_sram_writeData_4),
    .io_wdata_5  (_itcmWrapper_io_sram_writeData_5),
    .io_wdata_6  (_itcmWrapper_io_sram_writeData_6),
    .io_wdata_7  (_itcmWrapper_io_sram_writeData_7),
    .io_wdata_8  (_itcmWrapper_io_sram_writeData_8),
    .io_wdata_9  (_itcmWrapper_io_sram_writeData_9),
    .io_wdata_10 (_itcmWrapper_io_sram_writeData_10),
    .io_wdata_11 (_itcmWrapper_io_sram_writeData_11),
    .io_wdata_12 (_itcmWrapper_io_sram_writeData_12),
    .io_wdata_13 (_itcmWrapper_io_sram_writeData_13),
    .io_wdata_14 (_itcmWrapper_io_sram_writeData_14),
    .io_wdata_15 (_itcmWrapper_io_sram_writeData_15),
    .io_wmask_0  (_itcmWrapper_io_sram_mask_0),
    .io_wmask_1  (_itcmWrapper_io_sram_mask_1),
    .io_wmask_2  (_itcmWrapper_io_sram_mask_2),
    .io_wmask_3  (_itcmWrapper_io_sram_mask_3),
    .io_wmask_4  (_itcmWrapper_io_sram_mask_4),
    .io_wmask_5  (_itcmWrapper_io_sram_mask_5),
    .io_wmask_6  (_itcmWrapper_io_sram_mask_6),
    .io_wmask_7  (_itcmWrapper_io_sram_mask_7),
    .io_wmask_8  (_itcmWrapper_io_sram_mask_8),
    .io_wmask_9  (_itcmWrapper_io_sram_mask_9),
    .io_wmask_10 (_itcmWrapper_io_sram_mask_10),
    .io_wmask_11 (_itcmWrapper_io_sram_mask_11),
    .io_wmask_12 (_itcmWrapper_io_sram_mask_12),
    .io_wmask_13 (_itcmWrapper_io_sram_mask_13),
    .io_wmask_14 (_itcmWrapper_io_sram_mask_14),
    .io_wmask_15 (_itcmWrapper_io_sram_mask_15),
    .io_rdata_0  (_itcm_io_rdata_0),
    .io_rdata_1  (_itcm_io_rdata_1),
    .io_rdata_2  (_itcm_io_rdata_2),
    .io_rdata_3  (_itcm_io_rdata_3),
    .io_rdata_4  (_itcm_io_rdata_4),
    .io_rdata_5  (_itcm_io_rdata_5),
    .io_rdata_6  (_itcm_io_rdata_6),
    .io_rdata_7  (_itcm_io_rdata_7),
    .io_rdata_8  (_itcm_io_rdata_8),
    .io_rdata_9  (_itcm_io_rdata_9),
    .io_rdata_10 (_itcm_io_rdata_10),
    .io_rdata_11 (_itcm_io_rdata_11),
    .io_rdata_12 (_itcm_io_rdata_12),
    .io_rdata_13 (_itcm_io_rdata_13),
    .io_rdata_14 (_itcm_io_rdata_14),
    .io_rdata_15 (_itcm_io_rdata_15)
  );
  SRAM itcmWrapper (
    .clock                         (_rst_sync_clk_o),
    .reset                         (_global_reset_T_2),
    .io_fabric_readDataAddr_valid  (_itcmArbiter_io_port_readDataAddr_valid),
    .io_fabric_readDataAddr_bits   (_itcmArbiter_io_port_readDataAddr_bits),
    .io_fabric_readData_valid      (_itcmWrapper_io_fabric_readData_valid),
    .io_fabric_readData_bits       (_itcmWrapper_io_fabric_readData_bits),
    .io_fabric_writeDataAddr_valid (_itcmArbiter_io_port_writeDataAddr_valid),
    .io_fabric_writeDataAddr_bits  (_itcmArbiter_io_port_writeDataAddr_bits),
    .io_fabric_writeDataBits       (_itcmArbiter_io_port_writeDataBits),
    .io_fabric_writeDataStrb       (_itcmArbiter_io_port_writeDataStrb),
    .io_sram_address               (_itcmWrapper_io_sram_address),
    .io_sram_enable                (_itcmWrapper_io_sram_enable),
    .io_sram_isWrite               (_itcmWrapper_io_sram_isWrite),
    .io_sram_readData_0            (_itcm_io_rdata_0),
    .io_sram_readData_1            (_itcm_io_rdata_1),
    .io_sram_readData_2            (_itcm_io_rdata_2),
    .io_sram_readData_3            (_itcm_io_rdata_3),
    .io_sram_readData_4            (_itcm_io_rdata_4),
    .io_sram_readData_5            (_itcm_io_rdata_5),
    .io_sram_readData_6            (_itcm_io_rdata_6),
    .io_sram_readData_7            (_itcm_io_rdata_7),
    .io_sram_readData_8            (_itcm_io_rdata_8),
    .io_sram_readData_9            (_itcm_io_rdata_9),
    .io_sram_readData_10           (_itcm_io_rdata_10),
    .io_sram_readData_11           (_itcm_io_rdata_11),
    .io_sram_readData_12           (_itcm_io_rdata_12),
    .io_sram_readData_13           (_itcm_io_rdata_13),
    .io_sram_readData_14           (_itcm_io_rdata_14),
    .io_sram_readData_15           (_itcm_io_rdata_15),
    .io_sram_writeData_0           (_itcmWrapper_io_sram_writeData_0),
    .io_sram_writeData_1           (_itcmWrapper_io_sram_writeData_1),
    .io_sram_writeData_2           (_itcmWrapper_io_sram_writeData_2),
    .io_sram_writeData_3           (_itcmWrapper_io_sram_writeData_3),
    .io_sram_writeData_4           (_itcmWrapper_io_sram_writeData_4),
    .io_sram_writeData_5           (_itcmWrapper_io_sram_writeData_5),
    .io_sram_writeData_6           (_itcmWrapper_io_sram_writeData_6),
    .io_sram_writeData_7           (_itcmWrapper_io_sram_writeData_7),
    .io_sram_writeData_8           (_itcmWrapper_io_sram_writeData_8),
    .io_sram_writeData_9           (_itcmWrapper_io_sram_writeData_9),
    .io_sram_writeData_10          (_itcmWrapper_io_sram_writeData_10),
    .io_sram_writeData_11          (_itcmWrapper_io_sram_writeData_11),
    .io_sram_writeData_12          (_itcmWrapper_io_sram_writeData_12),
    .io_sram_writeData_13          (_itcmWrapper_io_sram_writeData_13),
    .io_sram_writeData_14          (_itcmWrapper_io_sram_writeData_14),
    .io_sram_writeData_15          (_itcmWrapper_io_sram_writeData_15),
    .io_sram_mask_0                (_itcmWrapper_io_sram_mask_0),
    .io_sram_mask_1                (_itcmWrapper_io_sram_mask_1),
    .io_sram_mask_2                (_itcmWrapper_io_sram_mask_2),
    .io_sram_mask_3                (_itcmWrapper_io_sram_mask_3),
    .io_sram_mask_4                (_itcmWrapper_io_sram_mask_4),
    .io_sram_mask_5                (_itcmWrapper_io_sram_mask_5),
    .io_sram_mask_6                (_itcmWrapper_io_sram_mask_6),
    .io_sram_mask_7                (_itcmWrapper_io_sram_mask_7),
    .io_sram_mask_8                (_itcmWrapper_io_sram_mask_8),
    .io_sram_mask_9                (_itcmWrapper_io_sram_mask_9),
    .io_sram_mask_10               (_itcmWrapper_io_sram_mask_10),
    .io_sram_mask_11               (_itcmWrapper_io_sram_mask_11),
    .io_sram_mask_12               (_itcmWrapper_io_sram_mask_12),
    .io_sram_mask_13               (_itcmWrapper_io_sram_mask_13),
    .io_sram_mask_14               (_itcmWrapper_io_sram_mask_14),
    .io_sram_mask_15               (_itcmWrapper_io_sram_mask_15)
  );
  FabricArbiter itcmArbiter (
    .clock                           (_rst_sync_clk_o),
    .reset                           (_global_reset_T_2),
    .io_source_0_readDataAddr_valid  (_core_io_ibus_valid),
    .io_source_0_readDataAddr_bits   (_core_io_ibus_addr),
    .io_source_0_readData_bits       (_itcmArbiter_io_source_0_readData_bits),
    .io_source_0_writeDataAddr_valid (1'h0),
    .io_source_0_writeDataAddr_bits  (32'h0),
    .io_source_0_writeDataBits       (128'h0),
    .io_source_0_writeDataStrb       (16'h0),
    .io_source_1_readDataAddr_valid  (_fabricMux_io_ports_0_readDataAddr_valid),
    .io_source_1_readDataAddr_bits   (_fabricMux_io_ports_0_readDataAddr_bits),
    .io_source_1_readData_valid      (_itcmArbiter_io_source_1_readData_valid),
    .io_source_1_readData_bits       (_itcmArbiter_io_source_1_readData_bits),
    .io_source_1_writeDataAddr_valid (_fabricMux_io_ports_0_writeDataAddr_valid),
    .io_source_1_writeDataAddr_bits  (_fabricMux_io_ports_0_writeDataAddr_bits),
    .io_source_1_writeDataBits       (_fabricMux_io_ports_0_writeDataBits),
    .io_source_1_writeDataStrb       (_fabricMux_io_ports_0_writeDataStrb),
    .io_fabricBusy                   (_itcmArbiter_io_fabricBusy),
    .io_port_readDataAddr_valid      (_itcmArbiter_io_port_readDataAddr_valid),
    .io_port_readDataAddr_bits       (_itcmArbiter_io_port_readDataAddr_bits),
    .io_port_readData_valid          (_itcmWrapper_io_fabric_readData_valid),
    .io_port_readData_bits           (_itcmWrapper_io_fabric_readData_bits),
    .io_port_writeDataAddr_valid     (_itcmArbiter_io_port_writeDataAddr_valid),
    .io_port_writeDataAddr_bits      (_itcmArbiter_io_port_writeDataAddr_bits),
    .io_port_writeDataBits           (_itcmArbiter_io_port_writeDataBits),
    .io_port_writeDataStrb           (_itcmArbiter_io_port_writeDataStrb)
  );
  TCM128_1 dtcm (
    .clock       (_rst_sync_clk_o),
    .io_addr     (_dtcmWrapper_io_sram_address),
    .io_enable   (_dtcmWrapper_io_sram_enable),
    .io_write    (_dtcmWrapper_io_sram_isWrite),
    .io_wdata_0  (_dtcmWrapper_io_sram_writeData_0),
    .io_wdata_1  (_dtcmWrapper_io_sram_writeData_1),
    .io_wdata_2  (_dtcmWrapper_io_sram_writeData_2),
    .io_wdata_3  (_dtcmWrapper_io_sram_writeData_3),
    .io_wdata_4  (_dtcmWrapper_io_sram_writeData_4),
    .io_wdata_5  (_dtcmWrapper_io_sram_writeData_5),
    .io_wdata_6  (_dtcmWrapper_io_sram_writeData_6),
    .io_wdata_7  (_dtcmWrapper_io_sram_writeData_7),
    .io_wdata_8  (_dtcmWrapper_io_sram_writeData_8),
    .io_wdata_9  (_dtcmWrapper_io_sram_writeData_9),
    .io_wdata_10 (_dtcmWrapper_io_sram_writeData_10),
    .io_wdata_11 (_dtcmWrapper_io_sram_writeData_11),
    .io_wdata_12 (_dtcmWrapper_io_sram_writeData_12),
    .io_wdata_13 (_dtcmWrapper_io_sram_writeData_13),
    .io_wdata_14 (_dtcmWrapper_io_sram_writeData_14),
    .io_wdata_15 (_dtcmWrapper_io_sram_writeData_15),
    .io_wmask_0  (_dtcmWrapper_io_sram_mask_0),
    .io_wmask_1  (_dtcmWrapper_io_sram_mask_1),
    .io_wmask_2  (_dtcmWrapper_io_sram_mask_2),
    .io_wmask_3  (_dtcmWrapper_io_sram_mask_3),
    .io_wmask_4  (_dtcmWrapper_io_sram_mask_4),
    .io_wmask_5  (_dtcmWrapper_io_sram_mask_5),
    .io_wmask_6  (_dtcmWrapper_io_sram_mask_6),
    .io_wmask_7  (_dtcmWrapper_io_sram_mask_7),
    .io_wmask_8  (_dtcmWrapper_io_sram_mask_8),
    .io_wmask_9  (_dtcmWrapper_io_sram_mask_9),
    .io_wmask_10 (_dtcmWrapper_io_sram_mask_10),
    .io_wmask_11 (_dtcmWrapper_io_sram_mask_11),
    .io_wmask_12 (_dtcmWrapper_io_sram_mask_12),
    .io_wmask_13 (_dtcmWrapper_io_sram_mask_13),
    .io_wmask_14 (_dtcmWrapper_io_sram_mask_14),
    .io_wmask_15 (_dtcmWrapper_io_sram_mask_15),
    .io_rdata_0  (_dtcm_io_rdata_0),
    .io_rdata_1  (_dtcm_io_rdata_1),
    .io_rdata_2  (_dtcm_io_rdata_2),
    .io_rdata_3  (_dtcm_io_rdata_3),
    .io_rdata_4  (_dtcm_io_rdata_4),
    .io_rdata_5  (_dtcm_io_rdata_5),
    .io_rdata_6  (_dtcm_io_rdata_6),
    .io_rdata_7  (_dtcm_io_rdata_7),
    .io_rdata_8  (_dtcm_io_rdata_8),
    .io_rdata_9  (_dtcm_io_rdata_9),
    .io_rdata_10 (_dtcm_io_rdata_10),
    .io_rdata_11 (_dtcm_io_rdata_11),
    .io_rdata_12 (_dtcm_io_rdata_12),
    .io_rdata_13 (_dtcm_io_rdata_13),
    .io_rdata_14 (_dtcm_io_rdata_14),
    .io_rdata_15 (_dtcm_io_rdata_15)
  );
  SRAM_1 dtcmWrapper (
    .clock                         (_rst_sync_clk_o),
    .reset                         (_global_reset_T_2),
    .io_fabric_readDataAddr_valid  (_dtcmArbiter_io_port_readDataAddr_valid),
    .io_fabric_readDataAddr_bits   (_dtcmArbiter_io_port_readDataAddr_bits),
    .io_fabric_readData_valid      (_dtcmWrapper_io_fabric_readData_valid),
    .io_fabric_readData_bits       (_dtcmWrapper_io_fabric_readData_bits),
    .io_fabric_writeDataAddr_valid (_dtcmArbiter_io_port_writeDataAddr_valid),
    .io_fabric_writeDataAddr_bits  (_dtcmArbiter_io_port_writeDataAddr_bits),
    .io_fabric_writeDataBits       (_dtcmArbiter_io_port_writeDataBits),
    .io_fabric_writeDataStrb       (_dtcmArbiter_io_port_writeDataStrb),
    .io_sram_address               (_dtcmWrapper_io_sram_address),
    .io_sram_enable                (_dtcmWrapper_io_sram_enable),
    .io_sram_isWrite               (_dtcmWrapper_io_sram_isWrite),
    .io_sram_readData_0            (_dtcm_io_rdata_0),
    .io_sram_readData_1            (_dtcm_io_rdata_1),
    .io_sram_readData_2            (_dtcm_io_rdata_2),
    .io_sram_readData_3            (_dtcm_io_rdata_3),
    .io_sram_readData_4            (_dtcm_io_rdata_4),
    .io_sram_readData_5            (_dtcm_io_rdata_5),
    .io_sram_readData_6            (_dtcm_io_rdata_6),
    .io_sram_readData_7            (_dtcm_io_rdata_7),
    .io_sram_readData_8            (_dtcm_io_rdata_8),
    .io_sram_readData_9            (_dtcm_io_rdata_9),
    .io_sram_readData_10           (_dtcm_io_rdata_10),
    .io_sram_readData_11           (_dtcm_io_rdata_11),
    .io_sram_readData_12           (_dtcm_io_rdata_12),
    .io_sram_readData_13           (_dtcm_io_rdata_13),
    .io_sram_readData_14           (_dtcm_io_rdata_14),
    .io_sram_readData_15           (_dtcm_io_rdata_15),
    .io_sram_writeData_0           (_dtcmWrapper_io_sram_writeData_0),
    .io_sram_writeData_1           (_dtcmWrapper_io_sram_writeData_1),
    .io_sram_writeData_2           (_dtcmWrapper_io_sram_writeData_2),
    .io_sram_writeData_3           (_dtcmWrapper_io_sram_writeData_3),
    .io_sram_writeData_4           (_dtcmWrapper_io_sram_writeData_4),
    .io_sram_writeData_5           (_dtcmWrapper_io_sram_writeData_5),
    .io_sram_writeData_6           (_dtcmWrapper_io_sram_writeData_6),
    .io_sram_writeData_7           (_dtcmWrapper_io_sram_writeData_7),
    .io_sram_writeData_8           (_dtcmWrapper_io_sram_writeData_8),
    .io_sram_writeData_9           (_dtcmWrapper_io_sram_writeData_9),
    .io_sram_writeData_10          (_dtcmWrapper_io_sram_writeData_10),
    .io_sram_writeData_11          (_dtcmWrapper_io_sram_writeData_11),
    .io_sram_writeData_12          (_dtcmWrapper_io_sram_writeData_12),
    .io_sram_writeData_13          (_dtcmWrapper_io_sram_writeData_13),
    .io_sram_writeData_14          (_dtcmWrapper_io_sram_writeData_14),
    .io_sram_writeData_15          (_dtcmWrapper_io_sram_writeData_15),
    .io_sram_mask_0                (_dtcmWrapper_io_sram_mask_0),
    .io_sram_mask_1                (_dtcmWrapper_io_sram_mask_1),
    .io_sram_mask_2                (_dtcmWrapper_io_sram_mask_2),
    .io_sram_mask_3                (_dtcmWrapper_io_sram_mask_3),
    .io_sram_mask_4                (_dtcmWrapper_io_sram_mask_4),
    .io_sram_mask_5                (_dtcmWrapper_io_sram_mask_5),
    .io_sram_mask_6                (_dtcmWrapper_io_sram_mask_6),
    .io_sram_mask_7                (_dtcmWrapper_io_sram_mask_7),
    .io_sram_mask_8                (_dtcmWrapper_io_sram_mask_8),
    .io_sram_mask_9                (_dtcmWrapper_io_sram_mask_9),
    .io_sram_mask_10               (_dtcmWrapper_io_sram_mask_10),
    .io_sram_mask_11               (_dtcmWrapper_io_sram_mask_11),
    .io_sram_mask_12               (_dtcmWrapper_io_sram_mask_12),
    .io_sram_mask_13               (_dtcmWrapper_io_sram_mask_13),
    .io_sram_mask_14               (_dtcmWrapper_io_sram_mask_14),
    .io_sram_mask_15               (_dtcmWrapper_io_sram_mask_15)
  );
  FabricArbiter dtcmArbiter (
    .clock                           (_rst_sync_clk_o),
    .reset                           (_global_reset_T_2),
    .io_source_0_readDataAddr_valid  (_core_io_dbus_valid & ~_core_io_dbus_write),
    .io_source_0_readDataAddr_bits   (_core_io_dbus_addr),
    .io_source_0_readData_bits       (_dtcmArbiter_io_source_0_readData_bits),
    .io_source_0_writeDataAddr_valid (_core_io_dbus_valid & _core_io_dbus_write),
    .io_source_0_writeDataAddr_bits  (_core_io_dbus_addr),
    .io_source_0_writeDataBits       (_core_io_dbus_wdata),
    .io_source_0_writeDataStrb       (_core_io_dbus_wmask),
    .io_source_1_readDataAddr_valid  (_fabricMux_io_ports_1_readDataAddr_valid),
    .io_source_1_readDataAddr_bits   (_fabricMux_io_ports_1_readDataAddr_bits),
    .io_source_1_readData_valid      (_dtcmArbiter_io_source_1_readData_valid),
    .io_source_1_readData_bits       (_dtcmArbiter_io_source_1_readData_bits),
    .io_source_1_writeDataAddr_valid (_fabricMux_io_ports_1_writeDataAddr_valid),
    .io_source_1_writeDataAddr_bits  (_fabricMux_io_ports_1_writeDataAddr_bits),
    .io_source_1_writeDataBits       (_fabricMux_io_ports_1_writeDataBits),
    .io_source_1_writeDataStrb       (_fabricMux_io_ports_1_writeDataStrb),
    .io_fabricBusy                   (_dtcmArbiter_io_fabricBusy),
    .io_port_readDataAddr_valid      (_dtcmArbiter_io_port_readDataAddr_valid),
    .io_port_readDataAddr_bits       (_dtcmArbiter_io_port_readDataAddr_bits),
    .io_port_readData_valid          (_dtcmWrapper_io_fabric_readData_valid),
    .io_port_readData_bits           (_dtcmWrapper_io_fabric_readData_bits),
    .io_port_writeDataAddr_valid     (_dtcmArbiter_io_port_writeDataAddr_valid),
    .io_port_writeDataAddr_bits      (_dtcmArbiter_io_port_writeDataAddr_bits),
    .io_port_writeDataBits           (_dtcmArbiter_io_port_writeDataBits),
    .io_port_writeDataStrb           (_dtcmArbiter_io_port_writeDataStrb)
  );
  FabricMux fabricMux (
    .clock                          (_rst_sync_clk_o),
    .reset                          (_global_reset_T_2),
    .io_source_readDataAddr_valid   (_axiSlave_io_fabric_readDataAddr_valid),
    .io_source_readDataAddr_bits    (_axiSlave_io_fabric_readDataAddr_bits),
    .io_source_readData_valid       (_fabricMux_io_source_readData_valid),
    .io_source_readData_bits        (_fabricMux_io_source_readData_bits),
    .io_source_writeDataAddr_valid  (_axiSlave_io_fabric_writeDataAddr_valid),
    .io_source_writeDataAddr_bits   (_axiSlave_io_fabric_writeDataAddr_bits),
    .io_source_writeDataBits        (_axiSlave_io_fabric_writeDataBits),
    .io_source_writeDataStrb        (_axiSlave_io_fabric_writeDataStrb),
    .io_source_writeResp            (_fabricMux_io_source_writeResp),
    .io_fabricBusy                  (_fabricMux_io_fabricBusy),
    .io_ports_0_readDataAddr_valid  (_fabricMux_io_ports_0_readDataAddr_valid),
    .io_ports_0_readDataAddr_bits   (_fabricMux_io_ports_0_readDataAddr_bits),
    .io_ports_0_readData_valid      (_itcmArbiter_io_source_1_readData_valid),
    .io_ports_0_readData_bits       (_itcmArbiter_io_source_1_readData_bits),
    .io_ports_0_writeDataAddr_valid (_fabricMux_io_ports_0_writeDataAddr_valid),
    .io_ports_0_writeDataAddr_bits  (_fabricMux_io_ports_0_writeDataAddr_bits),
    .io_ports_0_writeDataBits       (_fabricMux_io_ports_0_writeDataBits),
    .io_ports_0_writeDataStrb       (_fabricMux_io_ports_0_writeDataStrb),
    .io_ports_1_readDataAddr_valid  (_fabricMux_io_ports_1_readDataAddr_valid),
    .io_ports_1_readDataAddr_bits   (_fabricMux_io_ports_1_readDataAddr_bits),
    .io_ports_1_readData_valid      (_dtcmArbiter_io_source_1_readData_valid),
    .io_ports_1_readData_bits       (_dtcmArbiter_io_source_1_readData_bits),
    .io_ports_1_writeDataAddr_valid (_fabricMux_io_ports_1_writeDataAddr_valid),
    .io_ports_1_writeDataAddr_bits  (_fabricMux_io_ports_1_writeDataAddr_bits),
    .io_ports_1_writeDataBits       (_fabricMux_io_ports_1_writeDataBits),
    .io_ports_1_writeDataStrb       (_fabricMux_io_ports_1_writeDataStrb),
    .io_ports_2_readDataAddr_bits   (_fabricMux_io_ports_2_readDataAddr_bits),
    .io_ports_2_readData_valid      (_csr_io_fabric_readData_valid),
    .io_ports_2_readData_bits       (_csr_io_fabric_readData_bits),
    .io_ports_2_writeDataAddr_valid (_fabricMux_io_ports_2_writeDataAddr_valid),
    .io_ports_2_writeDataAddr_bits  (_fabricMux_io_ports_2_writeDataAddr_bits),
    .io_ports_2_writeDataBits       (_fabricMux_io_ports_2_writeDataBits),
    .io_ports_2_writeResp           (_csr_io_fabric_writeResp),
    .io_periBusy_0                  (_itcmArbiter_io_fabricBusy),
    .io_periBusy_1                  (_dtcmArbiter_io_fabricBusy)
  );
  AxiSlave axiSlave (
    .clock                         (_rst_sync_clk_o),
    .reset                         (_global_reset_T_2),
    .io_axi_write_addr_ready       (_axiSlave_io_axi_write_addr_ready),
    .io_axi_write_addr_valid       (io_axi_slave_write_addr_valid & axiSlaveEnable),
    .io_axi_write_addr_bits_addr   (io_axi_slave_write_addr_bits_addr),
    .io_axi_write_addr_bits_prot   (io_axi_slave_write_addr_bits_prot),
    .io_axi_write_addr_bits_id     (io_axi_slave_write_addr_bits_id),
    .io_axi_write_addr_bits_len    (io_axi_slave_write_addr_bits_len),
    .io_axi_write_addr_bits_size   (io_axi_slave_write_addr_bits_size),
    .io_axi_write_addr_bits_burst  (io_axi_slave_write_addr_bits_burst),
    .io_axi_write_addr_bits_lock   (io_axi_slave_write_addr_bits_lock),
    .io_axi_write_addr_bits_cache  (io_axi_slave_write_addr_bits_cache),
    .io_axi_write_addr_bits_qos    (io_axi_slave_write_addr_bits_qos),
    .io_axi_write_addr_bits_region (io_axi_slave_write_addr_bits_region),
    .io_axi_write_data_ready       (_axiSlave_io_axi_write_data_ready),
    .io_axi_write_data_valid       (io_axi_slave_write_data_valid & axiSlaveEnable),
    .io_axi_write_data_bits_data   (io_axi_slave_write_data_bits_data),
    .io_axi_write_data_bits_last   (io_axi_slave_write_data_bits_last),
    .io_axi_write_data_bits_strb   (io_axi_slave_write_data_bits_strb),
    .io_axi_write_resp_ready       (io_axi_slave_write_resp_ready & axiSlaveEnable),
    .io_axi_write_resp_valid       (_axiSlave_io_axi_write_resp_valid),
    .io_axi_write_resp_bits_id     (io_axi_slave_write_resp_bits_id),
    .io_axi_write_resp_bits_resp   (io_axi_slave_write_resp_bits_resp),
    .io_axi_read_addr_ready        (_axiSlave_io_axi_read_addr_ready),
    .io_axi_read_addr_valid        (io_axi_slave_read_addr_valid & axiSlaveEnable),
    .io_axi_read_addr_bits_addr    (io_axi_slave_read_addr_bits_addr),
    .io_axi_read_addr_bits_prot    (io_axi_slave_read_addr_bits_prot),
    .io_axi_read_addr_bits_id      (io_axi_slave_read_addr_bits_id),
    .io_axi_read_addr_bits_len     (io_axi_slave_read_addr_bits_len),
    .io_axi_read_addr_bits_size    (io_axi_slave_read_addr_bits_size),
    .io_axi_read_addr_bits_burst   (io_axi_slave_read_addr_bits_burst),
    .io_axi_read_addr_bits_lock    (io_axi_slave_read_addr_bits_lock),
    .io_axi_read_addr_bits_cache   (io_axi_slave_read_addr_bits_cache),
    .io_axi_read_addr_bits_qos     (io_axi_slave_read_addr_bits_qos),
    .io_axi_read_addr_bits_region  (io_axi_slave_read_addr_bits_region),
    .io_axi_read_data_ready        (io_axi_slave_read_data_ready & axiSlaveEnable),
    .io_axi_read_data_valid        (_axiSlave_io_axi_read_data_valid),
    .io_axi_read_data_bits_data    (io_axi_slave_read_data_bits_data),
    .io_axi_read_data_bits_id      (io_axi_slave_read_data_bits_id),
    .io_axi_read_data_bits_resp    (io_axi_slave_read_data_bits_resp),
    .io_axi_read_data_bits_last    (io_axi_slave_read_data_bits_last),
    .io_fabric_readDataAddr_valid  (_axiSlave_io_fabric_readDataAddr_valid),
    .io_fabric_readDataAddr_bits   (_axiSlave_io_fabric_readDataAddr_bits),
    .io_fabric_readData_valid      (_fabricMux_io_source_readData_valid),
    .io_fabric_readData_bits       (_fabricMux_io_source_readData_bits),
    .io_fabric_writeDataAddr_valid (_axiSlave_io_fabric_writeDataAddr_valid),
    .io_fabric_writeDataAddr_bits  (_axiSlave_io_fabric_writeDataAddr_bits),
    .io_fabric_writeDataBits       (_axiSlave_io_fabric_writeDataBits),
    .io_fabric_writeDataStrb       (_axiSlave_io_fabric_writeDataStrb),
    .io_fabric_writeResp           (_fabricMux_io_source_writeResp),
    .io_periBusy                   (_fabricMux_io_fabricBusy)
  );
  DBus2AxiV2 ebus2axi (
    .clock                       (_rst_sync_clk_o),
    .reset                       (_global_reset_T_2),
    .io_dbus_valid               (_core_io_ebus_dbus_valid),
    .io_dbus_ready               (_ebus2axi_io_dbus_ready),
    .io_dbus_write               (_core_io_ebus_dbus_write),
    .io_dbus_pc                  (_core_io_ebus_dbus_pc),
    .io_dbus_addr                (_core_io_ebus_dbus_addr),
    .io_dbus_size                (_core_io_ebus_dbus_size),
    .io_dbus_wdata               (_core_io_ebus_dbus_wdata),
    .io_dbus_wmask               (_core_io_ebus_dbus_wmask),
    .io_dbus_rdata               (_ebus2axi_io_dbus_rdata),
    .io_axi_write_addr_ready     (io_axi_master_write_addr_ready),
    .io_axi_write_addr_valid     (io_axi_master_write_addr_valid),
    .io_axi_write_addr_bits_addr (io_axi_master_write_addr_bits_addr),
    .io_axi_write_addr_bits_size (io_axi_master_write_addr_bits_size),
    .io_axi_write_data_ready     (io_axi_master_write_data_ready),
    .io_axi_write_data_valid     (io_axi_master_write_data_valid),
    .io_axi_write_data_bits_data (io_axi_master_write_data_bits_data),
    .io_axi_write_data_bits_last (io_axi_master_write_data_bits_last),
    .io_axi_write_data_bits_strb (io_axi_master_write_data_bits_strb),
    .io_axi_write_resp_ready     (io_axi_master_write_resp_ready),
    .io_axi_write_resp_valid     (io_axi_master_write_resp_valid),
    .io_axi_write_resp_bits_resp (io_axi_master_write_resp_bits_resp),
    .io_axi_read_addr_ready      (io_axi_master_read_addr_ready),
    .io_axi_read_addr_valid      (io_axi_master_read_addr_valid),
    .io_axi_read_addr_bits_addr  (io_axi_master_read_addr_bits_addr),
    .io_axi_read_addr_bits_size  (io_axi_master_read_addr_bits_size),
    .io_axi_read_data_ready      (io_axi_master_read_data_ready),
    .io_axi_read_data_valid      (io_axi_master_read_data_valid),
    .io_axi_read_data_bits_data  (io_axi_master_read_data_bits_data),
    .io_axi_read_data_bits_resp  (io_axi_master_read_data_bits_resp),
    .io_fault_valid              (_ebus2axi_io_fault_valid),
    .io_fault_bits_write         (_ebus2axi_io_fault_bits_write),
    .io_fault_bits_addr          (_ebus2axi_io_fault_bits_addr),
    .io_fault_bits_epc           (_ebus2axi_io_fault_bits_epc)
  );
  assign io_axi_slave_write_addr_ready =
    _axiSlave_io_axi_write_addr_ready & axiSlaveEnable;
  assign io_axi_slave_write_data_ready =
    _axiSlave_io_axi_write_data_ready & axiSlaveEnable;
  assign io_axi_slave_write_resp_valid =
    _axiSlave_io_axi_write_resp_valid & axiSlaveEnable;
  assign io_axi_slave_read_addr_ready = _axiSlave_io_axi_read_addr_ready & axiSlaveEnable;
  assign io_axi_slave_read_data_valid = _axiSlave_io_axi_read_data_valid & axiSlaveEnable;
  assign io_axi_master_write_addr_bits_prot = 3'h2;
  assign io_axi_master_write_addr_bits_id = 6'h0;
  assign io_axi_master_write_addr_bits_len = 8'h0;
  assign io_axi_master_write_addr_bits_burst = 2'h1;
  assign io_axi_master_write_addr_bits_lock = 1'h0;
  assign io_axi_master_write_addr_bits_cache = 4'h0;
  assign io_axi_master_write_addr_bits_qos = 4'h0;
  assign io_axi_master_write_addr_bits_region = 4'h0;
  assign io_axi_master_read_addr_bits_prot = 3'h2;
  assign io_axi_master_read_addr_bits_id = 6'h0;
  assign io_axi_master_read_addr_bits_len = 8'h0;
  assign io_axi_master_read_addr_bits_burst = 2'h1;
  assign io_axi_master_read_addr_bits_lock = 1'h0;
  assign io_axi_master_read_addr_bits_cache = 4'h0;
  assign io_axi_master_read_addr_bits_qos = 4'h0;
  assign io_axi_master_read_addr_bits_region = 4'h0;
  assign io_halted = _core_io_halted;
  assign io_fault = _core_io_fault;
  assign io_wfi = _core_io_wfi;
endmodule


// ----- 8< ----- FILE "verification/cover/layers-CoreMiniAxi-Verification_Cover.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
`ifndef layers_CoreMiniAxi_Verification_Cover
`define layers_CoreMiniAxi_Verification_Cover
`endif // layers_CoreMiniAxi_Verification_Cover

// ----- 8< ----- FILE "verification/assume/layers-CoreMiniAxi-Verification_Assume.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
`ifndef layers_CoreMiniAxi_Verification_Assume
`define layers_CoreMiniAxi_Verification_Assume
`endif // layers_CoreMiniAxi_Verification_Assume

// ----- 8< ----- FILE "verification/assert/layers-CoreMiniAxi-Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
`ifndef layers_CoreMiniAxi_Verification_Assert
`define layers_CoreMiniAxi_Verification_Assert
bind Regfile Regfile_Verification_Assert verification_Assert (
  ._GEN             (_valid_T_4),
  ._GEN_0           (valid_3),
  ._GEN_1           (_valid_T),
  ._GEN_2           (valid_1),
  .reset            (reset),
  ._GEN_3           (1'h1),
  ._GEN_4           (_valid_T_12),
  ._GEN_5           (valid_3_1),
  ._GEN_6           (_valid_T_8),
  ._GEN_7           (valid_1_1),
  ._GEN_8           (_valid_T_20),
  ._GEN_9           (valid_3_2),
  ._GEN_10          (_valid_T_16),
  ._GEN_11          (valid_1_2),
  ._GEN_12          (_valid_T_28),
  ._GEN_13          (valid_3_3),
  ._GEN_14          (_valid_T_24),
  ._GEN_15          (valid_1_3),
  ._GEN_16          (_valid_T_36),
  ._GEN_17          (valid_3_4),
  ._GEN_18          (_valid_T_32),
  ._GEN_19          (valid_1_4),
  ._GEN_20          (_valid_T_44),
  ._GEN_21          (valid_3_5),
  ._GEN_22          (_valid_T_40),
  ._GEN_23          (valid_1_5),
  ._GEN_24          (_valid_T_52),
  ._GEN_25          (valid_3_6),
  ._GEN_26          (_valid_T_48),
  ._GEN_27          (valid_1_6),
  ._GEN_28          (_valid_T_60),
  ._GEN_29          (valid_3_7),
  ._GEN_30          (_valid_T_56),
  ._GEN_31          (valid_1_7),
  ._GEN_32          (_valid_T_68),
  ._GEN_33          (valid_3_8),
  ._GEN_34          (_valid_T_64),
  ._GEN_35          (valid_1_8),
  ._GEN_36          (_valid_T_76),
  ._GEN_37          (valid_3_9),
  ._GEN_38          (_valid_T_72),
  ._GEN_39          (valid_1_9),
  ._GEN_40          (_valid_T_84),
  ._GEN_41          (valid_3_10),
  ._GEN_42          (_valid_T_80),
  ._GEN_43          (valid_1_10),
  ._GEN_44          (_valid_T_92),
  ._GEN_45          (valid_3_11),
  ._GEN_46          (_valid_T_88),
  ._GEN_47          (valid_1_11),
  ._GEN_48          (_valid_T_100),
  ._GEN_49          (valid_3_12),
  ._GEN_50          (_valid_T_96),
  ._GEN_51          (valid_1_12),
  ._GEN_52          (_valid_T_108),
  ._GEN_53          (valid_3_13),
  ._GEN_54          (_valid_T_104),
  ._GEN_55          (valid_1_13),
  ._GEN_56          (_valid_T_116),
  ._GEN_57          (valid_3_14),
  ._GEN_58          (_valid_T_112),
  ._GEN_59          (valid_1_14),
  ._GEN_60          (_valid_T_124),
  ._GEN_61          (valid_3_15),
  ._GEN_62          (_valid_T_120),
  ._GEN_63          (valid_1_15),
  ._GEN_64          (_valid_T_132),
  ._GEN_65          (valid_3_16),
  ._GEN_66          (_valid_T_128),
  ._GEN_67          (valid_1_16),
  ._GEN_68          (_valid_T_140),
  ._GEN_69          (valid_3_17),
  ._GEN_70          (_valid_T_136),
  ._GEN_71          (valid_1_17),
  ._GEN_72          (_valid_T_148),
  ._GEN_73          (valid_3_18),
  ._GEN_74          (_valid_T_144),
  ._GEN_75          (valid_1_18),
  ._GEN_76          (_valid_T_156),
  ._GEN_77          (valid_3_19),
  ._GEN_78          (_valid_T_152),
  ._GEN_79          (valid_1_19),
  ._GEN_80          (_valid_T_164),
  ._GEN_81          (valid_3_20),
  ._GEN_82          (_valid_T_160),
  ._GEN_83          (valid_1_20),
  ._GEN_84          (_valid_T_172),
  ._GEN_85          (valid_3_21),
  ._GEN_86          (_valid_T_168),
  ._GEN_87          (valid_1_21),
  ._GEN_88          (_valid_T_180),
  ._GEN_89          (valid_3_22),
  ._GEN_90          (_valid_T_176),
  ._GEN_91          (valid_1_22),
  ._GEN_92          (_valid_T_188),
  ._GEN_93          (valid_3_23),
  ._GEN_94          (_valid_T_184),
  ._GEN_95          (valid_1_23),
  ._GEN_96          (_valid_T_196),
  ._GEN_97          (valid_3_24),
  ._GEN_98          (_valid_T_192),
  ._GEN_99          (valid_1_24),
  ._GEN_100         (_valid_T_204),
  ._GEN_101         (valid_3_25),
  ._GEN_102         (_valid_T_200),
  ._GEN_103         (valid_1_25),
  ._GEN_104         (_valid_T_212),
  ._GEN_105         (valid_3_26),
  ._GEN_106         (_valid_T_208),
  ._GEN_107         (valid_1_26),
  ._GEN_108         (_valid_T_220),
  ._GEN_109         (valid_3_27),
  ._GEN_110         (_valid_T_216),
  ._GEN_111         (valid_1_27),
  ._GEN_112         (_valid_T_228),
  ._GEN_113         (valid_3_28),
  ._GEN_114         (_valid_T_224),
  ._GEN_115         (valid_1_28),
  ._GEN_116         (_valid_T_236),
  ._GEN_117         (valid_3_29),
  ._GEN_118         (_valid_T_232),
  ._GEN_119         (valid_1_29),
  ._GEN_120         (_valid_T_244),
  ._GEN_121         (valid_3_30),
  ._GEN_122         (_valid_T_240),
  ._GEN_123         (valid_1_30),
  .write_fail       (write_fail),
  .write_fail_1     (write_fail_1),
  .write_fail_2     (write_fail_2),
  .write_fail_3     (write_fail_3),
  .write_fail_4     (write_fail_4),
  .write_fail_5     (write_fail_5),
  .scoreboard_error (scoreboard_error),
  .clock            (clock)
);
bind CircularBufferMulti CircularBufferMulti_Verification_Assert verification_Assert (
  .io_nEnqueued (nEnqueued),
  .io_enqValid  (io_enqValid),
  .io_deqReady  (io_deqReady),
  .reset        (reset),
  ._GEN         (4'h8),
  .clock        (clock)
);
bind InstructionBuffer InstructionBuffer_Verification_Assert verification_Assert (
  ._GEN   (_nReady_T),
  ._GEN_0 (_nReady_T_1),
  ._GEN_1 (_nReady_T_2),
  ._GEN_2 (_nReady_T_3),
  .reset  (reset),
  .clock  (clock)
);
bind Csr Csr_Verification_Assert verification_Assert (
  ._GEN         (fflagsEn),
  ._GEN_0       (frmEn),
  .csr_address  (req_pipe_b_index),
  ._GEN_1       (fcsrEn),
  ._GEN_2       (mstatusEn),
  ._GEN_3       (misaEn),
  ._GEN_4       (mieEn),
  ._GEN_5       (mtvecEn),
  ._GEN_6       (mscratchEn),
  ._GEN_7       (mepcEn),
  ._GEN_8       (mcauseEn),
  ._GEN_9       (mtvalEn),
  ._GEN_10      (mcontext0En),
  ._GEN_11      (mcontext1En),
  ._GEN_12      (mcontext2En),
  ._GEN_13      (mcontext3En),
  ._GEN_14      (mcontext4En),
  ._GEN_15      (mcontext5En),
  ._GEN_16      (mcontext6En),
  ._GEN_17      (mcontext7En),
  ._GEN_18      (mpcEn),
  ._GEN_19      (mspEn),
  ._GEN_20      (mcycleEn),
  ._GEN_21      (minstretEn),
  ._GEN_22      (mcyclehEn),
  ._GEN_23      (minstrethEn),
  ._GEN_24      (mvendoridEn),
  ._GEN_25      (marchidEn),
  ._GEN_26      (mimpidEn),
  ._GEN_27      (mhartidEn),
  ._GEN_28      (kisaEn),
  ._GEN_29      (kscm0En),
  ._GEN_30      (kscm1En),
  ._GEN_31      (kscm2En),
  ._GEN_32      (kscm3En),
  ._GEN_33      (kscm4En),
  .req_valid    (req_pipe_v),
  .reset        (reset),
  .io_halted    (halted),
  .io_wfi       (wfi),
  .io_fault     (fault),
  .io_rs1_valid (io_rs1_valid),
  .clock        (clock)
);
bind Alu Alu_Verification_Assert verification_Assert (
  .io_rs1_valid    (io_rs1_valid),
  ._GEN            (op == 5'hA),
  .valid           (valid),
  .reset           (reset),
  .io_rs2_valid    (io_rs2_valid),
  ._rs1Only_WIRE_5 (op == 5'h15),
  ._rs1Only_WIRE_4 (op == 5'h16),
  ._rs1Only_WIRE_7 (op == 5'h1A),
  ._rs1Only_WIRE_6 (op == 5'h19),
  ._rs1Only_WIRE_1 (op == 5'hF),
  ._rs1Only_WIRE_0 (op == 5'hE),
  ._rs1Only_WIRE_3 (op == 5'h1B),
  ._rs1Only_WIRE_2 (op == 5'h10),
  .clock           (clock)
);
bind Bru Bru_Verification_Assert verification_Assert (
  .io_rs1_valid   (io_rs1_valid),
  .stateReg_valid (stateReg_valid),
  ._ignore_WIRE_5 (_ignore_T_5),
  ._ignore_WIRE_4 (_ignore_T_4),
  ._ignore_WIRE_7 (_ignore_T_7),
  ._ignore_WIRE_6 (_ignore_T_6),
  ._ignore_WIRE_1 (stateReg_bits_op == 4'h1),
  ._ignore_WIRE_0 (~(|stateReg_bits_op)),
  ._ignore_WIRE_3 (_ignore_T_3),
  ._ignore_WIRE_2 (_ignore_T_2),
  .reset          (reset),
  .io_rs2_valid   (io_rs2_valid),
  .clock          (clock)
);
bind Bru_1 Bru_1_Verification_Assert verification_Assert (
  ._GEN           (_ignore_T_6),
  ._GEN_0         (_ignore_T_5),
  ._GEN_1         (_ignore_T_3),
  ._GEN_2         (_ignore_T_2),
  ._GEN_3         (_ignore_T_4),
  .reset          (reset),
  .io_rs1_valid   (io_rs1_valid),
  .stateReg_valid (stateReg_valid),
  ._ignore_WIRE_5 (_ignore_T_5),
  ._ignore_WIRE_4 (_ignore_T_4),
  ._ignore_WIRE_7 (stateReg_bits_op == 4'hD),
  ._ignore_WIRE_6 (_ignore_T_6),
  ._ignore_WIRE_1 (stateReg_bits_op == 4'h1),
  ._ignore_WIRE_0 (~(|stateReg_bits_op)),
  ._ignore_WIRE_3 (_ignore_T_3),
  ._ignore_WIRE_2 (_ignore_T_2),
  .io_rs2_valid   (io_rs2_valid),
  .clock          (clock)
);
bind CircularBufferMulti_1 CircularBufferMulti_1_Verification_Assert verification_Assert (
  .io_nEnqueued (nEnqueued),
  .io_enqValid  (io_enqValid),
  .io_deqReady  (io_deqReady),
  .reset        (reset),
  ._GEN         (3'h4),
  .clock        (clock)
);
bind LsuV2 LsuV2_Verification_Assert verification_Assert (
  .reset               (reset),
  .opQueue_io_enqValid (opQueue_io_enqValid),
  .opQueue_io_nSpace   (_opQueue_io_nSpace),
  .lineActive_0        (lineActive_0),
  .lineActive_1        (lineActive_1),
  .wactive_1           (|selectionMatrix_1),
  .wactive_0           (|valueSet_1),
  .lineActive_2        (lineActive_2),
  .lineActive_3        (lineActive_3),
  .wactive_3           (|selectionMatrix_3),
  .wactive_2           (|selectionMatrix_2),
  .lineActive_4        (lineActive_4),
  .lineActive_5        (lineActive_5),
  .wactive_5           (|selectionMatrix_5),
  .wactive_4           (|selectionMatrix_4),
  .lineActive_6        (lineActive_6),
  .lineActive_7        (lineActive_7),
  .wactive_7           (|selectionMatrix_7),
  .wactive_6           (|selectionMatrix_6),
  .lineActive_8        (lineActive_8),
  .lineActive_9        (lineActive_9),
  .wactive_9           (|selectionMatrix_9),
  .wactive_8           (|selectionMatrix_8),
  .lineActive_10       (lineActive_10),
  .lineActive_11       (lineActive_11),
  .wactive_11          (|selectionMatrix_11),
  .wactive_10          (|selectionMatrix_10),
  .lineActive_12       (lineActive_12),
  .lineActive_13       (lineActive_13),
  .wactive_13          (|selectionMatrix_13),
  .wactive_12          (|selectionMatrix_12),
  .lineActive_14       (lineActive_14),
  .lineActive_15       (lineActive_15),
  .wactive_15          (|selectionMatrix_15),
  .wactive_14          (|selectionMatrix_14),
  .io_dbus_valid       (io_dbus_valid_0),
  ._GEN                (ebusFired),
  ._GEN_0              (ibusFired),
  ._GEN_1              (1'h1),
  .io_rd_valid         (io_rd_valid_0),
  .io_rd_flt_valid     (io_rd_flt_valid_0),
  .clock               (clock)
);
bind Mlu Mlu_Verification_Assert verification_Assert (
  .io_rs1_0_valid             (io_rs1_0_valid),
  .stage2Input_q_io_deq_valid (_stage2Input_q_io_deq_valid),
  ._GEN                       (_stage2Input_q_io_deq_bits_sel[0]),
  .reset                      (reset),
  .io_rs2_0_valid             (io_rs2_0_valid),
  .io_rs1_1_valid             (io_rs1_1_valid),
  ._GEN_0                     (_stage2Input_q_io_deq_bits_sel[1]),
  .io_rs2_1_valid             (io_rs2_1_valid),
  .clock                      (clock)
);
bind FloatCore FloatCore_Verification_Assert verification_Assert (
  .io_csr_out_frm (io_csr_out_frm),
  ._GEN           (1'h1),
  ._GEN_0         (2'h2),
  ._GEN_1         (2'h3),
  ._GEN_2         (3'h4),
  ._GEN_3         (3'h5),
  ._GEN_4         (reset),
  .clock          (clock)
);
bind FRegfile FRegfile_Verification_Assert verification_Assert (
  .reset            (reset),
  .scoreboard_error (scoreboard_error),
  .clock            (clock)
);
bind SCore SCore_Verification_Assert verification_Assert (
  .csr_io_rd_valid   (_csr_io_rd_valid),
  .alu_0_io_rd_valid (_alu_0_io_rd_valid),
  .bru_0_io_rd_valid (_bru_0_io_rd_valid),
  .reset             (reset),
  ._GEN              (1'h1),
  .alu_1_io_rd_valid (_alu_1_io_rd_valid),
  .bru_1_io_rd_valid (_bru_1_io_rd_valid),
  .clock             (clock)
);
bind FabricArbiter FabricArbiter_Verification_Assert verification_Assert (
  .io_source_0_readDataAddr_valid  (io_source_0_readDataAddr_valid),
  .io_source_0_writeDataAddr_valid (io_source_0_writeDataAddr_valid),
  .reset                           (reset),
  .io_source_1_readDataAddr_valid  (io_source_1_readDataAddr_valid),
  .io_source_1_writeDataAddr_valid (io_source_1_writeDataAddr_valid),
  .clock                           (clock)
);
bind FabricMux FabricMux_Verification_Assert verification_Assert (
  .io_source_readDataAddr_valid  (io_source_readDataAddr_valid),
  .io_source_writeDataAddr_valid (io_source_writeDataAddr_valid),
  .reset                         (reset),
  ._GEN                          (portSelected_1),
  ._GEN_0                        (_portSelected_T_7),
  ._GEN_1                        (portSelected_0),
  ._GEN_2                        (1'h1),
  .clock                         (clock)
);
bind AxiSlave AxiSlave_Verification_Assert verification_Assert (
  .readIssued_valid           (readIssued_valid),
  .reset                      (reset),
  .readDataQueue_io_enq_ready (_readDataQueue_io_enq_ready),
  .clock                      (clock)
);
bind DBus2AxiV2 DBus2AxiV2_Verification_Assert verification_Assert (
  .io_dbus_size  (io_dbus_size),
  ._GEN          (1'h1),
  .io_dbus_valid (io_dbus_valid),
  .reset         (reset),
  .clock         (clock)
);
`endif // layers_CoreMiniAxi_Verification_Assert

// ----- 8< ----- FILE "verification/assert/Regfile_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module Regfile_Verification_Assert(
  input _GEN,
        _GEN_0,
        _GEN_1,
        _GEN_2,
        reset,
        _GEN_3,
        _GEN_4,
        _GEN_5,
        _GEN_6,
        _GEN_7,
        _GEN_8,
        _GEN_9,
        _GEN_10,
        _GEN_11,
        _GEN_12,
        _GEN_13,
        _GEN_14,
        _GEN_15,
        _GEN_16,
        _GEN_17,
        _GEN_18,
        _GEN_19,
        _GEN_20,
        _GEN_21,
        _GEN_22,
        _GEN_23,
        _GEN_24,
        _GEN_25,
        _GEN_26,
        _GEN_27,
        _GEN_28,
        _GEN_29,
        _GEN_30,
        _GEN_31,
        _GEN_32,
        _GEN_33,
        _GEN_34,
        _GEN_35,
        _GEN_36,
        _GEN_37,
        _GEN_38,
        _GEN_39,
        _GEN_40,
        _GEN_41,
        _GEN_42,
        _GEN_43,
        _GEN_44,
        _GEN_45,
        _GEN_46,
        _GEN_47,
        _GEN_48,
        _GEN_49,
        _GEN_50,
        _GEN_51,
        _GEN_52,
        _GEN_53,
        _GEN_54,
        _GEN_55,
        _GEN_56,
        _GEN_57,
        _GEN_58,
        _GEN_59,
        _GEN_60,
        _GEN_61,
        _GEN_62,
        _GEN_63,
        _GEN_64,
        _GEN_65,
        _GEN_66,
        _GEN_67,
        _GEN_68,
        _GEN_69,
        _GEN_70,
        _GEN_71,
        _GEN_72,
        _GEN_73,
        _GEN_74,
        _GEN_75,
        _GEN_76,
        _GEN_77,
        _GEN_78,
        _GEN_79,
        _GEN_80,
        _GEN_81,
        _GEN_82,
        _GEN_83,
        _GEN_84,
        _GEN_85,
        _GEN_86,
        _GEN_87,
        _GEN_88,
        _GEN_89,
        _GEN_90,
        _GEN_91,
        _GEN_92,
        _GEN_93,
        _GEN_94,
        _GEN_95,
        _GEN_96,
        _GEN_97,
        _GEN_98,
        _GEN_99,
        _GEN_100,
        _GEN_101,
        _GEN_102,
        _GEN_103,
        _GEN_104,
        _GEN_105,
        _GEN_106,
        _GEN_107,
        _GEN_108,
        _GEN_109,
        _GEN_110,
        _GEN_111,
        _GEN_112,
        _GEN_113,
        _GEN_114,
        _GEN_115,
        _GEN_116,
        _GEN_117,
        _GEN_118,
        _GEN_119,
        _GEN_120,
        _GEN_121,
        _GEN_122,
        _GEN_123,
        write_fail,
        write_fail_1,
        write_fail_2,
        write_fail_3,
        write_fail_4,
        write_fail_5,
        scoreboard_error,
        clock
);

  `ifndef SYNTHESIS
    wire [2:0] _GEN_124 = {2'h0, _GEN_3};
    always @(posedge clock) begin
      if (~reset & {1'h0, {1'h0, _GEN_1} + {1'h0, _GEN_2}}
          + {1'h0, {1'h0, _GEN} + {1'h0, _GEN_0}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_6} + {1'h0, _GEN_7}}
          + {1'h0, {1'h0, _GEN_4} + {1'h0, _GEN_5}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_10} + {1'h0, _GEN_11}}
          + {1'h0, {1'h0, _GEN_8} + {1'h0, _GEN_9}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_14} + {1'h0, _GEN_15}}
          + {1'h0, {1'h0, _GEN_12} + {1'h0, _GEN_13}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_18} + {1'h0, _GEN_19}}
          + {1'h0, {1'h0, _GEN_16} + {1'h0, _GEN_17}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_22} + {1'h0, _GEN_23}}
          + {1'h0, {1'h0, _GEN_20} + {1'h0, _GEN_21}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_26} + {1'h0, _GEN_27}}
          + {1'h0, {1'h0, _GEN_24} + {1'h0, _GEN_25}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_30} + {1'h0, _GEN_31}}
          + {1'h0, {1'h0, _GEN_28} + {1'h0, _GEN_29}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_34} + {1'h0, _GEN_35}}
          + {1'h0, {1'h0, _GEN_32} + {1'h0, _GEN_33}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_38} + {1'h0, _GEN_39}}
          + {1'h0, {1'h0, _GEN_36} + {1'h0, _GEN_37}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_42} + {1'h0, _GEN_43}}
          + {1'h0, {1'h0, _GEN_40} + {1'h0, _GEN_41}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_46} + {1'h0, _GEN_47}}
          + {1'h0, {1'h0, _GEN_44} + {1'h0, _GEN_45}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_50} + {1'h0, _GEN_51}}
          + {1'h0, {1'h0, _GEN_48} + {1'h0, _GEN_49}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_54} + {1'h0, _GEN_55}}
          + {1'h0, {1'h0, _GEN_52} + {1'h0, _GEN_53}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_58} + {1'h0, _GEN_59}}
          + {1'h0, {1'h0, _GEN_56} + {1'h0, _GEN_57}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_62} + {1'h0, _GEN_63}}
          + {1'h0, {1'h0, _GEN_60} + {1'h0, _GEN_61}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_66} + {1'h0, _GEN_67}}
          + {1'h0, {1'h0, _GEN_64} + {1'h0, _GEN_65}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_70} + {1'h0, _GEN_71}}
          + {1'h0, {1'h0, _GEN_68} + {1'h0, _GEN_69}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_74} + {1'h0, _GEN_75}}
          + {1'h0, {1'h0, _GEN_72} + {1'h0, _GEN_73}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_78} + {1'h0, _GEN_79}}
          + {1'h0, {1'h0, _GEN_76} + {1'h0, _GEN_77}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_82} + {1'h0, _GEN_83}}
          + {1'h0, {1'h0, _GEN_80} + {1'h0, _GEN_81}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_86} + {1'h0, _GEN_87}}
          + {1'h0, {1'h0, _GEN_84} + {1'h0, _GEN_85}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_90} + {1'h0, _GEN_91}}
          + {1'h0, {1'h0, _GEN_88} + {1'h0, _GEN_89}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_94} + {1'h0, _GEN_95}}
          + {1'h0, {1'h0, _GEN_92} + {1'h0, _GEN_93}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_98} + {1'h0, _GEN_99}}
          + {1'h0, {1'h0, _GEN_96} + {1'h0, _GEN_97}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_102} + {1'h0, _GEN_103}}
          + {1'h0, {1'h0, _GEN_100} + {1'h0, _GEN_101}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_106} + {1'h0, _GEN_107}}
          + {1'h0, {1'h0, _GEN_104} + {1'h0, _GEN_105}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_110} + {1'h0, _GEN_111}}
          + {1'h0, {1'h0, _GEN_108} + {1'h0, _GEN_109}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_114} + {1'h0, _GEN_115}}
          + {1'h0, {1'h0, _GEN_112} + {1'h0, _GEN_113}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_118} + {1'h0, _GEN_119}}
          + {1'h0, {1'h0, _GEN_116} + {1'h0, _GEN_117}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_122} + {1'h0, _GEN_123}}
          + {1'h0, {1'h0, _GEN_120} + {1'h0, _GEN_121}} > _GEN_124) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:148\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_1) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_2) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_3) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_4) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_5) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & scoreboard_error) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:241\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/CircularBufferMulti_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module CircularBufferMulti_Verification_Assert(
  input [3:0] io_nEnqueued,
  input [2:0] io_enqValid,
              io_deqReady,
  input       reset,
  input [3:0] _GEN,
  input       clock
);

  `ifndef SYNTHESIS
    wire [4:0] _GEN_0 = {1'h0, io_nEnqueued};
    wire [4:0] _GEN_1 = {2'h0, io_enqValid};
    always @(posedge clock) begin
      if (~reset & {1'h0, _GEN_0 + _GEN_1} - {3'h0, io_deqReady} > {2'h0, _GEN}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:43\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_1 > {1'h0, _GEN} - _GEN_0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:44\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, io_deqReady} > io_nEnqueued) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:46\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/InstructionBuffer_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module InstructionBuffer_Verification_Assert(
  input _GEN,
        _GEN_0,
        _GEN_1,
        _GEN_2,
        reset,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & (~_GEN & _GEN_0 | ~_GEN_0 & _GEN_1 | ~_GEN_1 & _GEN_2)) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed: OneHotInOrder - Instructions not dispatched in order.\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/Csr_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module Csr_Verification_Assert(
  input        _GEN,
               _GEN_0,
  input [11:0] csr_address,
  input        _GEN_1,
               _GEN_2,
               _GEN_3,
               _GEN_4,
               _GEN_5,
               _GEN_6,
               _GEN_7,
               _GEN_8,
               _GEN_9,
               _GEN_10,
               _GEN_11,
               _GEN_12,
               _GEN_13,
               _GEN_14,
               _GEN_15,
               _GEN_16,
               _GEN_17,
               _GEN_18,
               _GEN_19,
               _GEN_20,
               _GEN_21,
               _GEN_22,
               _GEN_23,
               _GEN_24,
               _GEN_25,
               _GEN_26,
               _GEN_27,
               _GEN_28,
               _GEN_29,
               _GEN_30,
               _GEN_31,
               _GEN_32,
               _GEN_33,
               req_valid,
               reset,
               io_halted,
               io_wfi,
               io_fault,
               io_rs1_valid,
               clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & req_valid
          & ~(_GEN | _GEN_0 | _GEN_1 | csr_address == 12'h8 | csr_address == 12'h9
              | csr_address == 12'hA | _GEN_2 | _GEN_3 | _GEN_4 | _GEN_5 | _GEN_6 | _GEN_7
              | _GEN_8 | _GEN_9 | csr_address == 12'h7A0 | csr_address == 12'h7A1
              | csr_address == 12'h7A2 | csr_address == 12'h7A4 | csr_address == 12'h7B0
              | csr_address == 12'h7B1 | csr_address == 12'h7B2 | csr_address == 12'h7B3
              | _GEN_10 | _GEN_11 | _GEN_12 | _GEN_13 | _GEN_14 | _GEN_15 | _GEN_16
              | _GEN_17 | _GEN_18 | _GEN_19 | _GEN_20 | _GEN_21 | _GEN_22 | _GEN_23
              | csr_address == 12'hC20 | csr_address == 12'hC21 | csr_address == 12'hC22
              | _GEN_24 | _GEN_25 | _GEN_26 | _GEN_27 | _GEN_28 | _GEN_29 | _GEN_30
              | _GEN_31 | _GEN_32 | _GEN_33)) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Csr.scala:293\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & io_fault & ~io_halted & ~io_wfi) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Csr.scala:364\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & req_valid & ~io_rs1_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Csr.scala:591\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/Alu_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module Alu_Verification_Assert(
  input io_rs1_valid,
        _GEN,
        valid,
        reset,
        io_rs2_valid,
        _rs1Only_WIRE_5,
        _rs1Only_WIRE_4,
        _rs1Only_WIRE_7,
        _rs1Only_WIRE_6,
        _rs1Only_WIRE_1,
        _rs1Only_WIRE_0,
        _rs1Only_WIRE_3,
        _rs1Only_WIRE_2,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & valid & ~io_rs1_valid & ~_GEN) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Alu.scala:159\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & valid & ~io_rs2_valid
          & {_rs1Only_WIRE_7,
             _rs1Only_WIRE_6,
             _rs1Only_WIRE_5,
             _rs1Only_WIRE_4,
             _rs1Only_WIRE_3,
             _rs1Only_WIRE_2,
             _rs1Only_WIRE_1,
             _rs1Only_WIRE_0} == 8'h0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Alu.scala:160\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/Bru_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module Bru_Verification_Assert(
  input io_rs1_valid,
        stateReg_valid,
        _ignore_WIRE_5,
        _ignore_WIRE_4,
        _ignore_WIRE_7,
        _ignore_WIRE_6,
        _ignore_WIRE_1,
        _ignore_WIRE_0,
        _ignore_WIRE_3,
        _ignore_WIRE_2,
        reset,
        io_rs2_valid,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset
          & {~(stateReg_valid & ~io_rs1_valid),
             _ignore_WIRE_7,
             _ignore_WIRE_6,
             _ignore_WIRE_5,
             _ignore_WIRE_4,
             _ignore_WIRE_3,
             _ignore_WIRE_2,
             _ignore_WIRE_1,
             _ignore_WIRE_0} == 9'h0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Bru.scala:264\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {~(stateReg_valid & ~io_rs2_valid),
             _ignore_WIRE_7,
             _ignore_WIRE_6,
             _ignore_WIRE_5,
             _ignore_WIRE_4,
             _ignore_WIRE_3,
             _ignore_WIRE_2,
             _ignore_WIRE_1,
             _ignore_WIRE_0} == 9'h0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Bru.scala:265\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/Bru_1_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module Bru_1_Verification_Assert(
  input _GEN,
        _GEN_0,
        _GEN_1,
        _GEN_2,
        _GEN_3,
        reset,
        io_rs1_valid,
        stateReg_valid,
        _ignore_WIRE_5,
        _ignore_WIRE_4,
        _ignore_WIRE_7,
        _ignore_WIRE_6,
        _ignore_WIRE_1,
        _ignore_WIRE_0,
        _ignore_WIRE_3,
        _ignore_WIRE_2,
        io_rs2_valid,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & (|{_GEN, _GEN_0, _GEN_3, _GEN_1, _GEN_2})) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Bru.scala:162\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {~(stateReg_valid & ~io_rs1_valid),
             _ignore_WIRE_7,
             _ignore_WIRE_6,
             _ignore_WIRE_5,
             _ignore_WIRE_4,
             _ignore_WIRE_3,
             _ignore_WIRE_2,
             _ignore_WIRE_1,
             _ignore_WIRE_0} == 9'h0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Bru.scala:264\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {~(stateReg_valid & ~io_rs2_valid),
             _ignore_WIRE_7,
             _ignore_WIRE_6,
             _ignore_WIRE_5,
             _ignore_WIRE_4,
             _ignore_WIRE_3,
             _ignore_WIRE_2,
             _ignore_WIRE_1,
             _ignore_WIRE_0} == 9'h0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Bru.scala:265\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/CircularBufferMulti_1_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module CircularBufferMulti_1_Verification_Assert(
  input [2:0] io_nEnqueued,
  input [1:0] io_enqValid,
              io_deqReady,
  input       reset,
  input [2:0] _GEN,
  input       clock
);

  `ifndef SYNTHESIS
    wire [3:0] _GEN_0 = {1'h0, io_nEnqueued};
    wire [3:0] _GEN_1 = {2'h0, io_enqValid};
    always @(posedge clock) begin
      if (~reset & {1'h0, _GEN_0 + _GEN_1} - {3'h0, io_deqReady} > {2'h0, _GEN}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:43\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_1 > {1'h0, _GEN} - _GEN_0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:44\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, io_deqReady} > io_nEnqueued) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:46\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/LsuV2_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module LsuV2_Verification_Assert(
  input       reset,
  input [1:0] opQueue_io_enqValid,
  input [2:0] opQueue_io_nSpace,
  input       lineActive_0,
              lineActive_1,
              wactive_1,
              wactive_0,
              lineActive_2,
              lineActive_3,
              wactive_3,
              wactive_2,
              lineActive_4,
              lineActive_5,
              wactive_5,
              wactive_4,
              lineActive_6,
              lineActive_7,
              wactive_7,
              wactive_6,
              lineActive_8,
              lineActive_9,
              wactive_9,
              wactive_8,
              lineActive_10,
              lineActive_11,
              wactive_11,
              wactive_10,
              lineActive_12,
              lineActive_13,
              wactive_13,
              wactive_12,
              lineActive_14,
              lineActive_15,
              wactive_15,
              wactive_14,
              io_dbus_valid,
              _GEN,
              _GEN_0,
              _GEN_1,
              io_rd_valid,
              io_rd_flt_valid,
              clock
);

  `ifndef SYNTHESIS
    wire [1:0] _GEN_2 = {1'h0, _GEN_1};
    always @(posedge clock) begin
      if (~reset & {1'h0, opQueue_io_enqValid} > opQueue_io_nSpace) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Lsu.scala:888\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & (|({1'h0,
                {1'h0,
                 {1'h0,
                  {1'h0, wactive_0 & ~lineActive_0} + {1'h0, wactive_1 & ~lineActive_1}}
                   + {1'h0,
                      {1'h0, wactive_2 & ~lineActive_2}
                        + {1'h0, wactive_3 & ~lineActive_3}}}
                  + {1'h0,
                     {1'h0,
                      {1'h0, wactive_4 & ~lineActive_4}
                        + {1'h0, wactive_5 & ~lineActive_5}}
                       + {1'h0,
                          {1'h0, wactive_6 & ~lineActive_6}
                            + {1'h0, wactive_7 & ~lineActive_7}}}}
               + {1'h0,
                  {1'h0,
                   {1'h0,
                    {1'h0, wactive_8 & ~lineActive_8} + {1'h0, wactive_9 & ~lineActive_9}}
                     + {1'h0,
                        {1'h0, wactive_10 & ~lineActive_10}
                          + {1'h0, wactive_11 & ~lineActive_11}}}
                    + {1'h0,
                       {1'h0,
                        {1'h0, wactive_12 & ~lineActive_12}
                          + {1'h0, wactive_13 & ~lineActive_13}}
                         + {1'h0,
                            {1'h0, wactive_14 & ~lineActive_14}
                              + {1'h0, wactive_15 & ~lineActive_15}}}}))) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at ScatterGather.scala:94\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_0} + {1'h0, io_dbus_valid} + {1'h0, _GEN} > _GEN_2) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Lsu.scala:971\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, io_rd_valid} + {1'h0, io_rd_flt_valid} > _GEN_2) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Lsu.scala:1036\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/Mlu_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module Mlu_Verification_Assert(
  input io_rs1_0_valid,
        stage2Input_q_io_deq_valid,
        _GEN,
        reset,
        io_rs2_0_valid,
        io_rs1_1_valid,
        _GEN_0,
        io_rs2_1_valid,
        clock
);

  `ifndef SYNTHESIS
    wire _GEN_1 = stage2Input_q_io_deq_valid & _GEN;
    wire _GEN_2 = stage2Input_q_io_deq_valid & _GEN_0;
    always @(posedge clock) begin
      if (~reset & _GEN_1 & ~io_rs1_0_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Mlu.scala:120\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_1 & ~io_rs2_0_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Mlu.scala:121\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_2 & ~io_rs1_1_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Mlu.scala:120\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_2 & ~io_rs2_1_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Mlu.scala:121\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/FloatCore_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module FloatCore_Verification_Assert(
  input [2:0] io_csr_out_frm,
  input       _GEN,
  input [1:0] _GEN_0,
              _GEN_1,
  input [2:0] _GEN_2,
              _GEN_3,
  input       _GEN_4,
              clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~_GEN_4
          & ~(io_csr_out_frm == 3'h0 | io_csr_out_frm == {2'h0, _GEN}
              | io_csr_out_frm == {1'h0, _GEN_0} | io_csr_out_frm == {1'h0, _GEN_1}
              | io_csr_out_frm == _GEN_2 | io_csr_out_frm == _GEN_3
              | (&io_csr_out_frm))) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at FloatCore.scala:311\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/FRegfile_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module FRegfile_Verification_Assert(
  input reset,
        scoreboard_error,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & scoreboard_error) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at FRegfile.scala:47\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/SCore_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module SCore_Verification_Assert(
  input csr_io_rd_valid,
        alu_0_io_rd_valid,
        bru_0_io_rd_valid,
        reset,
        _GEN,
        alu_1_io_rd_valid,
        bru_1_io_rd_valid,
        clock
);

  `ifndef SYNTHESIS
    wire [2:0] _GEN_0 = {2'h0, _GEN};
    always @(posedge clock) begin
      if (~reset & {1'h0, {1'h0, csr_io_rd_valid} + {1'h0, alu_0_io_rd_valid}}
          + {2'h0, bru_0_io_rd_valid} > _GEN_0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at SCore.scala:311\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0, {1'h0, alu_1_io_rd_valid} + {1'h0, bru_1_io_rd_valid}} > _GEN_0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at SCore.scala:311\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/FabricArbiter_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module FabricArbiter_Verification_Assert(
  input io_source_0_readDataAddr_valid,
        io_source_0_writeDataAddr_valid,
        reset,
        io_source_1_readDataAddr_valid,
        io_source_1_writeDataAddr_valid,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & io_source_0_readDataAddr_valid & io_source_0_writeDataAddr_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Fabric.scala:31\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & io_source_1_readDataAddr_valid & io_source_1_writeDataAddr_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Fabric.scala:32\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/FabricMux_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module FabricMux_Verification_Assert(
  input io_source_readDataAddr_valid,
        io_source_writeDataAddr_valid,
        reset,
        _GEN,
        _GEN_0,
        _GEN_1,
        _GEN_2,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & io_source_readDataAddr_valid & io_source_writeDataAddr_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Fabric.scala:68\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_1} + {1'h0, _GEN} + {1'h0, _GEN_0} > {1'h0, _GEN_2}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Fabric.scala:84\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/AxiSlave_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module AxiSlave_Verification_Assert(
  input readIssued_valid,
        reset,
        readDataQueue_io_enq_ready,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & ~(~readIssued_valid | readDataQueue_io_enq_ready)) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at AxiSlave.scala:130\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/DBus2AxiV2_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module DBus2AxiV2_Verification_Assert(
  input [4:0] io_dbus_size,
  input       _GEN,
              io_dbus_valid,
              reset,
              clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & io_dbus_valid
          & {1'h0, {1'h0, io_dbus_size[0]} + {1'h0, io_dbus_size[1]}}
          + {1'h0,
             {1'h0, io_dbus_size[2]} + {1'h0, io_dbus_size[3]}
               + {1'h0, io_dbus_size[4]}} != {2'h0, _GEN}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed: Invalid dbus size=%d\n", io_dbus_size);
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "./RstSync.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// A module for synchronizing Asynchronous external reset to
// an internal synchronous deassert reset
// Clock is disabled while reset is asserted to prevent a race
// between clock and reset.
module RstSync
    (
        // Input clock
        input clk_i,
        // Input active-low async reset
        input rstn_i,
        // Functional clock gate enable. clk_o is enabled when clk_en
        // is 1, and we are out of reset
        // clk_en is assumed to be synchronous to clk_o or clk_i
        input clk_en,
        input te,

        // Output clock
        output clk_o,
        // Output reset active low
        output rstn_o);

  localparam RST_DELAY = 2;
  localparam CLK_DELAY = 2;

  logic [RST_DELAY + CLK_DELAY - 1 : 0] rst_delay_reg;
  always_ff @(posedge clk_i or negedge rstn_i) begin
    if (~rstn_i)
      rst_delay_reg <= '0;
    else
      rst_delay_reg <= {rst_delay_reg[RST_DELAY + CLK_DELAY - 2 : 0], 1'b1};
  end

  assign rstn_o = rst_delay_reg[RST_DELAY - 1];

  logic clk_en_int;
  assign clk_en_int = clk_en & rst_delay_reg[CLK_DELAY + RST_DELAY - 1];

  ClockGate icg(.clk_i(clk_i),
                .enable(clk_en_int),
                .te(te),
                .clk_o(clk_o));

`ifndef SYNTHESIS
  initial begin
    assert (RST_DELAY >= 2);
    assert (CLK_DELAY >= 2);
  end
`endif
endmodule
// ----- 8< ----- FILE "./ClockGate.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// A ClockGate module. The underlying implementation varies based on
// preprocessor.
// Default: ASIC implementation
// USE_GENERIC default: Verilator implementation (adapted from OpenTitan)
// USE_GENERIC and FPGA_XILINX: UltraScale Plus specific clockgate.
module ClockGate(
  input         clk_i,
  input         enable,  // '1' passthrough, '0' disable.
  input         te,      // test enable
  output        clk_o
);

///////////////////////////
/// ClockGate Selection ///
///////////////////////////
`ifdef USE_TSMC12FFC
  // TSMC12FFC Specific ClockGate
  CKLNQD10BWP6T20P96CPDLVT u_cg(
    .TE(te),
    .E(enable),
    .CP(clk_i),
    .Q(clk_o)
  );
`elsif USE_GF22
  // GF22 Specific ClockGate
  SC7P5T_CKGPRELATNX8_CSC36L u_cg (
    .CLK(clk_i),
    .E(enable),
    .TE(te),
    .Z(clk_o)
  );

`elsif FPGA_XILINX
  // Xilinx FPGA Specific ClockGate
  BUFGCE #(
    .SIM_DEVICE("ULTRASCALE_PLUS")
  ) u_bufgce (
    .I (clk_i),
    .CE(enable | te),
    .O (clk_o)
  );
`else
  // Default: Verilator implementation
  logic en_latch /* verilator clock_enable */;
  always_latch begin
    if (!clk_i) begin
      en_latch = enable | te;
    end
  end
  assign clk_o = en_latch & clk_i;
`endif

endmodule  // ClockGate
// ----- 8< ----- FILE "./Aligner.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// A module that moves valid inputs to the front of the output.
// Example:
// valid_in = [0, 1, 0, 1], data_in = [A, B, C, D]
// valid_out = [1, 1, 0, 0], data_out = [B, D, X, X]
module Aligner#(type T=logic [7:0], parameter N = 8)
(
  // Command input.
  input logic [N-1:0] valid_in,
  input T [N-1:0] data_in,

  // Command output.
  output logic [N-1:0] valid_out,
  output T [N-1:0] data_out
);
/* verilator lint_off WIDTHEXPAND */
/* verilator lint_off WIDTHTRUNC */
  localparam COUNTBITS = $clog2(N);
  typedef logic [COUNTBITS-1:0] count_t;

  // Build count
  count_t valid_count [N-1:0];
  always_comb begin
    valid_count[0] = 0;
    for (int i = 0; i < N-1; i++) begin
        valid_count[i+1] = valid_count[i] + valid_in[i];
    end
  end

  logic [N-1:0][N-1:0] output_valid_map;
  count_t valid_idx [N-1:0];
  always_comb begin
    
    for (int o = 0; o < N; o++) begin
      valid_idx[o] = 0;
      for (int i = 0; i < N; i++) begin
        output_valid_map[o][i] = (valid_count[i] == o) && valid_in[i];
        valid_idx[o] = valid_idx[o] | (output_valid_map[o][i] ? i : 0);
      end

      // Assign outputs
      valid_out[o] = |output_valid_map[o];
      data_out[o] = data_in[valid_idx[o]];
    end
  end
/* verilator lint_on WIDTHTRUNC */
/* verilator lint_on WIDTHEXPAND */

endmodule
// ----- 8< ----- FILE "./Aligner_107_2.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
module Aligner_107_2(
  input logic in_0_valid,
  input logic in_1_valid,
  input logic [107-1:0] in_0_bits,
  input logic [107-1:0] in_1_bits,
  output logic out_0_valid,
  output logic out_1_valid,
  output logic [107-1:0] out_0_bits,
  output logic [107-1:0] out_1_bits);

  logic [2-1:0] valid_in;
  assign valid_in[0] = in_0_valid;
  assign valid_in[1] = in_1_valid;
  logic [2-1:0][107-1:0] data_in;
  assign data_in[0] = in_0_bits;
  assign data_in[1] = in_1_bits;
  logic [2-1:0] valid_out;
  assign out_0_valid = valid_out[0];
  assign out_1_valid = valid_out[1];
  logic [2-1:0][107-1:0] data_out;
  assign out_0_bits = data_out[0];
  assign out_1_bits = data_out[1];

  Aligner#(.T (logic [107-1:0]), .N(2)) aligner(
    valid_in,
    data_in,
    valid_out,
    data_out
  );
endmodule
// ----- 8< ----- FILE "./registers.svh" ----- 8< -----

// Copyright 2018 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Common register defines for RTL designs
`ifndef COMMON_CELLS_REGISTERS_SVH_
`define COMMON_CELLS_REGISTERS_SVH_

// Abridged Summary of available FF macros:
// `FF:      asynchronous active-low reset (implicit clock and reset)
// `FFAR:    asynchronous active-high reset
// `FFARN:   asynchronous active-low reset
// `FFSR:    synchronous active-high reset
// `FFSRN:   synchronous active-low reset
// `FFNR:    without reset
// `FFL:     load-enable and asynchronous active-low reset (implicit clock and reset)
// `FFLAR:   load-enable and asynchronous active-high reset
// `FFLARN:  load-enable and asynchronous active-low reset
// `FFLARNC: load-enable and asynchronous active-low reset and synchronous active-high clear
// `FFLSR:   load-enable and synchronous active-high reset
// `FFLSRN:  load-enable and synchronous active-low reset
// `FFLNR:   load-enable without reset


// Flip-Flop with asynchronous active-low reset (implicit clock and reset)
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// Implicit:
// clk_i: clock input
// rst_ni: reset input (asynchronous, active low)
`define FF(__q, __d, __reset_value)                  \
  always_ff @(posedge clk_i or negedge rst_ni) begin \
    if (!rst_ni) begin                               \
      __q <= (__reset_value);                        \
    end else begin                                   \
      __q <= (__d);                                  \
    end                                              \
  end

// Flip-Flop with asynchronous active-high reset
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst: asynchronous reset
`define FFAR(__q, __d, __reset_value, __clk, __arst)     \
  always_ff @(posedge (__clk) or posedge (__arst)) begin \
    if (__arst) begin                                    \
      __q <= (__reset_value);                            \
    end else begin                                       \
      __q <= (__d);                                      \
    end                                                  \
  end

// Flip-Flop with asynchronous active-low reset
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst_n: asynchronous reset
`define FFARN(__q, __d, __reset_value, __clk, __arst_n)    \
  always_ff @(posedge (__clk) or negedge (__arst_n)) begin \
    if (!__arst_n) begin                                   \
      __q <= (__reset_value);                              \
    end else begin                                         \
      __q <= (__d);                                        \
    end                                                    \
  end

// Flip-Flop with synchronous active-high reset
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __reset_clk: reset input
`define FFSR(__q, __d, __reset_value, __clk, __reset_clk) \
  `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__reset_clk`" *``/       \
    `endif                        \
  always_ff @(posedge (__clk)) begin                      \
    __q <= (__reset_clk) ? (__reset_value) : (__d);       \
  end

// Flip-Flop with synchronous active-low reset
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __reset_n_clk: reset input
`define FFSRN(__q, __d, __reset_value, __clk, __reset_n_clk) \
    `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__reset_n_clk`" *``/        \
    `endif                        \
  always_ff @(posedge (__clk)) begin                         \
    __q <= (!__reset_n_clk) ? (__reset_value) : (__d);       \
  end

// Always-enable Flip-Flop without reset
// __q: Q output of FF
// __d: D input of FF
// __clk: clock input
`define FFNR(__q, __d, __clk)        \
  always_ff @(posedge (__clk)) begin \
    __q <= (__d);                    \
  end

// Flip-Flop with load-enable and asynchronous active-low reset (implicit clock and reset)
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// Implicit:
// clk_i: clock input
// rst_ni: reset input (asynchronous, active low)
`define FFL(__q, __d, __load, __reset_value)         \
  always_ff @(posedge clk_i or negedge rst_ni) begin \
    if (!rst_ni) begin                               \
      __q <= (__reset_value);                        \
    end else begin                                   \
      __q <= (__load) ? (__d) : (__q);               \
    end                                              \
  end

// Flip-Flop with load-enable and asynchronous active-high reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst: asynchronous reset
`define FFLAR(__q, __d, __load, __reset_value, __clk, __arst) \
  always_ff @(posedge (__clk) or posedge (__arst)) begin      \
    if (__arst) begin                                         \
      __q <= (__reset_value);                                 \
    end else begin                                            \
      __q <= (__load) ? (__d) : (__q);                        \
    end                                                       \
  end

// Flip-Flop with load-enable and asynchronous active-low reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst_n: asynchronous reset
`define FFLARN(__q, __d, __load, __reset_value, __clk, __arst_n) \
  always_ff @(posedge (__clk) or negedge (__arst_n)) begin       \
    if (!__arst_n) begin                                         \
      __q <= (__reset_value);                                    \
    end else begin                                               \
      __q <= (__load) ? (__d) : (__q);                           \
    end                                                          \
  end

// Flip-Flop with load-enable and synchronous active-high reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __reset_clk: reset input
`define FFLSR(__q, __d, __load, __reset_value, __clk, __reset_clk)       \
    `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__reset_clk`" *``/                      \
    `endif                        \
  always_ff @(posedge (__clk)) begin                                     \
    __q <= (__reset_clk) ? (__reset_value) : ((__load) ? (__d) : (__q)); \
  end

// Flip-Flop with load-enable and synchronous active-low reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __reset_n_clk: reset input
`define FFLSRN(__q, __d, __load, __reset_value, __clk, __reset_n_clk)       \
    `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__reset_n_clk`" *``/                       \
    `endif                        \
  always_ff @(posedge (__clk)) begin                                        \
    __q <= (!__reset_n_clk) ? (__reset_value) : ((__load) ? (__d) : (__q)); \
  end

// Flip-Flop with load-enable and asynchronous active-low reset and synchronous clear
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __clear: assign reset value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst_n: asynchronous reset
`define FFLARNC(__q, __d, __load, __clear, __reset_value, __clk, __arst_n) \
    `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__clear`" *``/                       \
    `endif                        \
  always_ff @(posedge (__clk) or negedge (__arst_n)) begin                 \
    if (!__arst_n) begin                                                   \
      __q <= (__reset_value);                                              \
    end else begin                                                         \
      __q <= (__clear) ? (__reset_value) : (__load) ? (__d) : (__q);       \
    end                                                                    \
  end

// Load-enable Flip-Flop without reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __clk: clock input
`define FFLNR(__q, __d, __load, __clk) \
  always_ff @(posedge (__clk)) begin   \
    __q <= (__load) ? (__d) : (__q);   \
  end

`endif
// ----- 8< ----- FILE "./cf_math_pkg.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2016 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

/// cf_math_pkg: Constant Function Implementations of Mathematical Functions for HDL Elaboration
///
/// This package contains a collection of mathematical functions that are commonly used when defining
/// the value of constants in HDL code.  These functions are implemented as Verilog constants
/// functions.  Introduced in Verilog 2001 (IEEE Std 1364-2001), a constant function (?? 10.3.5) is a
/// function whose value can be evaluated at compile time or during elaboration.  A constant function
/// must be called with arguments that are constants.
package cf_math_pkg;

    /// Ceiled Division of Two Natural Numbers
    ///
    /// Returns the quotient of two natural numbers, rounded towards plus infinity.
    function automatic integer ceil_div (input longint dividend, input longint divisor);
        automatic longint remainder;

        // pragma translate_off
        `ifndef VERILATOR
        if (dividend < 0) begin
            $fatal(1, "Dividend %0d is not a natural number!", dividend);
        end

        if (divisor < 0) begin
            $fatal(1, "Divisor %0d is not a natural number!", divisor);
        end

        if (divisor == 0) begin
            $fatal(1, "Division by zero!");
        end
        `endif
        // pragma translate_on

        remainder = dividend;
        for (ceil_div = 0; remainder > 0; ceil_div++) begin
            remainder = remainder - divisor;
        end
    endfunction

    /// Index width required to be able to represent up to `num_idx` indices as a binary
    /// encoded signal.
    /// Ensures that the minimum width if an index signal is `1`, regardless of parametrization.
    ///
    /// Sample usage in type definition:
    /// As parameter:
    ///   `parameter type idx_t = logic[cf_math_pkg::idx_width(NumIdx)-1:0]`
    /// As typedef:
    ///   `typedef logic [cf_math_pkg::idx_width(NumIdx)-1:0] idx_t`
    function automatic integer unsigned idx_width (input integer unsigned num_idx);
        return (num_idx > 32'd1) ? unsigned'($clog2(num_idx)) : 32'd1;
    endfunction

endpackage
// ----- 8< ----- FILE "./lzc.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright (c) 2018 - 2019 ETH Zurich, University of Bologna
// All rights reserved.
//
// This code is under development and not yet released to the public.
// Until it is released, the code is under the copyright of ETH Zurich and
// the University of Bologna, and may contain confidential and/or unpublished
// work. Any reuse/redistribution is strictly forbidden without written
// permission from ETH Zurich.
//
// Bug fixes and contributions will eventually be released under the
// SolderPad open hardware license in the context of the PULP platform
// (http://www.pulp-platform.org), under the copyright of ETH Zurich and the
// University of Bologna.

/// A trailing zero counter / leading zero counter.
/// Set MODE to 0 for trailing zero counter => cnt_o is the number of trailing zeros (from the LSB)
/// Set MODE to 1 for leading zero counter  => cnt_o is the number of leading zeros  (from the MSB)
/// If the input does not contain a zero, `empty_o` is asserted. Additionally `cnt_o` contains
/// the maximum number of zeros - 1. For example:
///   in_i = 000_0000, empty_o = 1, cnt_o = 6 (mode = 0)
///   in_i = 000_0001, empty_o = 0, cnt_o = 0 (mode = 0)
///   in_i = 000_1000, empty_o = 0, cnt_o = 3 (mode = 0)
/// Furthermore, this unit contains a more efficient implementation for Verilator (simulation only).
/// This speeds up simulation significantly.
module lzc #(
  /// The width of the input vector.
  parameter int unsigned WIDTH = 2,
  /// Mode selection: 0 -> trailing zero, 1 -> leading zero
  parameter bit          MODE  = 1'b0,
  /// Dependent parameter. Do **not** change!
  ///
  /// Width of the output signal with the zero count.
  parameter int unsigned CNT_WIDTH = cf_math_pkg::idx_width(WIDTH)
) (
  /// Input vector to be counted.
  input  logic [WIDTH-1:0]     in_i,
  /// Count of the leading / trailing zeros.
  output logic [CNT_WIDTH-1:0] cnt_o,
  /// Counter is empty: Asserted if all bits in in_i are zero.
  output logic                 empty_o
);

  if (WIDTH == 1) begin : gen_degenerate_lzc

    assign cnt_o[0] = !in_i[0];
    assign empty_o = !in_i[0];

  end else begin : gen_lzc

    localparam int unsigned NumLevels = $clog2(WIDTH);

    // pragma translate_off
    initial begin
      assert(WIDTH > 0) else $fatal(1, "input must be at least one bit wide");
    end
    // pragma translate_on

    logic [WIDTH-1:0][NumLevels-1:0] index_lut;
    logic [2**NumLevels-1:0] sel_nodes;
    logic [2**NumLevels-1:0][NumLevels-1:0] index_nodes;

    logic [WIDTH-1:0] in_tmp;

    // reverse vector if required
    always_comb begin : flip_vector
      for (int unsigned i = 0; i < WIDTH; i++) begin
        in_tmp[i] = (MODE) ? in_i[WIDTH-1-i] : in_i[i];
      end
    end

    for (genvar j = 0; unsigned'(j) < WIDTH; j++) begin : g_index_lut
      assign index_lut[j] = (NumLevels)'(unsigned'(j));
    end

    for (genvar level = 0; unsigned'(level) < NumLevels; level++) begin : g_levels
      if (unsigned'(level) == NumLevels - 1) begin : g_last_level
        for (genvar k = 0; k < 2 ** level; k++) begin : g_level
          // if two successive indices are still in the vector...
          if (unsigned'(k) * 2 < WIDTH - 1) begin : g_reduce
            assign sel_nodes[2 ** level - 1 + k] = in_tmp[k * 2] | in_tmp[k * 2 + 1];
            assign index_nodes[2 ** level - 1 + k] = (in_tmp[k * 2] == 1'b1)
              ? index_lut[k * 2] :
                index_lut[k * 2 + 1];
          end
          // if only the first index is still in the vector...
          if (unsigned'(k) * 2 == WIDTH - 1) begin : g_base
            assign sel_nodes[2 ** level - 1 + k] = in_tmp[k * 2];
            assign index_nodes[2 ** level - 1 + k] = index_lut[k * 2];
          end
          // if index is out of range
          if (unsigned'(k) * 2 > WIDTH - 1) begin : g_out_of_range
            assign sel_nodes[2 ** level - 1 + k] = 1'b0;
            assign index_nodes[2 ** level - 1 + k] = '0;
          end
        end
      end else begin : g_not_last_level
        for (genvar l = 0; l < 2 ** level; l++) begin : g_level
          assign sel_nodes[2 ** level - 1 + l] =
              sel_nodes[2 ** (level + 1) - 1 + l * 2] | sel_nodes[2 ** (level + 1) - 1 + l * 2 + 1];
          assign index_nodes[2 ** level - 1 + l] = (sel_nodes[2 ** (level + 1) - 1 + l * 2] == 1'b1)
            ? index_nodes[2 ** (level + 1) - 1 + l * 2] :
              index_nodes[2 ** (level + 1) - 1 + l * 2 + 1];
        end
      end
    end

    assign cnt_o = NumLevels > unsigned'(0) ? index_nodes[0] : {($clog2(WIDTH)) {1'b0}};
    assign empty_o = NumLevels > unsigned'(0) ? ~sel_nodes[0] : ~(|in_i);

  end : gen_lzc

endmodule : lzc
// ----- 8< ----- FILE "./rr_arb_tree.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich
//         Wolfgang Roenninger <wroennin@iis.ee.ethz.ch>, ETH Zurich
// Date: 02.04.2019
// Description: logarithmic arbitration tree with round robin arbitration scheme.

/// The rr_arb_tree employs non-starving round robin-arbitration - i.e., the priorities
/// rotate each cycle.
///
/// ## Fair vs. unfair Arbitration
///
/// This refers to fair throughput distribution when not all inputs have active requests.
/// This module has an internal state `rr_q` which defines the highest priority input. (When
/// `ExtPrio` is `1'b1` this state is provided from the outside.) The arbitration tree will
/// choose the input with the same index as currently defined by the state if it has an active
/// request. Otherwise a *random* other active input is selected. The parameter `FairArb` is used
/// to distinguish between two methods of calculating the next state.
/// * `1'b0`: The next state is calculated by advancing the current state by one. This leads to the
///           state being calculated without the context of the active request. Leading to an
///           unfair throughput distribution if not all inputs have active requests.
/// * `1'b1`: The next state jumps to the next unserved request with higher index.
///           This is achieved by using two trailing-zero-counters (`lzc`). The upper has the masked
///           `req_i` signal with all indices which will have a higher priority in the next state.
///           The trailing zero count defines the input index with the next highest priority after
///           the current one is served. When the upper is empty the lower `lzc` provides the
///           wrapped index if there are outstanding requests with lower or same priority.
/// The implication of throughput fairness on the module timing are:
/// * The trailing zero counter (`lzc`) has a loglog relation of input to output timing. This means
///   that in this module the input to register path scales with Log(Log(`NumIn`)).
/// * The `rr_arb_tree` data multiplexing scales with Log(`NumIn`). This means that the input to output
///   timing path of this module also scales scales with Log(`NumIn`).
/// This implies that in this module the input to output path is always longer than the input to
/// register path. As the output data usually also terminates in a register the parameter `FairArb`
/// only has implications on the area. When it is `1'b0` a static plus one adder is instantiated.
/// If it is `1'b1` two `lzc`, a masking logic stage and a two input multiplexer are instantiated.
/// However these are small in respect of the data multiplexers needed, as the width of the `req_i`
/// signal is usually less as than `DataWidth`.
module rr_arb_tree #(
  /// Number of inputs to be arbitrated.
  parameter int unsigned NumIn      = 64,
  /// Data width of the payload in bits. Not needed if `DataType` is overwritten.
  parameter int unsigned DataWidth  = 32,
  /// Data type of the payload, can be overwritten with custom type. Only use of `DataWidth`.
  parameter type         DataType   = logic [DataWidth-1:0],
  /// The `ExtPrio` option allows to override the internal round robin counter via the
  /// `rr_i` signal. This can be useful in case multiple arbiters need to have
  /// rotating priorities that are operating in lock-step. If static priority arbitration
  /// is needed, just connect `rr_i` to '0.
  ///
  /// Set to 1'b1 to enable.
  parameter bit          ExtPrio    = 1'b0,
  /// If `AxiVldRdy` is set, the req/gnt signals are compliant with the AXI style vld/rdy
  /// handshake. Namely, upstream vld (req) must not depend on rdy (gnt), as it can be deasserted
  /// again even though vld is asserted. Enabling `AxiVldRdy` leads to a reduction of arbiter
  /// delay and area.
  ///
  /// Set to `1'b1` to treat req/gnt as vld/rdy.
  parameter bit          AxiVldRdy  = 1'b0,
  /// The `LockIn` option prevents the arbiter from changing the arbitration
  /// decision when the arbiter is disabled. I.e., the index of the first request
  /// that wins the arbitration will be locked in case the destination is not
  /// able to grant the request in the same cycle.
  ///
  /// Set to `1'b1` to enable.
  parameter bit          LockIn     = 1'b0,
  /// When set, ensures that throughput gets distributed evenly between all inputs.
  ///
  /// Set to `1'b0` to disable.
  parameter bit          FairArb    = 1'b1,
  /// Dependent parameter, do **not** overwrite.
  /// Width of the arbitration priority signal and the arbitrated index.
  parameter int unsigned IdxWidth   = (NumIn > 32'd1) ? unsigned'($clog2(NumIn)) : 32'd1,
  /// Dependent parameter, do **not** overwrite.
  /// Type for defining the arbitration priority and arbitrated index signal.
  parameter type         idx_t      = logic [IdxWidth-1:0]
) (
  /// Clock, positive edge triggered.
  input  logic                clk_i,
  /// Asynchronous reset, active low.
  input  logic                rst_ni,
  /// Clears the arbiter state. Only used if `ExtPrio` is `1'b0` or `LockIn` is `1'b1`.
  input  logic                flush_i,
  /// External round-robin priority. Only used if `ExtPrio` is `1'b1.`
  input  idx_t                rr_i,
  /// Input requests arbitration.
  input  logic    [NumIn-1:0] req_i,
  /* verilator lint_off UNOPTFLAT */
  /// Input request is granted.
  output logic    [NumIn-1:0] gnt_o,
  /* verilator lint_on UNOPTFLAT */
  /// Input data for arbitration.
  input  DataType [NumIn-1:0] data_i,
  /// Output request is valid.
  output logic                req_o,
  /// Output request is granted.
  input  logic                gnt_i,
  /// Output data.
  output DataType             data_o,
  /// Index from which input the data came from.
  output idx_t                idx_o
);

  // pragma translate_off
  `ifndef VERILATOR
  `ifndef XSIM
  // Default SVA reset
  default disable iff (!rst_ni || flush_i);
  `endif
  `endif
  // pragma translate_on

  // just pass through in this corner case
  if (NumIn == unsigned'(1)) begin : gen_pass_through
    assign req_o    = req_i[0];
    assign gnt_o[0] = gnt_i;
    assign data_o   = data_i[0];
    assign idx_o    = '0;
  // non-degenerate cases
  end else begin : gen_arbiter
    localparam int unsigned NumLevels = unsigned'($clog2(NumIn));

    /* verilator lint_off UNOPTFLAT */
    idx_t    [2**NumLevels-2:0] index_nodes; // used to propagate the indices
    DataType [2**NumLevels-2:0] data_nodes;  // used to propagate the data
    logic    [2**NumLevels-2:0] gnt_nodes;   // used to propagate the grant to masters
    logic    [2**NumLevels-2:0] req_nodes;   // used to propagate the requests to slave
    /* lint_off */
    idx_t                       rr_q;
    logic [NumIn-1:0]           req_d;

    // the final arbitration decision can be taken from the root of the tree
    assign req_o        = req_nodes[0];
    assign data_o       = data_nodes[0];
    assign idx_o        = index_nodes[0];

    if (ExtPrio) begin : gen_ext_rr
      assign rr_q       = rr_i;
      assign req_d      = req_i;
    end else begin : gen_int_rr
      idx_t rr_d;

      // lock arbiter decision in case we got at least one req and no acknowledge
      if (LockIn) begin : gen_lock
        logic  lock_d, lock_q;
        logic [NumIn-1:0] req_q;

        assign lock_d     = req_o & ~gnt_i;
        assign req_d      = (lock_q) ? req_q : req_i;

        always_ff @(posedge clk_i or negedge rst_ni) begin : p_lock_reg
          if (!rst_ni) begin
            lock_q <= '0;
          end else begin
            if (flush_i) begin
              lock_q <= '0;
            end else begin
              lock_q <= lock_d;
            end
          end
        end

        // pragma translate_off
        `ifndef VERILATOR
          lock: assert property(
            @(posedge clk_i) LockIn |-> req_o && !gnt_i |=> idx_o == $past(idx_o)) else
                $fatal (1, "Lock implies same arbiter decision in next cycle if output is not \
                            ready.");

          logic [NumIn-1:0] req_tmp;
          assign req_tmp = req_q & req_i;
          lock_req: assume property(
            @(posedge clk_i) LockIn |-> lock_d |=> req_tmp == req_q) else
                $fatal (1, "It is disallowed to deassert unserved request signals when LockIn is \
                            enabled.");
        `endif
        // pragma translate_on

        always_ff @(posedge clk_i or negedge rst_ni) begin : p_req_regs
          if (!rst_ni) begin
            req_q  <= '0;
          end else begin
            if (flush_i) begin
              req_q  <= '0;
            end else begin
              req_q  <= req_d;
            end
          end
        end
      end else begin : gen_no_lock
        assign req_d = req_i;
      end

      if (FairArb) begin : gen_fair_arb
        logic [NumIn-1:0] upper_mask,  lower_mask;
        idx_t             upper_idx,   lower_idx,   next_idx;
        logic             upper_empty, lower_empty;

        for (genvar i = 0; i < NumIn; i++) begin : gen_mask
          assign upper_mask[i] = (i >  rr_q) ? req_d[i] : 1'b0;
          assign lower_mask[i] = (i <= rr_q) ? req_d[i] : 1'b0;
        end

        lzc #(
          .WIDTH ( NumIn ),
          .MODE  ( 1'b0  )
        ) i_lzc_upper (
          .in_i    ( upper_mask  ),
          .cnt_o   ( upper_idx   ),
          .empty_o ( upper_empty )
        );

        lzc #(
          .WIDTH ( NumIn ),
          .MODE  ( 1'b0  )
        ) i_lzc_lower (
          .in_i    ( lower_mask  ),
          .cnt_o   ( lower_idx   ),
          .empty_o ( /*unused*/  )
        );

        assign next_idx = upper_empty      ? lower_idx : upper_idx;
        assign rr_d     = (gnt_i && req_o) ? next_idx  : rr_q;

      end else begin : gen_unfair_arb
        assign rr_d = (gnt_i && req_o) ? ((rr_q == idx_t'(NumIn-1)) ? '0 : rr_q + 1'b1) : rr_q;
      end

      // this holds the highest priority
      always_ff @(posedge clk_i or negedge rst_ni) begin : p_rr_regs
        if (!rst_ni) begin
          rr_q   <= '0;
        end else begin
          if (flush_i) begin
            rr_q   <= '0;
          end else begin
            rr_q   <= rr_d;
          end
        end
      end
    end

    assign gnt_nodes[0] = gnt_i;

    // arbiter tree
    for (genvar level = 0; unsigned'(level) < NumLevels; level++) begin : gen_levels
      for (genvar l = 0; l < 2**level; l++) begin : gen_level
        // local select signal
        logic sel;
        // index calcs
        localparam int unsigned Idx0 = 2**level-1+l;// current node
        localparam int unsigned Idx1 = 2**(level+1)-1+l*2;
        //////////////////////////////////////////////////////////////
        // uppermost level where data is fed in from the inputs
        if (unsigned'(level) == NumLevels-1) begin : gen_first_level
          // if two successive indices are still in the vector...
          if (unsigned'(l) * 2 < NumIn-1) begin : gen_reduce
            assign req_nodes[Idx0]   = req_d[l*2] | req_d[l*2+1];

            // arbitration: round robin
            assign sel =  ~req_d[l*2] | req_d[l*2+1] & rr_q[NumLevels-1-level];

            assign index_nodes[Idx0] = idx_t'(sel);
            assign data_nodes[Idx0]  = (sel) ? data_i[l*2+1] : data_i[l*2];
            assign gnt_o[l*2]        = gnt_nodes[Idx0] & (AxiVldRdy | req_d[l*2])   & ~sel;
            assign gnt_o[l*2+1]      = gnt_nodes[Idx0] & (AxiVldRdy | req_d[l*2+1]) & sel;
          end
          // if only the first index is still in the vector...
          if (unsigned'(l) * 2 == NumIn-1) begin : gen_first
            assign req_nodes[Idx0]   = req_d[l*2];
            assign index_nodes[Idx0] = '0;// always zero in this case
            assign data_nodes[Idx0]  = data_i[l*2];
            assign gnt_o[l*2]        = gnt_nodes[Idx0] & (AxiVldRdy | req_d[l*2]);
          end
          // if index is out of range, fill up with zeros (will get pruned)
          if (unsigned'(l) * 2 > NumIn-1) begin : gen_out_of_range
            assign req_nodes[Idx0]   = 1'b0;
            assign index_nodes[Idx0] = idx_t'('0);
            assign data_nodes[Idx0]  = DataType'('0);
          end
        //////////////////////////////////////////////////////////////
        // general case for other levels within the tree
        end else begin : gen_other_levels
          assign req_nodes[Idx0]   = req_nodes[Idx1] | req_nodes[Idx1+1];

          // arbitration: round robin
          assign sel =  ~req_nodes[Idx1] | req_nodes[Idx1+1] & rr_q[NumLevels-1-level];

          assign index_nodes[Idx0] = (sel) ?
            idx_t'({1'b1, index_nodes[Idx1+1][NumLevels-unsigned'(level)-2:0]}) :
            idx_t'({1'b0, index_nodes[Idx1][NumLevels-unsigned'(level)-2:0]});

          assign data_nodes[Idx0]  = (sel) ? data_nodes[Idx1+1] : data_nodes[Idx1];
          assign gnt_nodes[Idx1]   = gnt_nodes[Idx0] & ~sel;
          assign gnt_nodes[Idx1+1] = gnt_nodes[Idx0] & sel;
        end
        //////////////////////////////////////////////////////////////
      end
    end

    // pragma translate_off
    `ifndef VERILATOR
    `ifndef XSIM
    initial begin : p_assert
      assert(NumIn)
        else $fatal(1, "Input must be at least one element wide.");
      assert(!(LockIn && ExtPrio))
        else $fatal(1,"Cannot use LockIn feature together with external ExtPrio.");
    end

    hot_one : assert property(
      @(posedge clk_i) $onehot0(gnt_o))
        else $fatal (1, "Grant signal must be hot1 or zero.");

    gnt0 : assert property(
      @(posedge clk_i) |gnt_o |-> gnt_i)
        else $fatal (1, "Grant out implies grant in.");

    gnt1 : assert property(
      @(posedge clk_i) req_o |-> gnt_i |-> |gnt_o)
        else $fatal (1, "Req out and grant in implies grant out.");

    gnt_idx : assert property(
      @(posedge clk_i) req_o |->  gnt_i |-> gnt_o[idx_o])
        else $fatal (1, "Idx_o / gnt_o do not match.");

    req0 : assert property(
      @(posedge clk_i) |req_i |-> req_o)
        else $fatal (1, "Req in implies req out.");

    req1 : assert property(
      @(posedge clk_i) req_o |-> |req_i)
        else $fatal (1, "Req out implies req in.");
    `endif
    `endif
    // pragma translate_on
  end

endmodule : rr_arb_tree
// ----- 8< ----- FILE "./fpnew_pkg.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

package fpnew_pkg;

  // ---------
  // FP TYPES
  // ---------
  // | Enumerator | Format           | Width  | EXP_BITS | MAN_BITS
  // |:----------:|------------------|-------:|:--------:|:--------:
  // | FP32       | IEEE binary32    | 32 bit | 8        | 23
  // | FP64       | IEEE binary64    | 64 bit | 11       | 52
  // | FP16       | IEEE binary16    | 16 bit | 5        | 10
  // | FP8        | binary8          |  8 bit | 5        | 2
  // | FP16ALT    | binary16alt      | 16 bit | 8        | 7
  // *NOTE:* Add new formats only at the end of the enumeration for backwards compatibilty!

  // Encoding for a format
  typedef struct packed {
    int unsigned exp_bits;
    int unsigned man_bits;
  } fp_encoding_t;

  localparam int unsigned NUM_FP_FORMATS = 5; // change me to add formats
  localparam int unsigned FP_FORMAT_BITS = $clog2(NUM_FP_FORMATS);

  // FP formats
  typedef enum logic [FP_FORMAT_BITS-1:0] {
    FP32    = 'd0,
    FP64    = 'd1,
    FP16    = 'd2,
    FP8     = 'd3,
    FP16ALT = 'd4
    // add new formats here
  } fp_format_e;

  // Encodings for supported FP formats
  localparam fp_encoding_t [0:NUM_FP_FORMATS-1] FP_ENCODINGS  = '{
    '{8,  23}, // IEEE binary32 (single)
    '{11, 52}, // IEEE binary64 (double)
    '{5,  10}, // IEEE binary16 (half)
    '{5,  2},  // custom binary8
    '{8,  7}   // custom binary16alt
    // add new formats here
  };

  typedef logic [0:NUM_FP_FORMATS-1]       fmt_logic_t;    // Logic indexed by FP format (for masks)
  typedef logic [0:NUM_FP_FORMATS-1][31:0] fmt_unsigned_t; // Unsigned indexed by FP format

  localparam fmt_logic_t CPK_FORMATS = 5'b11000; // FP32 and FP64 can provide CPK only

  // ---------
  // INT TYPES
  // ---------
  // | Enumerator | Width  |
  // |:----------:|-------:|
  // | INT8       |  8 bit |
  // | INT16      | 16 bit |
  // | INT32      | 32 bit |
  // | INT64      | 64 bit |
  // *NOTE:* Add new formats only at the end of the enumeration for backwards compatibilty!

  localparam int unsigned NUM_INT_FORMATS = 4; // change me to add formats
  localparam int unsigned INT_FORMAT_BITS = $clog2(NUM_INT_FORMATS);

  // Int formats
  typedef enum logic [INT_FORMAT_BITS-1:0] {
    INT8,
    INT16,
    INT32,
    INT64
    // add new formats here
  } int_format_e;

  // Returns the width of an INT format by index
  function automatic int unsigned int_width(int_format_e ifmt);
    unique case (ifmt)
      INT8:  return 8;
      INT16: return 16;
      INT32: return 32;
      INT64: return 64;
      default: begin
        // pragma translate_off
        $fatal(1, "Invalid INT format supplied");
        // pragma translate_on
        // just return any integer to avoid any latches
        // hopefully this error is caught by simulation
        return INT8;
      end
    endcase
  endfunction

  typedef logic [0:NUM_INT_FORMATS-1] ifmt_logic_t; // Logic indexed by INT format (for masks)

  // --------------
  // FP OPERATIONS
  // --------------
  localparam int unsigned NUM_OPGROUPS = 4;

  // Each FP operation belongs to an operation group
  typedef enum logic [1:0] {
    ADDMUL, DIVSQRT, NONCOMP, CONV
  } opgroup_e;

  localparam int unsigned OP_BITS = 4;

  typedef enum logic [OP_BITS-1:0] {
    FMADD, FNMSUB, ADD, MUL,     // ADDMUL operation group
    DIV, SQRT,                   // DIVSQRT operation group
    SGNJ, MINMAX, CMP, CLASSIFY, // NONCOMP operation group
    F2F, F2I, I2F, CPKAB, CPKCD  // CONV operation group
  } operation_e;

  // -------------------
  // RISC-V FP-SPECIFIC
  // -------------------
  // Rounding modes
  typedef enum logic [2:0] {
    RNE = 3'b000,
    RTZ = 3'b001,
    RDN = 3'b010,
    RUP = 3'b011,
    RMM = 3'b100,
    ROD = 3'b101,  // This mode is not defined in RISC-V FP-SPEC
    DYN = 3'b111
  } roundmode_e;

  // Status flags
  typedef struct packed {
    logic NV; // Invalid
    logic DZ; // Divide by zero
    logic OF; // Overflow
    logic UF; // Underflow
    logic NX; // Inexact
  } status_t;

  // Information about a floating point value
  typedef struct packed {
    logic is_normal;     // is the value normal
    logic is_subnormal;  // is the value subnormal
    logic is_zero;       // is the value zero
    logic is_inf;        // is the value infinity
    logic is_nan;        // is the value NaN
    logic is_signalling; // is the value a signalling NaN
    logic is_quiet;      // is the value a quiet NaN
    logic is_boxed;      // is the value properly NaN-boxed (RISC-V specific)
  } fp_info_t;

  // Classification mask
  typedef enum logic [9:0] {
    NEGINF     = 10'b00_0000_0001,
    NEGNORM    = 10'b00_0000_0010,
    NEGSUBNORM = 10'b00_0000_0100,
    NEGZERO    = 10'b00_0000_1000,
    POSZERO    = 10'b00_0001_0000,
    POSSUBNORM = 10'b00_0010_0000,
    POSNORM    = 10'b00_0100_0000,
    POSINF     = 10'b00_1000_0000,
    SNAN       = 10'b01_0000_0000,
    QNAN       = 10'b10_0000_0000
  } classmask_e;

  // ------------------
  // FPU configuration
  // ------------------
  // Pipelining registers can be inserted (at elaboration time) into operational units
  typedef enum logic [1:0] {
    BEFORE,     // registers are inserted at the inputs of the unit
    AFTER,      // registers are inserted at the outputs of the unit
    INSIDE,     // registers are inserted at predetermined (suboptimal) locations in the unit
    DISTRIBUTED // registers are evenly distributed, INSIDE >= AFTER >= BEFORE
  } pipe_config_t;

  // Arithmetic units can be arranged in parallel (per format), merged (multi-format) or not at all.
  typedef enum logic [1:0] {
    DISABLED, // arithmetic units are not generated
    PARALLEL, // arithmetic units are generated in prallel slices, one for each format
    MERGED    // arithmetic units are contained within a merged unit holding multiple formats
  } unit_type_t;

  // Array of unit types indexed by format
  typedef unit_type_t [0:NUM_FP_FORMATS-1] fmt_unit_types_t;

  // Array of format-specific unit types by opgroup
  typedef fmt_unit_types_t [0:NUM_OPGROUPS-1] opgrp_fmt_unit_types_t;
  // same with unsigned
  typedef fmt_unsigned_t [0:NUM_OPGROUPS-1] opgrp_fmt_unsigned_t;

  // FPU configuration: features
  typedef struct packed {
    int unsigned Width;
    logic        EnableVectors;
    logic        EnableNanBox;
    fmt_logic_t  FpFmtMask;
    ifmt_logic_t IntFmtMask;
  } fpu_features_t;

  localparam fpu_features_t RV64D = '{
    Width:         64,
    EnableVectors: 1'b0,
    EnableNanBox:  1'b1,
    FpFmtMask:     5'b11000,
    IntFmtMask:    4'b0011
  };

  localparam fpu_features_t RV32D = '{
    Width:         64,
    EnableVectors: 1'b1,
    EnableNanBox:  1'b1,
    FpFmtMask:     5'b11000,
    IntFmtMask:    4'b0010
  };

  localparam fpu_features_t RV32F = '{
    Width:         32,
    EnableVectors: 1'b0,
    EnableNanBox:  1'b1,
    FpFmtMask:     5'b10000,
    IntFmtMask:    4'b0010
  };

  localparam fpu_features_t RV64D_Xsflt = '{
    Width:         64,
    EnableVectors: 1'b1,
    EnableNanBox:  1'b1,
    FpFmtMask:     5'b11111,
    IntFmtMask:    4'b1111
  };

  localparam fpu_features_t RV32F_Xsflt = '{
    Width:         32,
    EnableVectors: 1'b1,
    EnableNanBox:  1'b1,
    FpFmtMask:     5'b10111,
    IntFmtMask:    4'b1110
  };

  localparam fpu_features_t RV32F_Xf16alt_Xfvec = '{
    Width:         32,
    EnableVectors: 1'b1,
    EnableNanBox:  1'b1,
    FpFmtMask:     5'b10001,
    IntFmtMask:    4'b0110
  };


  // FPU configuraion: implementation
  typedef struct packed {
    opgrp_fmt_unsigned_t   PipeRegs;
    opgrp_fmt_unit_types_t UnitTypes;
    pipe_config_t          PipeConfig;
  } fpu_implementation_t;

  localparam fpu_implementation_t DEFAULT_NOREGS = '{
    PipeRegs:   '{default: 0},
    UnitTypes:  '{'{default: PARALLEL}, // ADDMUL
                  '{default: MERGED},   // DIVSQRT
                  '{default: PARALLEL}, // NONCOMP
                  '{default: MERGED}},  // CONV
    PipeConfig: BEFORE
  };

  localparam fpu_implementation_t DEFAULT_SNITCH = '{
    PipeRegs:   '{default: 1},
    UnitTypes:  '{'{default: PARALLEL}, // ADDMUL
                  '{default: DISABLED}, // DIVSQRT
                  '{default: PARALLEL}, // NONCOMP
                  '{default: MERGED}},  // CONV
    PipeConfig: BEFORE
  };

  // -----------------------
  // Synthesis optimization
  // -----------------------
  localparam logic DONT_CARE = 1'b1; // the value to assign as don't care

  // -------------------------
  // General helper functions
  // -------------------------
  function automatic int minimum(int a, int b);
    return (a < b) ? a : b;
  endfunction

  function automatic int maximum(int a, int b);
    return (a > b) ? a : b;
  endfunction

  // -------------------------------------------
  // Helper functions for FP formats and values
  // -------------------------------------------
  // Returns the width of a FP format
  function automatic int unsigned fp_width(fp_format_e fmt);
    return FP_ENCODINGS[fmt].exp_bits + FP_ENCODINGS[fmt].man_bits + 1;
  endfunction

  // Returns the widest FP format present
  function automatic int unsigned max_fp_width(fmt_logic_t cfg);
    automatic int unsigned res = 0;
    for (int unsigned i = 0; i < NUM_FP_FORMATS; i++)
      if (cfg[i])
        res = unsigned'(maximum(res, fp_width(fp_format_e'(i))));
    return res;
  endfunction

  // Returns the narrowest FP format present
  function automatic int unsigned min_fp_width(fmt_logic_t cfg);
    automatic int unsigned res = max_fp_width(cfg);
    for (int unsigned i = 0; i < NUM_FP_FORMATS; i++)
      if (cfg[i])
        res = unsigned'(minimum(res, fp_width(fp_format_e'(i))));
    return res;
  endfunction

  // Returns the number of expoent bits for a format
  function automatic int unsigned exp_bits(fp_format_e fmt);
    return FP_ENCODINGS[fmt].exp_bits;
  endfunction

  // Returns the number of mantissa bits for a format
  function automatic int unsigned man_bits(fp_format_e fmt);
    return FP_ENCODINGS[fmt].man_bits;
  endfunction

  // Returns the bias value for a given format (as per IEEE 754-2008)
  function automatic int unsigned bias(fp_format_e fmt);
    return unsigned'(2**(FP_ENCODINGS[fmt].exp_bits-1)-1); // symmetrical bias
  endfunction

  function automatic fp_encoding_t super_format(fmt_logic_t cfg);
    automatic fp_encoding_t res;
    res = '0;
    for (int unsigned fmt = 0; fmt < NUM_FP_FORMATS; fmt++)
      if (cfg[fmt]) begin // only active format
        res.exp_bits = unsigned'(maximum(res.exp_bits, exp_bits(fp_format_e'(fmt))));
        res.man_bits = unsigned'(maximum(res.man_bits, man_bits(fp_format_e'(fmt))));
      end
    return res;
  endfunction

  // -------------------------------------------
  // Helper functions for INT formats and values
  // -------------------------------------------
  // Returns the widest INT format present
  function automatic int unsigned max_int_width(ifmt_logic_t cfg);
    automatic int unsigned res = 0;
    for (int ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++) begin
      if (cfg[ifmt]) res = maximum(res, int_width(int_format_e'(ifmt)));
    end
    return res;
  endfunction

  // --------------------------------------------------
  // Helper functions for operations and FPU structure
  // --------------------------------------------------
  // Returns the operation group of the given operation
  function automatic opgroup_e get_opgroup(operation_e op);
    unique case (op)
      FMADD, FNMSUB, ADD, MUL:     return ADDMUL;
      DIV, SQRT:                   return DIVSQRT;
      SGNJ, MINMAX, CMP, CLASSIFY: return NONCOMP;
      F2F, F2I, I2F, CPKAB, CPKCD: return CONV;
      default:                     return NONCOMP;
    endcase
  endfunction

  // Returns the number of operands by operation group
  function automatic int unsigned num_operands(opgroup_e grp);
    unique case (grp)
      ADDMUL:  return 3;
      DIVSQRT: return 2;
      NONCOMP: return 2;
      CONV:    return 3; // vectorial casts use 3 operands
      default: return 0;
    endcase
  endfunction

  // Returns the number of lanes according to width, format and vectors
  function automatic int unsigned num_lanes(int unsigned width, fp_format_e fmt, logic vec);
    return vec ? width / fp_width(fmt) : 1; // if no vectors, only one lane
  endfunction

  // Returns the maximum number of lanes in the FPU according to width, format config and vectors
  function automatic int unsigned max_num_lanes(int unsigned width, fmt_logic_t cfg, logic vec);
    // return vec ? width / min_fp_width(cfg) : 1; // if no vectors, only one lane
    if (vec) begin
      automatic int unsigned res = max_fp_width(cfg);
      for (int unsigned i = 0; i < NUM_FP_FORMATS; i++) begin
        if (cfg[i]) begin
          automatic int unsigned format_width = FP_ENCODINGS[i].exp_bits + FP_ENCODINGS[i].man_bits + 1;
          res = unsigned'(minimum(res, format_width));
        end
      end
      return width / res;
    end else begin
      return 1;
    end
  endfunction

  // Returns a mask of active FP formats that are present in lane lane_no of a multiformat slice
  function automatic fmt_logic_t get_lane_formats(int unsigned width,
                                                  fmt_logic_t cfg,
                                                  int unsigned lane_no);
    automatic fmt_logic_t res;
    for (int unsigned fmt = 0; fmt < NUM_FP_FORMATS; fmt++)
      // Mask active formats with the number of lanes for that format
      res[fmt] = cfg[fmt] & (width / fp_width(fp_format_e'(fmt)) > lane_no);
    return res;
  endfunction

  // Returns a mask of active INT formats that are present in lane lane_no of a multiformat slice
  function automatic ifmt_logic_t get_lane_int_formats(int unsigned width,
                                                       fmt_logic_t cfg,
                                                       ifmt_logic_t icfg,
                                                       int unsigned lane_no);
    automatic ifmt_logic_t res;
    automatic fmt_logic_t lanefmts;
    res = '0;
    lanefmts = get_lane_formats(width, cfg, lane_no);

    for (int unsigned ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++)
      for (int unsigned fmt = 0; fmt < NUM_FP_FORMATS; fmt++)
        // Mask active int formats with the width of the float formats
        if ((fp_width(fp_format_e'(fmt)) == int_width(int_format_e'(ifmt))))
          res[ifmt] |= icfg[ifmt] && lanefmts[fmt];
    return res;
  endfunction

  // Returns a mask of active FP formats that are present in lane lane_no of a CONV slice
  function automatic fmt_logic_t get_conv_lane_formats(int unsigned width,
                                                       fmt_logic_t cfg,
                                                       int unsigned lane_no);
    automatic fmt_logic_t res;
    for (int unsigned fmt = 0; fmt < NUM_FP_FORMATS; fmt++)
      // Mask active formats with the number of lanes for that format, CPK at least twice
      res[fmt] = cfg[fmt] && ((width / fp_width(fp_format_e'(fmt)) > lane_no) ||
                             (CPK_FORMATS[fmt] && (lane_no < 2)));
    return res;
  endfunction

  // Returns a mask of active INT formats that are present in lane lane_no of a CONV slice
  function automatic ifmt_logic_t get_conv_lane_int_formats(int unsigned width,
                                                            fmt_logic_t cfg,
                                                            ifmt_logic_t icfg,
                                                            int unsigned lane_no);
    automatic ifmt_logic_t res;
    automatic fmt_logic_t lanefmts;
    res = '0;
    lanefmts = get_conv_lane_formats(width, cfg, lane_no);

    for (int unsigned ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++)
      for (int unsigned fmt = 0; fmt < NUM_FP_FORMATS; fmt++)
        // Mask active int formats with the width of the float formats
        res[ifmt] |= icfg[ifmt] && lanefmts[fmt] &&
                     (fp_width(fp_format_e'(fmt)) == int_width(int_format_e'(ifmt)));
    return res;
  endfunction

  // Return whether any active format is set as MERGED
  function automatic logic any_enabled_multi(fmt_unit_types_t types, fmt_logic_t cfg);
    for (int unsigned i = 0; i < NUM_FP_FORMATS; i++)
      if (cfg[i] && types[i] == MERGED)
        return 1'b1;
      return 1'b0;
  endfunction

  // Return whether the given format is the first active one set as MERGED
  function automatic logic is_first_enabled_multi(fp_format_e fmt,
                                                  fmt_unit_types_t types,
                                                  fmt_logic_t cfg);
    for (int unsigned i = 0; i < NUM_FP_FORMATS; i++) begin
      if (cfg[i] && types[i] == MERGED) return (fp_format_e'(i) == fmt);
    end
    return 1'b0;
  endfunction

  // Returns the first format that is active and is set as MERGED
  function automatic fp_format_e get_first_enabled_multi(fmt_unit_types_t types, fmt_logic_t cfg);
    for (int unsigned i = 0; i < NUM_FP_FORMATS; i++)
      if (cfg[i] && types[i] == MERGED)
        return fp_format_e'(i);
      return fp_format_e'(0);
  endfunction

  // Returns the largest number of regs that is active and is set as MERGED
  function automatic int unsigned get_num_regs_multi(fmt_unsigned_t regs,
                                                     fmt_unit_types_t types,
                                                     fmt_logic_t cfg);
    automatic int unsigned res = 0;
    for (int unsigned i = 0; i < NUM_FP_FORMATS; i++) begin
      if (cfg[i] && types[i] == MERGED) res = maximum(res, regs[i]);
    end
    return res;
  endfunction

endpackage
// ----- 8< ----- FILE "./fpnew_cast_multi.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>



module fpnew_cast_multi #(
  parameter fpnew_pkg::fmt_logic_t   FpFmtConfig  = '1,
  parameter fpnew_pkg::ifmt_logic_t  IntFmtConfig = '1,
  // FPU configuration
  parameter int unsigned             NumPipeRegs = 0,
  parameter fpnew_pkg::pipe_config_t PipeConfig  = fpnew_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH = fpnew_pkg::maximum(fpnew_pkg::max_fp_width(FpFmtConfig),
                                                     fpnew_pkg::max_int_width(IntFmtConfig)),
  localparam int unsigned NUM_FORMATS = fpnew_pkg::NUM_FP_FORMATS,
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input  logic                   clk_i,
  input  logic                   rst_ni,
  // Input signals
  input  logic [WIDTH-1:0]       operands_i, // 1 operand
  input  logic [NUM_FORMATS-1:0] is_boxed_i, // 1 operand
  input  fpnew_pkg::roundmode_e  rnd_mode_i,
  input  fpnew_pkg::operation_e  op_i,
  input  logic                   op_mod_i,
  input  fpnew_pkg::fp_format_e  src_fmt_i,
  input  fpnew_pkg::fp_format_e  dst_fmt_i,
  input  fpnew_pkg::int_format_e int_fmt_i,
  input  TagType                 tag_i,
  input  logic                   mask_i,
  input  AuxType                 aux_i,
  // Input Handshake
  input  logic                   in_valid_i,
  output logic                   in_ready_o,
  input  logic                   flush_i,
  // Output signals
  output logic [WIDTH-1:0]       result_o,
  output fpnew_pkg::status_t     status_o,
  output logic                   extension_bit_o,
  output TagType                 tag_o,
  output logic                   mask_o,
  output AuxType                 aux_o,
  // Output handshake
  output logic                   out_valid_o,
  input  logic                   out_ready_i,
  // Indication of valid data in flight
  output logic                   busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0] reg_ena_i
);

  // ----------
  // Constants
  // ----------
  localparam int unsigned NUM_INT_FORMATS = fpnew_pkg::NUM_INT_FORMATS;
  localparam int unsigned MAX_INT_WIDTH   = fpnew_pkg::max_int_width(IntFmtConfig);

  localparam fpnew_pkg::fp_encoding_t SUPER_FORMAT = fpnew_pkg::super_format(FpFmtConfig);

  localparam int unsigned SUPER_EXP_BITS = SUPER_FORMAT.exp_bits;
  localparam int unsigned SUPER_MAN_BITS = SUPER_FORMAT.man_bits;
  localparam int unsigned SUPER_BIAS     = 2**(SUPER_EXP_BITS - 1) - 1;

  // The internal mantissa includes normal bit or an entire integer
  localparam int unsigned INT_MAN_WIDTH = fpnew_pkg::maximum(SUPER_MAN_BITS + 1, MAX_INT_WIDTH);
  // If needed, there will be a LZC for renormalization
  localparam int unsigned LZC_RESULT_WIDTH = $clog2(INT_MAN_WIDTH);
  // The internal exponent must be able to represent the smallest denormal input value as signed
  // or the number of bits in an integer
  localparam int unsigned INT_EXP_WIDTH = fpnew_pkg::maximum($clog2(MAX_INT_WIDTH),
      fpnew_pkg::maximum(SUPER_EXP_BITS, $clog2(SUPER_BIAS + SUPER_MAN_BITS))) + 1;
  // Pipelines
  localparam NUM_INP_REGS = PipeConfig == fpnew_pkg::BEFORE
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 3) // Second to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_MID_REGS = PipeConfig == fpnew_pkg::INSIDE
                          ? NumPipeRegs
                          : (PipeConfig == fpnew_pkg::DISTRIBUTED
                             ? ((NumPipeRegs + 2) / 3) // First to get distributed regs
                             : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = PipeConfig == fpnew_pkg::AFTER
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 3) // Last to get distributed regs
                               : 0); // no regs here otherwise

  // ---------------
  // Input pipeline
  // ---------------
  // Selected pipeline output signals as non-arrays
  logic [WIDTH-1:0]       operands_q;
  logic [NUM_FORMATS-1:0] is_boxed_q;
  logic                   op_mod_q;
  fpnew_pkg::fp_format_e  src_fmt_q;
  fpnew_pkg::fp_format_e  dst_fmt_q;
  fpnew_pkg::int_format_e int_fmt_q;

  // Input pipeline signals, index i holds signal after i register stages
  logic                   [0:NUM_INP_REGS][WIDTH-1:0]       inp_pipe_operands_q;
  logic                   [0:NUM_INP_REGS][NUM_FORMATS-1:0] inp_pipe_is_boxed_q;
  fpnew_pkg::roundmode_e  [0:NUM_INP_REGS]                  inp_pipe_rnd_mode_q;
  fpnew_pkg::operation_e  [0:NUM_INP_REGS]                  inp_pipe_op_q;
  logic                   [0:NUM_INP_REGS]                  inp_pipe_op_mod_q;
  fpnew_pkg::fp_format_e  [0:NUM_INP_REGS]                  inp_pipe_src_fmt_q;
  fpnew_pkg::fp_format_e  [0:NUM_INP_REGS]                  inp_pipe_dst_fmt_q;
  fpnew_pkg::int_format_e [0:NUM_INP_REGS]                  inp_pipe_int_fmt_q;
  TagType                 [0:NUM_INP_REGS]                  inp_pipe_tag_q;
  logic                   [0:NUM_INP_REGS]                  inp_pipe_mask_q;
  AuxType                 [0:NUM_INP_REGS]                  inp_pipe_aux_q;
  logic                   [0:NUM_INP_REGS]                  inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_is_boxed_q[0] = is_boxed_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_op_mod_q[0]   = op_mod_i;
  assign inp_pipe_src_fmt_q[0]  = src_fmt_i;
  assign inp_pipe_dst_fmt_q[0]  = dst_fmt_i;
  assign inp_pipe_int_fmt_q[0]  = int_fmt_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_mask_q[0]     = mask_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, fpnew_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, fpnew_pkg::FMADD)
    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)
    `FFL(inp_pipe_src_fmt_q[i+1],  inp_pipe_src_fmt_q[i],  reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(inp_pipe_dst_fmt_q[i+1],  inp_pipe_dst_fmt_q[i],  reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(inp_pipe_int_fmt_q[i+1],  inp_pipe_int_fmt_q[i],  reg_ena, fpnew_pkg::int_format_e'(0))
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign operands_q = inp_pipe_operands_q[NUM_INP_REGS];
  assign is_boxed_q = inp_pipe_is_boxed_q[NUM_INP_REGS];
  assign op_mod_q   = inp_pipe_op_mod_q[NUM_INP_REGS];
  assign src_fmt_q  = inp_pipe_src_fmt_q[NUM_INP_REGS];
  assign dst_fmt_q  = inp_pipe_dst_fmt_q[NUM_INP_REGS];
  assign int_fmt_q  = inp_pipe_int_fmt_q[NUM_INP_REGS];

  // -----------------
  // Input processing
  // -----------------
  logic src_is_int, dst_is_int; // if 0, it's a float

  assign src_is_int = (inp_pipe_op_q[NUM_INP_REGS] == fpnew_pkg::I2F);
  assign dst_is_int = (inp_pipe_op_q[NUM_INP_REGS] == fpnew_pkg::F2I);

  logic [INT_MAN_WIDTH-1:0] encoded_mant; // input mantissa with implicit bit

  logic        [NUM_FORMATS-1:0]                    fmt_sign;
  logic signed [NUM_FORMATS-1:0][INT_EXP_WIDTH-1:0] fmt_exponent;
  logic        [NUM_FORMATS-1:0][INT_MAN_WIDTH-1:0] fmt_mantissa;
  logic signed [NUM_FORMATS-1:0][INT_EXP_WIDTH-1:0] fmt_shift_compensation; // for LZC

  fpnew_pkg::fp_info_t [NUM_FORMATS-1:0] info;

  logic [NUM_INT_FORMATS-1:0][INT_MAN_WIDTH-1:0] ifmt_input_val;
  logic                                          int_sign;
  logic [INT_MAN_WIDTH-1:0]                      int_value, int_mantissa;

  // FP Input initialization
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : fmt_init_inputs
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      // Classify input
      fpnew_classifier #(
        .FpFormat    ( fpnew_pkg::fp_format_e'(fmt) ),
        .NumOperands ( 1                            )
      ) i_fpnew_classifier (
        .operands_i ( operands_q[FP_WIDTH-1:0] ),
        .is_boxed_i ( is_boxed_q[fmt]          ),
        .info_o     ( info[fmt]                )
      );

      assign fmt_sign[fmt]     = operands_q[FP_WIDTH-1];
      assign fmt_exponent[fmt] = signed'({1'b0, operands_q[MAN_BITS+:EXP_BITS]});
      assign fmt_mantissa[fmt] = {info[fmt].is_normal, operands_q[MAN_BITS-1:0]}; // zero pad
      // Compensation for the difference in mantissa widths used for leading-zero count
      assign fmt_shift_compensation[fmt] = signed'(INT_MAN_WIDTH - 1 - MAN_BITS);
    end else begin : inactive_format
      assign info[fmt]                   = '{default: fpnew_pkg::DONT_CARE}; // format disabled
      assign fmt_sign[fmt]               = fpnew_pkg::DONT_CARE;             // format disabled
      assign fmt_exponent[fmt]           = '{default: fpnew_pkg::DONT_CARE}; // format disabled
      assign fmt_mantissa[fmt]           = '{default: fpnew_pkg::DONT_CARE}; // format disabled
      assign fmt_shift_compensation[fmt] = '{default: fpnew_pkg::DONT_CARE}; // format disabled
    end
  end

  // Sign-extend INT input
  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_sign_extend_int
    // Set up some constants
    localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));

    if (IntFmtConfig[ifmt]) begin : active_format // only active formats
      always_comb begin : sign_ext_input
        // sign-extend value only if it's signed
        ifmt_input_val[ifmt]                = '{default: operands_q[INT_WIDTH-1] & ~op_mod_q};
        ifmt_input_val[ifmt][INT_WIDTH-1:0] = operands_q[INT_WIDTH-1:0];
      end
    end else begin : inactive_format
      assign ifmt_input_val[ifmt] = '{default: fpnew_pkg::DONT_CARE}; // format disabled
    end
  end

  // Construct input mantissa from integer
  assign int_value    = ifmt_input_val[int_fmt_q];
  assign int_sign     = int_value[INT_MAN_WIDTH-1] & ~op_mod_q; // only signed ints are negative
  assign int_mantissa = int_sign ? unsigned'(-int_value) : int_value; // get magnitude of negative

  // select mantissa with source format
  assign encoded_mant = src_is_int ? int_mantissa : fmt_mantissa[src_fmt_q];

  // --------------
  // Normalization
  // --------------
  logic signed [INT_EXP_WIDTH-1:0] src_bias;      // src format bias
  logic signed [INT_EXP_WIDTH-1:0] src_exp;       // src format exponent (biased)
  logic signed [INT_EXP_WIDTH-1:0] src_subnormal; // src is subnormal
  logic signed [INT_EXP_WIDTH-1:0] src_offset;    // src offset within mantissa

  assign src_bias      = signed'(fpnew_pkg::bias(src_fmt_q));
  assign src_exp       = fmt_exponent[src_fmt_q];
  assign src_subnormal = signed'({1'b0, info[src_fmt_q].is_subnormal});
  assign src_offset    = fmt_shift_compensation[src_fmt_q];

  logic                            input_sign;   // input sign
  logic signed [INT_EXP_WIDTH-1:0] input_exp;    // unbiased true exponent
  logic        [INT_MAN_WIDTH-1:0] input_mant;   // normalized input mantissa
  logic                            mant_is_zero; // for integer zeroes

  logic signed [INT_EXP_WIDTH-1:0] fp_input_exp;
  logic signed [INT_EXP_WIDTH-1:0] int_input_exp;

  // Input mantissa needs to be normalized
  logic [LZC_RESULT_WIDTH-1:0] renorm_shamt;     // renormalization shift amount
  logic [LZC_RESULT_WIDTH:0]   renorm_shamt_sgn; // signed form for calculations

  // Leading-zero counter is needed for renormalization
  lzc #(
    .WIDTH ( INT_MAN_WIDTH ),
    .MODE  ( 1             ) // MODE = 1 counts leading zeroes
  ) i_lzc (
    .in_i    ( encoded_mant ),
    .cnt_o   ( renorm_shamt ),
    .empty_o ( mant_is_zero )
  );
  assign renorm_shamt_sgn = signed'({1'b0, renorm_shamt});

  // Get the sign from the proper source
  assign input_sign = src_is_int ? int_sign : fmt_sign[src_fmt_q];
  // Realign input mantissa, append zeroes if destination is wider
  assign input_mant = encoded_mant << renorm_shamt;
  // Unbias exponent and compensate for shift
  assign fp_input_exp  = signed'(src_exp + src_subnormal - src_bias -
                                 renorm_shamt_sgn + src_offset); // compensate for shift
  assign int_input_exp = signed'(INT_MAN_WIDTH - 1 - renorm_shamt_sgn);

  assign input_exp     = src_is_int ? int_input_exp : fp_input_exp;

  logic signed [INT_EXP_WIDTH-1:0] destination_exp;  // re-biased exponent for destination

  // Rebias the exponent
  assign destination_exp = input_exp + signed'(fpnew_pkg::bias(dst_fmt_q));

  // ---------------
  // Internal pipeline
  // ---------------
  // Pipeline output signals as non-arrays
  logic                            input_sign_q;
  logic signed [INT_EXP_WIDTH-1:0] input_exp_q;
  logic [INT_MAN_WIDTH-1:0]        input_mant_q;
  logic signed [INT_EXP_WIDTH-1:0] destination_exp_q;
  logic                            src_is_int_q;
  logic                            dst_is_int_q;
  fpnew_pkg::fp_info_t             info_q;
  logic                            mant_is_zero_q;
  logic                            op_mod_q2;
  fpnew_pkg::roundmode_e           rnd_mode_q;
  fpnew_pkg::fp_format_e           src_fmt_q2;
  fpnew_pkg::fp_format_e           dst_fmt_q2;
  fpnew_pkg::int_format_e          int_fmt_q2;
  // Internal pipeline signals, index i holds signal after i register stages


  logic                   [0:NUM_MID_REGS]                    mid_pipe_input_sign_q;
  logic signed            [0:NUM_MID_REGS][INT_EXP_WIDTH-1:0] mid_pipe_input_exp_q;
  logic                   [0:NUM_MID_REGS][INT_MAN_WIDTH-1:0] mid_pipe_input_mant_q;
  logic signed            [0:NUM_MID_REGS][INT_EXP_WIDTH-1:0] mid_pipe_dest_exp_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_src_is_int_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_dst_is_int_q;
  fpnew_pkg::fp_info_t    [0:NUM_MID_REGS]                    mid_pipe_info_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_mant_zero_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_op_mod_q;
  fpnew_pkg::roundmode_e  [0:NUM_MID_REGS]                    mid_pipe_rnd_mode_q;
  fpnew_pkg::fp_format_e  [0:NUM_MID_REGS]                    mid_pipe_src_fmt_q;
  fpnew_pkg::fp_format_e  [0:NUM_MID_REGS]                    mid_pipe_dst_fmt_q;
  fpnew_pkg::int_format_e [0:NUM_MID_REGS]                    mid_pipe_int_fmt_q;
  TagType                 [0:NUM_MID_REGS]                    mid_pipe_tag_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_mask_q;
  AuxType                 [0:NUM_MID_REGS]                    mid_pipe_aux_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_MID_REGS] mid_pipe_ready;

  // Input stage: First element of pipeline is taken from upstream logic
  assign mid_pipe_input_sign_q[0] = input_sign;
  assign mid_pipe_input_exp_q[0]  = input_exp;
  assign mid_pipe_input_mant_q[0] = input_mant;
  assign mid_pipe_dest_exp_q[0]   = destination_exp;
  assign mid_pipe_src_is_int_q[0] = src_is_int;
  assign mid_pipe_dst_is_int_q[0] = dst_is_int;
  assign mid_pipe_info_q[0]       = info[src_fmt_q];
  assign mid_pipe_mant_zero_q[0]  = mant_is_zero;
  assign mid_pipe_op_mod_q[0]     = op_mod_q;
  assign mid_pipe_rnd_mode_q[0]   = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign mid_pipe_src_fmt_q[0]    = src_fmt_q;
  assign mid_pipe_dst_fmt_q[0]    = dst_fmt_q;
  assign mid_pipe_int_fmt_q[0]    = int_fmt_q;
  assign mid_pipe_tag_q[0]        = inp_pipe_tag_q[NUM_INP_REGS];
  assign mid_pipe_mask_q[0]       = inp_pipe_mask_q[NUM_INP_REGS];
  assign mid_pipe_aux_q[0]        = inp_pipe_aux_q[NUM_INP_REGS];
  assign mid_pipe_valid_q[0]      = inp_pipe_valid_q[NUM_INP_REGS];
  // Input stage: Propagate pipeline ready signal to input pipe
  assign inp_pipe_ready[NUM_INP_REGS] = mid_pipe_ready[0];

  // Generate the register stages
  for (genvar i = 0; i < NUM_MID_REGS; i++) begin : gen_inside_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign mid_pipe_ready[i] = mid_pipe_ready[i+1] | ~mid_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(mid_pipe_valid_q[i+1], mid_pipe_valid_q[i], mid_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (mid_pipe_ready[i] & mid_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(mid_pipe_input_sign_q[i+1], mid_pipe_input_sign_q[i], reg_ena, '0)
    `FFL(mid_pipe_input_exp_q[i+1],  mid_pipe_input_exp_q[i],  reg_ena, '0)
    `FFL(mid_pipe_input_mant_q[i+1], mid_pipe_input_mant_q[i], reg_ena, '0)
    `FFL(mid_pipe_dest_exp_q[i+1],   mid_pipe_dest_exp_q[i],   reg_ena, '0)
    `FFL(mid_pipe_src_is_int_q[i+1], mid_pipe_src_is_int_q[i], reg_ena, '0)
    `FFL(mid_pipe_dst_is_int_q[i+1], mid_pipe_dst_is_int_q[i], reg_ena, '0)
    `FFL(mid_pipe_info_q[i+1],       mid_pipe_info_q[i],       reg_ena, '0)
    `FFL(mid_pipe_mant_zero_q[i+1],  mid_pipe_mant_zero_q[i],  reg_ena, '0)
    `FFL(mid_pipe_op_mod_q[i+1],     mid_pipe_op_mod_q[i],     reg_ena, '0)
    `FFL(mid_pipe_rnd_mode_q[i+1],   mid_pipe_rnd_mode_q[i],   reg_ena, fpnew_pkg::RNE)
    `FFL(mid_pipe_src_fmt_q[i+1],    mid_pipe_src_fmt_q[i],    reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(mid_pipe_dst_fmt_q[i+1],    mid_pipe_dst_fmt_q[i],    reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(mid_pipe_int_fmt_q[i+1],    mid_pipe_int_fmt_q[i],    reg_ena, fpnew_pkg::int_format_e'(0))
    `FFL(mid_pipe_tag_q[i+1],        mid_pipe_tag_q[i],        reg_ena, TagType'('0))
    `FFL(mid_pipe_mask_q[i+1],       mid_pipe_mask_q[i],       reg_ena, '0)
    `FFL(mid_pipe_aux_q[i+1],        mid_pipe_aux_q[i],        reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign input_sign_q      = mid_pipe_input_sign_q[NUM_MID_REGS];
  assign input_exp_q       = mid_pipe_input_exp_q[NUM_MID_REGS];
  assign input_mant_q      = mid_pipe_input_mant_q[NUM_MID_REGS];
  assign destination_exp_q = mid_pipe_dest_exp_q[NUM_MID_REGS];
  assign src_is_int_q      = mid_pipe_src_is_int_q[NUM_MID_REGS];
  assign dst_is_int_q      = mid_pipe_dst_is_int_q[NUM_MID_REGS];
  assign info_q            = mid_pipe_info_q[NUM_MID_REGS];
  assign mant_is_zero_q    = mid_pipe_mant_zero_q[NUM_MID_REGS];
  assign op_mod_q2         = mid_pipe_op_mod_q[NUM_MID_REGS];
  assign rnd_mode_q        = mid_pipe_rnd_mode_q[NUM_MID_REGS];
  assign src_fmt_q2        = mid_pipe_src_fmt_q[NUM_MID_REGS];
  assign dst_fmt_q2        = mid_pipe_dst_fmt_q[NUM_MID_REGS];
  assign int_fmt_q2        = mid_pipe_int_fmt_q[NUM_MID_REGS];

  // --------
  // Casting
  // --------
  logic [INT_EXP_WIDTH-1:0] final_exp;        // after eventual adjustments

  logic [2*INT_MAN_WIDTH:0]  preshift_mant;    // mantissa before final shift
  logic [2*INT_MAN_WIDTH:0]  destination_mant; // mantissa from shifter, with rnd bit
  logic [SUPER_MAN_BITS-1:0] final_mant;       // mantissa after adjustments
  logic [MAX_INT_WIDTH-1:0]  final_int;        // integer shifted in position

  logic [$clog2(INT_MAN_WIDTH+1)-1:0] denorm_shamt; // shift amount for denormalization

  logic [1:0] fp_round_sticky_bits, int_round_sticky_bits, round_sticky_bits;
  logic       of_before_round, uf_before_round;


  // Perform adjustments to mantissa and exponent
  always_comb begin : cast_value
    // Default assignment
    final_exp       = unsigned'(destination_exp_q); // take exponent as is, only look at lower bits
    preshift_mant   = '0;  // initialize mantissa container with zeroes
    denorm_shamt    = SUPER_MAN_BITS - fpnew_pkg::man_bits(dst_fmt_q2); // right of mantissa
    of_before_round = 1'b0;
    uf_before_round = 1'b0;

    // Place mantissa to the left of the shifter
    preshift_mant = input_mant_q << (INT_MAN_WIDTH + 1);

    // Handle INT casts
    if (dst_is_int_q) begin
      // By default right shift mantissa to be an integer
      denorm_shamt = unsigned'(MAX_INT_WIDTH - 1 - input_exp_q);
      // overflow: when converting to unsigned the range is larger by one
      if ((input_exp_q >= signed'(fpnew_pkg::int_width(int_fmt_q2) - 1 + op_mod_q2))    // Exponent larger than max int range,
          && !(!op_mod_q2                                                               // unless cast to signed int
               && input_sign_q                                                          // and input value is larges negative int value
               && (input_exp_q == signed'(fpnew_pkg::int_width(int_fmt_q2) - 1))
               && (input_mant_q == {1'b1, {INT_MAN_WIDTH-1{1'b0}}}))) begin
        denorm_shamt    = '0; // prevent shifting
        of_before_round = 1'b1;
      // underflow
      end else if (input_exp_q < -1) begin
        denorm_shamt    = MAX_INT_WIDTH + 1; // all bits go to the sticky
        uf_before_round = 1'b1;
      end
    // Handle FP over-/underflows
    end else begin
      // Overflow or infinities (for proper rounding)
      if ((destination_exp_q >= signed'(2**fpnew_pkg::exp_bits(dst_fmt_q2))-1) ||
          (~src_is_int_q && info_q.is_inf)) begin
        final_exp       = unsigned'(2**fpnew_pkg::exp_bits(dst_fmt_q2)-2); // largest normal value
        preshift_mant   = '1;                           // largest normal value and RS bits set
        of_before_round = 1'b1;
      // Denormalize underflowing values
      end else if (destination_exp_q < 1 &&
                   destination_exp_q >= -signed'(fpnew_pkg::man_bits(dst_fmt_q2))) begin
        final_exp       = '0; // denormal result
        denorm_shamt    = unsigned'(denorm_shamt + 1 - destination_exp_q); // adjust right shifting
        uf_before_round = 1'b1;
      // Limit the shift to retain sticky bits
      end else if (destination_exp_q < -signed'(fpnew_pkg::man_bits(dst_fmt_q2))) begin
        final_exp       = '0; // denormal result
        denorm_shamt    = unsigned'(denorm_shamt + 2 + fpnew_pkg::man_bits(dst_fmt_q2)); // to sticky
        uf_before_round = 1'b1;
      end
    end
  end

  localparam NUM_FP_STICKY  = 2 * INT_MAN_WIDTH - SUPER_MAN_BITS - 1; // removed mantissa, 1. and R
  localparam NUM_INT_STICKY = 2 * INT_MAN_WIDTH - MAX_INT_WIDTH; // removed int and R

  // Mantissa adjustment shift
  assign destination_mant = preshift_mant >> denorm_shamt;
  // Extract final mantissa and round bit, discard the normal bit (for FP)
  assign {final_mant, fp_round_sticky_bits[1]} =
      destination_mant[2*INT_MAN_WIDTH-1-:SUPER_MAN_BITS+1];
  assign {final_int, int_round_sticky_bits[1]} = destination_mant[2*INT_MAN_WIDTH-:MAX_INT_WIDTH+1];
  // Collapse sticky bits
  assign fp_round_sticky_bits[0]  = (| {destination_mant[NUM_FP_STICKY-1:0]});
  assign int_round_sticky_bits[0] = (| {destination_mant[NUM_INT_STICKY-1:0]});

  // select RS bits for destination operation
  assign round_sticky_bits = dst_is_int_q ? int_round_sticky_bits : fp_round_sticky_bits;

  // ----------------------------
  // Rounding and classification
  // ----------------------------
  logic [WIDTH-1:0] pre_round_abs;  // absolute value of result before rnd
  logic             of_after_round; // overflow
  logic             uf_after_round; // underflow

  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_pre_round_abs; // per format
  logic [NUM_FORMATS-1:0]            fmt_of_after_round;
  logic [NUM_FORMATS-1:0]            fmt_uf_after_round;

  logic [NUM_INT_FORMATS-1:0][WIDTH-1:0] ifmt_pre_round_abs; // per format
  logic [NUM_INT_FORMATS-1:0]            ifmt_of_after_round;

  logic             rounded_sign;
  logic [WIDTH-1:0] rounded_abs; // absolute value of result after rounding
  logic             result_true_zero;

  logic [WIDTH-1:0] rounded_int_res; // after possible inversion
  logic             rounded_int_res_zero; // after rounding


  // Pack exponent and mantissa into proper rounding form
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_res_assemble
    // Set up some constants
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : assemble_result
        fmt_pre_round_abs[fmt] = {final_exp[EXP_BITS-1:0], final_mant[MAN_BITS-1:0]}; // 0-extend
      end
    end else begin : inactive_format
      assign fmt_pre_round_abs[fmt] = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Sign-extend integer result
  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_int_res_sign_ext
    // Set up some constants
    localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));

    if (IntFmtConfig[ifmt]) begin : active_format
      always_comb begin : assemble_result
        // sign-extend reusult
        ifmt_pre_round_abs[ifmt]                = '{default: final_int[INT_WIDTH-1]};
        ifmt_pre_round_abs[ifmt][INT_WIDTH-1:0] = final_int[INT_WIDTH-1:0];
      end
    end else begin : inactive_format
      assign ifmt_pre_round_abs[ifmt] = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Select output with destination format and operation
  assign pre_round_abs = dst_is_int_q ? ifmt_pre_round_abs[int_fmt_q2] : fmt_pre_round_abs[dst_fmt_q2];

  fpnew_rounding #(
    .AbsWidth ( WIDTH )
  ) i_fpnew_rounding (
    .abs_value_i             ( pre_round_abs     ),
    .sign_i                  ( input_sign_q      ), // source format
    .round_sticky_bits_i     ( round_sticky_bits ),
    .rnd_mode_i              ( rnd_mode_q        ),
    .effective_subtraction_i ( 1'b0              ), // no operation happened
    .abs_rounded_o           ( rounded_abs       ),
    .sign_o                  ( rounded_sign      ),
    .exact_zero_o            ( result_true_zero  )
  );

  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_result;

  // Detect overflows and inject sign
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_sign_inject
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : post_process
        // detect of / uf
        fmt_uf_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0; // denormal
        fmt_of_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '1; // inf exp.

        // Assemble regular result, nan box short ones. Int zeroes need to be detected`
        fmt_result[fmt]               = '1;
        fmt_result[fmt][FP_WIDTH-1:0] = src_is_int_q & mant_is_zero_q
                                        ? '0
                                        : {rounded_sign, rounded_abs[EXP_BITS+MAN_BITS-1:0]};
      end
    end else begin : inactive_format
      assign fmt_uf_after_round[fmt] = fpnew_pkg::DONT_CARE;
      assign fmt_of_after_round[fmt] = fpnew_pkg::DONT_CARE;
      assign fmt_result[fmt]         = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Negative integer result needs to be brought into two's complement
  assign rounded_int_res      = rounded_sign ? unsigned'(-rounded_abs) : rounded_abs;
  assign rounded_int_res_zero = (rounded_int_res == '0);

  // Detect integer overflows after rounding (only positives)
  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_int_overflow
    // Set up some constants
    localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));

    if (IntFmtConfig[ifmt]) begin : active_format
      always_comb begin : detect_overflow
        ifmt_of_after_round[ifmt] = 1'b0;
        // Int result can overflow if we're at the max exponent
        if (!rounded_sign && input_exp_q == signed'(INT_WIDTH - 2 + op_mod_q2)) begin
          // Check whether the rounded MSB differs from unrounded MSB
          ifmt_of_after_round[ifmt] = ~rounded_int_res[INT_WIDTH-2+op_mod_q2];
        end
      end
    end else begin : inactive_format
      assign ifmt_of_after_round[ifmt] = fpnew_pkg::DONT_CARE;
    end
  end

  // Classification after rounding select by destination format
  assign uf_after_round = fmt_uf_after_round[dst_fmt_q2];
  assign of_after_round = dst_is_int_q ? ifmt_of_after_round[int_fmt_q2] : fmt_of_after_round[dst_fmt_q2];

  // -------------------------
  // FP Special case handling
  // -------------------------
  logic [WIDTH-1:0]   fp_special_result;
  fpnew_pkg::status_t fp_special_status;
  logic               fp_result_is_special;

  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_special_result;

  // Special result construction
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_special_results
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    localparam logic [EXP_BITS-1:0] QNAN_EXPONENT = '1;
    localparam logic [MAN_BITS-1:0] QNAN_MANTISSA = 2**(MAN_BITS-1);

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : special_results
        logic [FP_WIDTH-1:0] special_res;
        special_res = info_q.is_zero
                      ? input_sign_q << FP_WIDTH-1 // signed zero
                      : {1'b0, QNAN_EXPONENT, QNAN_MANTISSA}; // qNaN

        // Initialize special result with ones (NaN-box)
        fmt_special_result[fmt]               = '1;
        fmt_special_result[fmt][FP_WIDTH-1:0] = special_res;
      end
    end else begin : inactive_format
      assign fmt_special_result[fmt] = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Detect special case from source format, I2F casts don't produce a special result
  assign fp_result_is_special = ~src_is_int_q & (info_q.is_zero |
                                                 info_q.is_nan |
                                                 ~info_q.is_boxed);

  // Signalling input NaNs raise invalid flag, otherwise no flags set
  assign fp_special_status = '{NV: info_q.is_signalling, default: 1'b0};

  // Assemble result according to destination format
  assign fp_special_result = fmt_special_result[dst_fmt_q2]; // destination format

  // --------------------------
  // INT Special case handling
  // --------------------------
  logic [WIDTH-1:0]   int_special_result;
  fpnew_pkg::status_t int_special_status;
  logic               int_result_is_special;

  logic [NUM_INT_FORMATS-1:0][WIDTH-1:0] ifmt_special_result;

  // Special result construction
  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_special_results_int
    // Set up some constants
    localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));

    if (IntFmtConfig[ifmt]) begin : active_format
      always_comb begin : special_results
        automatic logic [INT_WIDTH-1:0] special_res;

        // Default is overflow to positive max, which is 2**INT_WIDTH-1 or 2**(INT_WIDTH-1)-1
        special_res[INT_WIDTH-2:0] = '1;       // alone yields 2**(INT_WIDTH-1)-1
        special_res[INT_WIDTH-1]   = op_mod_q2; // for unsigned casts yields 2**INT_WIDTH-1

        // Negative special case (except for nans) tie to -max or 0
        if (input_sign_q && !info_q.is_nan)
          special_res = ~special_res;

        // Initialize special result with sign-extension
        ifmt_special_result[ifmt]                = '{default: special_res[INT_WIDTH-1]};
        ifmt_special_result[ifmt][INT_WIDTH-1:0] = special_res;
      end
    end else begin : inactive_format
      assign ifmt_special_result[ifmt] = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Detect special case from source format (inf, nan, overflow, nan-boxing or negative unsigned)
  assign int_result_is_special = info_q.is_nan | info_q.is_inf |
                                 of_before_round | of_after_round | ~info_q.is_boxed |
                                 (input_sign_q & op_mod_q2 & ~rounded_int_res_zero);

  // All integer special cases are invalid
  assign int_special_status = '{NV: 1'b1, default: 1'b0};

  // Assemble result according to destination format
  assign int_special_result = ifmt_special_result[int_fmt_q2]; // destination format

  // -----------------
  // Result selection
  // -----------------
  fpnew_pkg::status_t int_regular_status, fp_regular_status;

  logic [WIDTH-1:0]   fp_result, int_result;
  fpnew_pkg::status_t fp_status, int_status;

  assign fp_regular_status.NV = src_is_int_q & (of_before_round | of_after_round); // overflow is invalid for I2F casts
  assign fp_regular_status.DZ = 1'b0; // no divisions
  assign fp_regular_status.OF = ~src_is_int_q & (~info_q.is_inf & (of_before_round | of_after_round)); // inf casts no OF
  assign fp_regular_status.UF = uf_after_round & fp_regular_status.NX;
  assign fp_regular_status.NX = src_is_int_q ? (| fp_round_sticky_bits) // overflow is invalid in i2f
            : (| fp_round_sticky_bits) | (~info_q.is_inf & (of_before_round | of_after_round));
  assign int_regular_status = '{NX: (| int_round_sticky_bits), default: 1'b0};

  assign fp_result  = fp_result_is_special  ? fp_special_result  : fmt_result[dst_fmt_q2];
  assign fp_status  = fp_result_is_special  ? fp_special_status  : fp_regular_status;
  assign int_result = int_result_is_special ? int_special_result : rounded_int_res;
  assign int_status = int_result_is_special ? int_special_status : int_regular_status;

  // Final results for output pipeline
  logic [WIDTH-1:0]   result_d;
  fpnew_pkg::status_t status_d;
  logic               extension_bit;

  // Select output depending on special case detection
  assign result_d = dst_is_int_q ? int_result : fp_result;
  assign status_d = dst_is_int_q ? int_status : fp_status;

  // MSB of int result decides extension, otherwise NaN box
  assign extension_bit = dst_is_int_q ? int_result[WIDTH-1] : 1'b1;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  logic               [0:NUM_OUT_REGS][WIDTH-1:0] out_pipe_result_q;
  fpnew_pkg::status_t [0:NUM_OUT_REGS]            out_pipe_status_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_ext_bit_q;
  TagType             [0:NUM_OUT_REGS]            out_pipe_tag_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_mask_q;
  AuxType             [0:NUM_OUT_REGS]            out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0]  = result_d;
  assign out_pipe_status_q[0]  = status_d;
  assign out_pipe_ext_bit_q[0] = extension_bit;
  assign out_pipe_tag_q[0]     = mid_pipe_tag_q[NUM_MID_REGS];
  assign out_pipe_mask_q[0]    = mid_pipe_mask_q[NUM_MID_REGS];
  assign out_pipe_aux_q[0]     = mid_pipe_aux_q[NUM_MID_REGS];
  assign out_pipe_valid_q[0]   = mid_pipe_valid_q[NUM_MID_REGS];
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign mid_pipe_ready[NUM_MID_REGS] = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + NUM_MID_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1],  out_pipe_result_q[i],  reg_ena, '0)
    `FFL(out_pipe_status_q[i+1],  out_pipe_status_q[i],  reg_ena, '0)
    `FFL(out_pipe_ext_bit_q[i+1], out_pipe_ext_bit_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],     out_pipe_tag_q[i],     reg_ena, TagType'('0))
    `FFL(out_pipe_mask_q[i+1],    out_pipe_mask_q[i],    reg_ena, '0)
    `FFL(out_pipe_aux_q[i+1],     out_pipe_aux_q[i],     reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = out_pipe_ext_bit_q[NUM_OUT_REGS];
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, mid_pipe_valid_q, out_pipe_valid_q});
endmodule
// ----- 8< ----- FILE "./fpnew_classifier.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module fpnew_classifier #(
  parameter fpnew_pkg::fp_format_e   FpFormat = fpnew_pkg::fp_format_e'(0),
  parameter int unsigned             NumOperands = 1,
  // Do not change
  localparam int unsigned WIDTH = fpnew_pkg::fp_width(FpFormat)
) (
  input  logic                [NumOperands-1:0][WIDTH-1:0] operands_i,
  input  logic                [NumOperands-1:0]            is_boxed_i,
  output fpnew_pkg::fp_info_t [NumOperands-1:0]            info_o
);

  localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(FpFormat);
  localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(FpFormat);

  // Type definition
  typedef struct packed {
    logic                sign;
    logic [EXP_BITS-1:0] exponent;
    logic [MAN_BITS-1:0] mantissa;
  } fp_t;

  // Iterate through all operands
  for (genvar op = 0; op < int'(NumOperands); op++) begin : gen_num_values

    fp_t value;
    logic is_boxed;
    logic is_normal;
    logic is_inf;
    logic is_nan;
    logic is_signalling;
    logic is_quiet;
    logic is_zero;
    logic is_subnormal;

    // ---------------
    // Classify Input
    // ---------------
    always_comb begin : classify_input
      value         = operands_i[op];
      is_boxed      = is_boxed_i[op];
      is_normal     = is_boxed && (value.exponent != '0) && (value.exponent != '1);
      is_zero       = is_boxed && (value.exponent == '0) && (value.mantissa == '0);
      is_subnormal  = is_boxed && (value.exponent == '0) && !is_zero;
      is_inf        = is_boxed && ((value.exponent == '1) && (value.mantissa == '0));
      is_nan        = !is_boxed || ((value.exponent == '1) && (value.mantissa != '0));
      is_signalling = is_boxed && is_nan && (value.mantissa[MAN_BITS-1] == 1'b0);
      is_quiet      = is_nan && !is_signalling;
      // Assign output for current input
      info_o[op].is_normal     = is_normal;
      info_o[op].is_subnormal  = is_subnormal;
      info_o[op].is_zero       = is_zero;
      info_o[op].is_inf        = is_inf;
      info_o[op].is_nan        = is_nan;
      info_o[op].is_signalling = is_signalling;
      info_o[op].is_quiet      = is_quiet;
      info_o[op].is_boxed      = is_boxed;
    end
  end
endmodule
// ----- 8< ----- FILE "./gated_clk_cell.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

module gated_clk_cell(
  clk_in,
  global_en,
  module_en,
  local_en,
  external_en,
  pad_yy_icg_scan_en,
  clk_out
);

input  clk_in;
input  global_en;
input  module_en;
input  local_en;
input  external_en;
input  pad_yy_icg_scan_en;
output clk_out;

wire   clk_en_bf_latch;
wire   SE;

assign clk_en_bf_latch = (global_en && (module_en || local_en)) || external_en ;

// SE driven from primary input, held constant
assign SE	       = pad_yy_icg_scan_en;
 
// //   &Connect(    .clk_in           (clk_in), @50
// //                .SE               (SE), @51
// //                .external_en      (clk_en_bf_latch), @52
// //                .clk_out          (clk_out) @53
// //                ) ; @54

assign clk_out = clk_in;

endmodule   
// ----- 8< ----- FILE "./pa_fdsu_ctrl.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_ctrl(
  cp0_fpu_icg_en,
  cp0_yy_clk_en,
  cpurst_b,
  ctrl_fdsu_ex1_sel,
  ctrl_xx_ex1_cmplt_dp,
  ctrl_xx_ex1_inst_vld,
  ctrl_xx_ex1_stall,
  ctrl_xx_ex1_warm_up,
  ctrl_xx_ex2_warm_up,
  ctrl_xx_ex3_warm_up,
  ex1_div,
  ex1_expnt_adder_op0,
  ex1_of_result_lfn,
  ex1_op0_id,
  ex1_op0_norm,
  ex1_op1_id_vld,
  ex1_op1_norm,
  ex1_op1_sel,
  ex1_oper_id_expnt,
  ex1_oper_id_expnt_f,
  ex1_pipedown,
  ex1_pipedown_gate,
  ex1_result_sign,
  ex1_rm,
  ex1_save_op0,
  ex1_save_op0_gate,
  ex1_sqrt,
  ex1_srt_skip,
  ex2_expnt_adder_op0,
  ex2_of,
  ex2_pipe_clk,
  ex2_pipedown,
  ex2_potnt_of,
  ex2_potnt_uf,
  ex2_result_inf,
  ex2_result_lfn,
  ex2_rslt_denorm,
  ex2_srt_expnt_rst,
  ex2_srt_first_round,
  ex2_uf,
  ex2_uf_srt_skip,
  ex3_expnt_adjust_result,
  ex3_pipedown,
  ex3_rslt_denorm,
  fdsu_ex1_sel,
  fdsu_fpu_debug_info,
  fdsu_fpu_ex1_cmplt,
  fdsu_fpu_ex1_cmplt_dp,
  fdsu_fpu_ex1_stall,
  fdsu_fpu_no_op,
  fdsu_frbus_wb_vld,
  fdsu_yy_div,
  fdsu_yy_expnt_rst,
  fdsu_yy_of,
  fdsu_yy_of_rm_lfn,
  fdsu_yy_op0_norm,
  fdsu_yy_op1_norm,
  fdsu_yy_potnt_of,
  fdsu_yy_potnt_uf,
  fdsu_yy_result_inf,
  fdsu_yy_result_lfn,
  fdsu_yy_result_sign,
  fdsu_yy_rm,
  fdsu_yy_rslt_denorm,
  fdsu_yy_sqrt,
  fdsu_yy_uf,
  fdsu_yy_wb_freg,
  forever_cpuclk,
  frbus_fdsu_wb_grant,
  idu_fpu_ex1_dst_freg,
  idu_fpu_ex1_eu_sel,
  pad_yy_icg_scan_en,
  rtu_xx_ex1_cancel,
  rtu_xx_ex2_cancel,
  rtu_yy_xx_async_flush,
  rtu_yy_xx_flush,
  srt_remainder_zero,
  srt_sm_on
);

// &Ports; @24
input           cp0_fpu_icg_en;         
input           cp0_yy_clk_en;          
input           cpurst_b;               
input           ctrl_fdsu_ex1_sel;      
input           ctrl_xx_ex1_cmplt_dp;   
input           ctrl_xx_ex1_inst_vld;   
input           ctrl_xx_ex1_stall;      
input           ctrl_xx_ex1_warm_up;    
input           ctrl_xx_ex2_warm_up;    
input           ctrl_xx_ex3_warm_up;    
input           ex1_div;                
input   [12:0]  ex1_expnt_adder_op0;    
input           ex1_of_result_lfn;      
input           ex1_op0_id;             
input           ex1_op0_norm;           
input           ex1_op1_id_vld;         
input           ex1_op1_norm;           
input   [12:0]  ex1_oper_id_expnt;      
input           ex1_result_sign;        
input   [2 :0]  ex1_rm;                 
input           ex1_sqrt;               
input           ex1_srt_skip;           
input           ex2_of;                 
input           ex2_potnt_of;           
input           ex2_potnt_uf;           
input           ex2_result_inf;         
input           ex2_result_lfn;         
input           ex2_rslt_denorm;        
input   [9 :0]  ex2_srt_expnt_rst;      
input           ex2_uf;                 
input           ex2_uf_srt_skip;        
input   [9 :0]  ex3_expnt_adjust_result; 
input           ex3_rslt_denorm;        
input           forever_cpuclk;         
input           frbus_fdsu_wb_grant;    
input   [4 :0]  idu_fpu_ex1_dst_freg;   
input   [2 :0]  idu_fpu_ex1_eu_sel;     
input           pad_yy_icg_scan_en;     
input           rtu_xx_ex1_cancel;      
input           rtu_xx_ex2_cancel;      
input           rtu_yy_xx_async_flush;  
input           rtu_yy_xx_flush;        
input           srt_remainder_zero;     
output          ex1_op1_sel;            
output  [12:0]  ex1_oper_id_expnt_f;    
output          ex1_pipedown;           
output          ex1_pipedown_gate;      
output          ex1_save_op0;           
output          ex1_save_op0_gate;      
output  [9 :0]  ex2_expnt_adder_op0;    
output          ex2_pipe_clk;           
output          ex2_pipedown;           
output          ex2_srt_first_round;    
output          ex3_pipedown;           
output          fdsu_ex1_sel;           
output  [4 :0]  fdsu_fpu_debug_info;    
output          fdsu_fpu_ex1_cmplt;     
output          fdsu_fpu_ex1_cmplt_dp;  
output          fdsu_fpu_ex1_stall;     
output          fdsu_fpu_no_op;         
output          fdsu_frbus_wb_vld;      
output          fdsu_yy_div;            
output  [9 :0]  fdsu_yy_expnt_rst;      
output          fdsu_yy_of;             
output          fdsu_yy_of_rm_lfn;      
output          fdsu_yy_op0_norm;       
output          fdsu_yy_op1_norm;       
output          fdsu_yy_potnt_of;       
output          fdsu_yy_potnt_uf;       
output          fdsu_yy_result_inf;     
output          fdsu_yy_result_lfn;     
output          fdsu_yy_result_sign;    
output  [2 :0]  fdsu_yy_rm;             
output          fdsu_yy_rslt_denorm;    
output          fdsu_yy_sqrt;           
output          fdsu_yy_uf;             
output  [4 :0]  fdsu_yy_wb_freg;        
output          srt_sm_on;              

// &Regs; @25
reg             ex2_srt_first_round;    
reg     [2 :0]  fdsu_cur_state;         
reg             fdsu_div;               
reg     [9 :0]  fdsu_expnt_rst;         
reg     [2 :0]  fdsu_next_state;        
reg             fdsu_of;                
reg             fdsu_of_rm_lfn;         
reg             fdsu_potnt_of;          
reg             fdsu_potnt_uf;          
reg             fdsu_result_inf;        
reg             fdsu_result_lfn;        
reg             fdsu_result_sign;       
reg     [2 :0]  fdsu_rm;                
reg             fdsu_sqrt;              
reg             fdsu_uf;                
reg     [4 :0]  fdsu_wb_freg;           
reg             fdsu_yy_rslt_denorm;    
reg     [4 :0]  srt_cnt;                
reg     [1 :0]  wb_cur_state;           
reg     [1 :0]  wb_nxt_state;           

// &Wires; @26
wire            cp0_fpu_icg_en;         
wire            cp0_yy_clk_en;          
wire            cpurst_b;               
wire            ctrl_fdsu_ex1_sel;      
wire            ctrl_fdsu_ex1_stall;    
wire            ctrl_fdsu_wb_vld;       
wire            ctrl_iter_start;        
wire            ctrl_iter_start_gate;   
wire            ctrl_pack;              
wire            ctrl_result_vld;        
wire            ctrl_round;             
wire            ctrl_sm_cmplt;          
wire            ctrl_sm_ex1;            
wire            ctrl_sm_idle;           
wire            ctrl_sm_start;          
wire            ctrl_sm_start_gate;     
wire            ctrl_srt_idle;          
wire            ctrl_srt_itering;       
wire            ctrl_wb_idle;           
wire            ctrl_wb_sm_cmplt;       
wire            ctrl_wb_sm_ex2;         
wire            ctrl_wb_sm_idle;        
wire            ctrl_wfi2;              
wire            ctrl_wfwb;              
wire            ctrl_xx_ex1_cmplt_dp;   
wire            ctrl_xx_ex1_inst_vld;   
wire            ctrl_xx_ex1_stall;      
wire            ctrl_xx_ex1_warm_up;    
wire            ctrl_xx_ex2_warm_up;    
wire            ctrl_xx_ex3_warm_up;    
wire            ex1_div;                
wire    [12:0]  ex1_expnt_adder_op0;    
wire            ex1_of_result_lfn;      
wire            ex1_op0_id;             
wire            ex1_op1_id_vld;         
wire            ex1_op1_sel;            
wire    [12:0]  ex1_oper_id_expnt;      
wire    [12:0]  ex1_oper_id_expnt_f;    
wire            ex1_pipe_clk;           
wire            ex1_pipe_clk_en;        
wire            ex1_pipedown;           
wire            ex1_pipedown_gate;      
wire            ex1_result_sign;        
wire    [2 :0]  ex1_rm;                 
wire            ex1_save_op0;           
wire            ex1_save_op0_gate;      
wire            ex1_sqrt;               
wire            ex1_srt_skip;           
wire    [4 :0]  ex1_wb_freg;            
wire    [9 :0]  ex2_expnt_adder_op0;    
wire            ex2_of;                 
wire            ex2_pipe_clk;           
wire            ex2_pipe_clk_en;        
wire            ex2_pipedown;           
wire            ex2_potnt_of;           
wire            ex2_potnt_uf;           
wire            ex2_result_inf;         
wire            ex2_result_lfn;         
wire            ex2_rslt_denorm;        
wire    [9 :0]  ex2_srt_expnt_rst;      
wire            ex2_uf;                 
wire            ex2_uf_srt_skip;        
wire    [9 :0]  ex3_expnt_adjust_result; 
wire            ex3_pipedown;           
wire            ex3_rslt_denorm;        
wire            expnt_rst_clk;          
wire            expnt_rst_clk_en;       
wire            fdsu_busy;              
wire            fdsu_clk;               
wire            fdsu_clk_en;            
wire            fdsu_dn_stall;          
wire            fdsu_ex1_inst_vld;      
wire            fdsu_ex1_res_vld;       
wire            fdsu_ex1_sel;           
wire            fdsu_flush;             
wire    [4 :0]  fdsu_fpu_debug_info;    
wire            fdsu_fpu_ex1_cmplt;     
wire            fdsu_fpu_ex1_cmplt_dp;  
wire            fdsu_fpu_ex1_stall;     
wire            fdsu_fpu_no_op;         
wire            fdsu_frbus_wb_vld;      
wire            fdsu_op0_norm;          
wire            fdsu_op1_norm;          
wire            fdsu_wb_grant;          
wire            fdsu_yy_div;            
wire    [9 :0]  fdsu_yy_expnt_rst;      
wire            fdsu_yy_of;             
wire            fdsu_yy_of_rm_lfn;      
wire            fdsu_yy_op0_norm;       
wire            fdsu_yy_op1_norm;       
wire            fdsu_yy_potnt_of;       
wire            fdsu_yy_potnt_uf;       
wire            fdsu_yy_result_inf;     
wire            fdsu_yy_result_lfn;     
wire            fdsu_yy_result_sign;    
wire    [2 :0]  fdsu_yy_rm;             
wire            fdsu_yy_sqrt;           
wire            fdsu_yy_uf;             
wire    [4 :0]  fdsu_yy_wb_freg;        
wire            forever_cpuclk;         
wire            frbus_fdsu_wb_grant;    
wire    [4 :0]  idu_fpu_ex1_dst_freg;   
wire    [2 :0]  idu_fpu_ex1_eu_sel;     
wire            pad_yy_icg_scan_en;     
wire            rtu_xx_ex1_cancel;      
wire            rtu_xx_ex2_cancel;      
wire            rtu_yy_xx_async_flush;  
wire            rtu_yy_xx_flush;        
wire    [4 :0]  srt_cnt_ini;            
wire            srt_cnt_zero;           
wire            srt_last_round;         
wire            srt_remainder_zero;     
wire            srt_skip;               
wire            srt_sm_on;              


//==========================================================
//                       Input Signal
//==========================================================
assign ex1_wb_freg[4:0] = idu_fpu_ex1_dst_freg[4:0];
assign fdsu_ex1_inst_vld = ctrl_xx_ex1_inst_vld && ctrl_fdsu_ex1_sel;
assign fdsu_ex1_sel      = idu_fpu_ex1_eu_sel[2];
// &Force("input", "idu_fpu_ex1_eu_sel"); &Force("bus", "idu_fpu_ex1_eu_sel", 2, 0); @34

//==========================================================
//                 FDSU Main State Machine
//==========================================================
assign fdsu_ex1_res_vld  = fdsu_ex1_inst_vld && ex1_srt_skip;
assign fdsu_wb_grant = frbus_fdsu_wb_grant;

assign ctrl_iter_start = ctrl_sm_start && !fdsu_dn_stall
                      || ctrl_wfi2;
assign ctrl_iter_start_gate = ctrl_sm_start_gate && !fdsu_dn_stall
                           || ctrl_wfi2;
assign ctrl_sm_start = fdsu_ex1_inst_vld && ctrl_srt_idle
                   && !ex1_srt_skip;
assign ctrl_sm_start_gate = fdsu_ex1_inst_vld && ctrl_srt_idle;

assign srt_last_round = (srt_skip ||
                         srt_remainder_zero ||
                         srt_cnt_zero)      &&
                         ctrl_srt_itering;
assign srt_skip       =  ex2_of ||
                         ex2_uf_srt_skip;
assign srt_cnt_zero   = ~|srt_cnt[4:0];
assign fdsu_dn_stall  = ctrl_sm_start && ex1_op1_id_vld;

parameter IDLE  = 3'b000;
parameter WFI2  = 3'b001;
parameter ITER  = 3'b010;
parameter RND   = 3'b011;
parameter PACK  = 3'b100;
parameter WFWB  = 3'b101;

always @ (posedge fdsu_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    fdsu_cur_state[2:0] <= IDLE;
  else if (fdsu_flush)
    fdsu_cur_state[2:0] <= IDLE;
  else
    fdsu_cur_state[2:0] <= fdsu_next_state[2:0];
end

// &CombBeg; @76
always @( ctrl_sm_start
       or fdsu_dn_stall
       or srt_last_round
       or fdsu_cur_state[2:0]
       or fdsu_wb_grant)
begin
case (fdsu_cur_state[2:0])
  IDLE:
  begin
    if (ctrl_sm_start)
      if (fdsu_dn_stall)
        fdsu_next_state[2:0] = WFI2;
      else
        fdsu_next_state[2:0] = ITER;
    else
      fdsu_next_state[2:0] = IDLE;
  end
  WFI2:
    fdsu_next_state[2:0] = ITER;
  ITER:
  begin
    if (srt_last_round)
      fdsu_next_state[2:0] = RND;
    else
      fdsu_next_state[2:0] = ITER;
  end
  RND:
    fdsu_next_state[2:0] = PACK;
  PACK:
  begin
    if (fdsu_wb_grant)
      if (ctrl_sm_start)
        if (fdsu_dn_stall)
          fdsu_next_state[2:0] = WFI2;
        else
          fdsu_next_state[2:0] = ITER;
      else
        fdsu_next_state[2:0] = IDLE;
    else
      fdsu_next_state[2:0] = WFWB;
  end
  WFWB:
  begin
    if (fdsu_wb_grant)
      if (ctrl_sm_start)
        if (fdsu_dn_stall)
          fdsu_next_state[2:0] = WFI2;
        else
          fdsu_next_state[2:0] = ITER;
      else
        fdsu_next_state[2:0] = IDLE;
    else
      fdsu_next_state[2:0] = WFWB;
  end
  default:
    fdsu_next_state[2:0] = IDLE;
endcase
// &CombEnd; @128
end

assign ctrl_sm_idle     = fdsu_cur_state[2:0] == IDLE;
assign ctrl_wfi2        = fdsu_cur_state[2:0] == WFI2;
assign ctrl_srt_itering = fdsu_cur_state[2:0] == ITER;
assign ctrl_round       = fdsu_cur_state[2:0] == RND;
assign ctrl_pack        = fdsu_cur_state[2:0] == PACK;
assign ctrl_wfwb        = fdsu_cur_state[2:0] == WFWB;

assign ctrl_sm_cmplt    = ctrl_pack || ctrl_wfwb;
assign ctrl_srt_idle     = ctrl_sm_idle
                       || fdsu_wb_grant;
assign ctrl_sm_ex1      = ctrl_srt_idle || ctrl_wfi2;

//==========================================================
//                    Iteration Counter
//==========================================================
always @ (posedge fdsu_clk)
begin
  if (fdsu_flush)
    srt_cnt[4:0] <= 5'b0;
  else if (ctrl_iter_start)
    srt_cnt[4:0] <= srt_cnt_ini[4:0];
  else if (ctrl_srt_itering)
    srt_cnt[4:0] <= srt_cnt[4:0] - 5'b1;
  else
    srt_cnt[4:0] <= srt_cnt[4:0];
end

//srt_cnt_ini[4:0]
//For Double, initial is 5'b11100('d28), calculate 29 round
//For Single, initial is 5'b01110('d14), calculate 15 round
assign srt_cnt_ini[4:0] = 5'b01110;

//fdsu srt first round signal 
//For srt calculate special use
always @(posedge fdsu_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    ex2_srt_first_round <= 1'b0;
  else if(fdsu_flush)
    ex2_srt_first_round <= 1'b0;
  else if(ex1_pipedown)
    ex2_srt_first_round <= 1'b1;
  else
    ex2_srt_first_round <= 1'b0;
end

//==========================================================
//                 Write Back State Machine
//==========================================================
parameter WB_IDLE  = 2'b00,
          WB_EX2   = 2'b10,
          WB_CMPLT = 2'b01;

always @ (posedge fdsu_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    wb_cur_state[1:0] <= WB_IDLE;
  else if (fdsu_flush)
    wb_cur_state[1:0] <= WB_IDLE;
  else
    wb_cur_state[1:0] <= wb_nxt_state[1:0];
end

// &CombBeg; @215
always @( ctrl_fdsu_wb_vld
       or fdsu_dn_stall
       or ctrl_xx_ex1_stall
       or fdsu_ex1_inst_vld
       or ctrl_iter_start
       or fdsu_ex1_res_vld
       or wb_cur_state[1:0])
begin
  case(wb_cur_state[1:0])
    WB_IDLE:
      if (fdsu_ex1_inst_vld)
        if (ctrl_xx_ex1_stall || fdsu_ex1_res_vld || fdsu_dn_stall)
          wb_nxt_state[1:0] = WB_IDLE;
        else
          wb_nxt_state[1:0] = WB_EX2;
      else
        wb_nxt_state[1:0] = WB_IDLE;
    WB_EX2:
      // if (ctrl_xx_ex2_stall)
      //   wb_nxt_state[1:0] = WB_EX2;
      // else
        if (ctrl_fdsu_wb_vld)
          if (ctrl_iter_start && !ctrl_xx_ex1_stall)
            wb_nxt_state[1:0] = WB_EX2;
          else
            wb_nxt_state[1:0] = WB_IDLE;
        else
          wb_nxt_state[1:0] = WB_CMPLT;
    WB_CMPLT:
      if (ctrl_fdsu_wb_vld)
        if (ctrl_iter_start && !ctrl_xx_ex1_stall)
          wb_nxt_state[1:0] = WB_EX2;
        else
          wb_nxt_state[1:0] = WB_IDLE;
      else
        wb_nxt_state[1:0] = WB_CMPLT;
    default:
      wb_nxt_state[1:0] = WB_IDLE;
  endcase
// &CombEnd; @247
end

assign ctrl_wb_idle  = wb_cur_state[1:0] == WB_IDLE
                       || wb_cur_state[1:0] == WB_CMPLT && ctrl_fdsu_wb_vld;
assign ctrl_wb_sm_idle  = wb_cur_state[1:0] == WB_IDLE;
assign ctrl_wb_sm_ex2   = wb_cur_state[1:0] == WB_EX2;
assign ctrl_wb_sm_cmplt = wb_cur_state[1:0] == WB_EX2
                       || wb_cur_state[1:0] == WB_CMPLT;

assign ctrl_result_vld  = ctrl_sm_cmplt && ctrl_wb_sm_cmplt;
assign ctrl_fdsu_wb_vld = ctrl_result_vld && frbus_fdsu_wb_grant;

assign ctrl_fdsu_ex1_stall = fdsu_ex1_inst_vld && !ctrl_sm_ex1 && !ctrl_wb_idle
                          || fdsu_ex1_inst_vld && fdsu_dn_stall;

//==========================================================
//                          Flops
//==========================================================
always @(posedge ex1_pipe_clk)
begin
  if(ex1_pipedown)
  begin
    fdsu_wb_freg[4:0]    <= ex1_wb_freg[4:0];
    fdsu_result_sign     <= ex1_result_sign;
    fdsu_of_rm_lfn       <= ex1_of_result_lfn;
    fdsu_div             <= ex1_div;
    fdsu_sqrt            <= ex1_sqrt;
    fdsu_rm[2:0]         <= ex1_rm[2:0];
  end
  else
  begin
    fdsu_wb_freg[4:0]    <= fdsu_wb_freg[4:0];
    fdsu_result_sign     <= fdsu_result_sign;
    fdsu_of_rm_lfn       <= fdsu_of_rm_lfn;
    fdsu_div             <= fdsu_div;
    fdsu_sqrt            <= fdsu_sqrt;
    fdsu_rm[2:0]         <= fdsu_rm[2:0];
  end
end

// In 906 FDSU, if one op0/1 is not norm, it will not enter EX2.
assign fdsu_op0_norm = 1'b1;
assign fdsu_op1_norm = 1'b1;
// &Force("input", "ex1_op0_norm"); @337
// &Force("input", "ex1_op1_norm"); @338

// fdsu_expnt_rst is used to save:
//  1. op0 denormal expnt;
//  2. op0 expnt;
//  3. result expnt.
// &Force("bus", "ex1_oper_id_expnt", 12, 0); @378
// &Force("bus", "ex1_expnt_adder_op0", 12, 0); @379


always @ (posedge expnt_rst_clk)
begin
  if (ex1_save_op0)
    fdsu_expnt_rst[9:0] <= ex1_oper_id_expnt[9:0];
  else if (ex1_pipedown)
    fdsu_expnt_rst[9:0] <= ex1_expnt_adder_op0[9:0];
  else if (ex2_pipedown)
    fdsu_expnt_rst[9:0] <= ex2_srt_expnt_rst[9:0];
  else if (ex3_pipedown)
    fdsu_expnt_rst[9:0] <= ex3_expnt_adjust_result[9:0];
  else
    fdsu_expnt_rst[9:0] <= fdsu_expnt_rst[9:0];
end

assign ex1_oper_id_expnt_f[12:0] = {3'b1, fdsu_expnt_rst[9:0]};

always @ (posedge expnt_rst_clk)
begin
  if (ex2_pipedown)
    fdsu_yy_rslt_denorm <= ex2_rslt_denorm;
  else if (ex3_pipedown)
    fdsu_yy_rslt_denorm <= ex3_rslt_denorm;
  else
    fdsu_yy_rslt_denorm <= fdsu_yy_rslt_denorm;
end
// &Force("output", "fdsu_yy_rslt_denorm"); @440

// EX2 signal used in EX3 & EX4
always @ (posedge ex2_pipe_clk)
begin
  if (ex2_pipedown)
  begin
    fdsu_result_inf <= ex2_result_inf;
    fdsu_result_lfn <= ex2_result_lfn;
    fdsu_of         <= ex2_of;
    fdsu_uf         <= ex2_uf;
    fdsu_potnt_of   <= ex2_potnt_of;
    fdsu_potnt_uf   <= ex2_potnt_uf;
  end
  else
  begin
    fdsu_result_inf <= fdsu_result_inf;
    fdsu_result_lfn <= fdsu_result_lfn;
    fdsu_of         <= fdsu_of;
    fdsu_uf         <= fdsu_uf;
    fdsu_potnt_of   <= fdsu_potnt_of;
    fdsu_potnt_uf   <= fdsu_potnt_uf;
  end
end

//==========================================================
//                          Flush
//==========================================================
assign fdsu_flush = rtu_xx_ex1_cancel && ctrl_wb_idle
                 || rtu_xx_ex2_cancel && ctrl_wb_sm_ex2
                 || ctrl_xx_ex1_warm_up
                 || rtu_yy_xx_async_flush;

//==========================================================
//                           ICG
//==========================================================
assign fdsu_busy = fdsu_ex1_inst_vld
                || !ctrl_sm_idle
                || !ctrl_wb_sm_idle;
assign fdsu_clk_en = fdsu_busy
                  || !ctrl_sm_idle
                  || rtu_yy_xx_flush;
// &Instance("gated_clk_cell", "x_fdsu_clk"); @514
gated_clk_cell  x_fdsu_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (fdsu_clk          ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (fdsu_clk_en       ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect(.clk_in      (forever_cpuclk), @515
//          .external_en (1'b0), @516
//          .global_en   (cp0_yy_clk_en), @517
//          .module_en   (cp0_fpu_icg_en), @518
//          .local_en    (fdsu_clk_en), @519
//          .clk_out     (fdsu_clk)); @520

assign ex1_pipe_clk_en = ex1_pipedown_gate;
// &Instance("gated_clk_cell","x_ex1_pipe_clk"); @523
gated_clk_cell  x_ex1_pipe_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (ex1_pipe_clk      ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (ex1_pipe_clk_en   ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @524
//           .clk_out        (ex1_pipe_clk),//Out Clock @525
//           .external_en    (1'b0), @526
//           .global_en      (cp0_yy_clk_en), @527
//           .local_en       (ex1_pipe_clk_en),//Local Condition @528
//           .module_en      (cp0_fpu_icg_en) @529
//         ); @530

assign ex2_pipe_clk_en = ex2_pipedown;
// &Instance("gated_clk_cell","x_ex2_pipe_clk"); @533
gated_clk_cell  x_ex2_pipe_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (ex2_pipe_clk      ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (ex2_pipe_clk_en   ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @534
//           .clk_out        (ex2_pipe_clk),//Out Clock @535
//           .external_en    (1'b0), @536
//           .global_en      (cp0_yy_clk_en), @537
//           .local_en       (ex2_pipe_clk_en),//Local Condition @538
//           .module_en      (cp0_fpu_icg_en) @539
//         ); @540
// &Force("output", "ex2_pipe_clk"); @541

assign expnt_rst_clk_en = ex1_save_op0_gate
                       || ex1_pipedown_gate
                       || ex2_pipedown
                       || ex3_pipedown;
// &Instance("gated_clk_cell", "x_expnt_rst_clk"); @547
gated_clk_cell  x_expnt_rst_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (expnt_rst_clk     ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (expnt_rst_clk_en  ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect(.clk_in      (forever_cpuclk), @548
//          .external_en (1'b0), @549
//          .global_en   (cp0_yy_clk_en), @550
//          .module_en   (cp0_fpu_icg_en), @551
//          .local_en    (expnt_rst_clk_en), @552
//          .clk_out     (expnt_rst_clk)); @553

//==========================================================
//                      Output Signal
//==========================================================
assign fdsu_yy_wb_freg[4:0]    = fdsu_wb_freg[4:0];
assign fdsu_yy_result_sign     = fdsu_result_sign;
assign fdsu_yy_op0_norm        = fdsu_op0_norm;
assign fdsu_yy_op1_norm        = fdsu_op1_norm;
assign fdsu_yy_of_rm_lfn       = fdsu_of_rm_lfn;
assign fdsu_yy_div             = fdsu_div;
assign fdsu_yy_sqrt            = fdsu_sqrt;
assign fdsu_yy_rm[2:0]         = fdsu_rm[2:0];

assign fdsu_yy_expnt_rst[9:0] = fdsu_expnt_rst[9:0];
assign ex2_expnt_adder_op0[9:0] = fdsu_expnt_rst[9:0];

assign fdsu_yy_result_inf = fdsu_result_inf;
assign fdsu_yy_result_lfn = fdsu_result_lfn;
assign fdsu_yy_of         = fdsu_of;
assign fdsu_yy_uf         = fdsu_uf;
assign fdsu_yy_potnt_of   = fdsu_potnt_of;
assign fdsu_yy_potnt_uf   = fdsu_potnt_uf;

assign ex1_pipedown = ctrl_iter_start || ctrl_xx_ex1_warm_up;
assign ex1_pipedown_gate = ctrl_iter_start_gate || ctrl_xx_ex1_warm_up;
assign ex2_pipedown = ctrl_srt_itering && srt_last_round || ctrl_xx_ex2_warm_up;
assign ex3_pipedown = ctrl_round || ctrl_xx_ex3_warm_up;
// &Force("output", "ex1_pipedown"); @589
// &Force("output", "ex1_pipedown_gate"); @590
// &Force("output", "ex2_pipedown"); @591
// &Force("output", "ex3_pipedown"); @592

assign srt_sm_on = ctrl_srt_itering;

assign fdsu_fpu_ex1_cmplt = fdsu_ex1_inst_vld;
assign fdsu_fpu_ex1_cmplt_dp =  ctrl_xx_ex1_cmplt_dp && idu_fpu_ex1_eu_sel[2];
assign fdsu_fpu_ex1_stall = ctrl_fdsu_ex1_stall;
assign fdsu_frbus_wb_vld  = ctrl_result_vld;
// &Force("bus","idu_fpu_ex1_eu_sel",2,0); @600
assign fdsu_fpu_no_op = !fdsu_busy;
assign ex1_op1_sel = ctrl_wfi2;
assign ex1_save_op0 = ctrl_sm_start && ex1_op0_id && ex1_op1_id_vld;
assign ex1_save_op0_gate = ctrl_sm_start_gate && ex1_op0_id && ex1_op1_id_vld;
// &Force("output", "ex1_save_op0"); @605
// &Force("output", "ex1_save_op0_gate"); @606

assign fdsu_fpu_debug_info[4:0] = {wb_cur_state[1:0], fdsu_cur_state[2:0]};

// &ModuleEnd; @610
endmodule



// ----- 8< ----- FILE "./pa_fdsu_ff1.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_ff1(
  fanc_shift_num,
  frac_bin_val,
  frac_num
);

// &Ports; @24
input   [51:0]  frac_num;      
output  [51:0]  fanc_shift_num; 
output  [12:0]  frac_bin_val;  

// &Regs; @25
reg     [51:0]  fanc_shift_num; 
reg     [12:0]  frac_bin_val;  

// &Wires; @26
wire    [51:0]  frac_num;      


// &CombBeg; @28
always @( frac_num[51:0])
begin
casez(frac_num[51:0])
  52'b1???????????????????????????????????????????????????: frac_bin_val[12:0] = 13'h0;
  52'b01??????????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1fff;
  52'b001?????????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffe;
  52'b0001????????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffd;
  52'b00001???????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffc;
  52'b000001??????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffb;
  52'b0000001?????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffa;
  52'b00000001????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff9;
  52'b000000001???????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff8;
  52'b0000000001??????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff7;
  52'b00000000001?????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff6;
  52'b000000000001????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff5;
  52'b0000000000001???????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff4;
  52'b00000000000001??????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff3;
  52'b000000000000001?????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff2;
  52'b0000000000000001????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff1;
  52'b00000000000000001???????????????????????????????????: frac_bin_val[12:0] = 13'h1ff0;
  52'b000000000000000001??????????????????????????????????: frac_bin_val[12:0] = 13'h1fef;
  52'b0000000000000000001?????????????????????????????????: frac_bin_val[12:0] = 13'h1fee;
  52'b00000000000000000001????????????????????????????????: frac_bin_val[12:0] = 13'h1fed;
  52'b000000000000000000001???????????????????????????????: frac_bin_val[12:0] = 13'h1fec;
  52'b0000000000000000000001??????????????????????????????: frac_bin_val[12:0] = 13'h1feb;
  52'b00000000000000000000001?????????????????????????????: frac_bin_val[12:0] = 13'h1fea;
  52'b000000000000000000000001????????????????????????????: frac_bin_val[12:0] = 13'h1fe9;
  52'b0000000000000000000000001???????????????????????????: frac_bin_val[12:0] = 13'h1fe8;
  52'b00000000000000000000000001??????????????????????????: frac_bin_val[12:0] = 13'h1fe7;
  52'b000000000000000000000000001?????????????????????????: frac_bin_val[12:0] = 13'h1fe6;
  52'b0000000000000000000000000001????????????????????????: frac_bin_val[12:0] = 13'h1fe5;
  52'b00000000000000000000000000001???????????????????????: frac_bin_val[12:0] = 13'h1fe4;
  52'b000000000000000000000000000001??????????????????????: frac_bin_val[12:0] = 13'h1fe3;
  52'b0000000000000000000000000000001?????????????????????: frac_bin_val[12:0] = 13'h1fe2;
  52'b00000000000000000000000000000001????????????????????: frac_bin_val[12:0] = 13'h1fe1;
  52'b000000000000000000000000000000001???????????????????: frac_bin_val[12:0] = 13'h1fe0;
  52'b0000000000000000000000000000000001??????????????????: frac_bin_val[12:0] = 13'h1fdf;
  52'b00000000000000000000000000000000001?????????????????: frac_bin_val[12:0] = 13'h1fde;
  52'b000000000000000000000000000000000001????????????????: frac_bin_val[12:0] = 13'h1fdd;
  52'b0000000000000000000000000000000000001???????????????: frac_bin_val[12:0] = 13'h1fdc;
  52'b00000000000000000000000000000000000001??????????????: frac_bin_val[12:0] = 13'h1fdb;
  52'b000000000000000000000000000000000000001?????????????: frac_bin_val[12:0] = 13'h1fda;
  52'b0000000000000000000000000000000000000001????????????: frac_bin_val[12:0] = 13'h1fd9;
  52'b00000000000000000000000000000000000000001???????????: frac_bin_val[12:0] = 13'h1fd8;
  52'b000000000000000000000000000000000000000001??????????: frac_bin_val[12:0] = 13'h1fd7;
  52'b0000000000000000000000000000000000000000001?????????: frac_bin_val[12:0] = 13'h1fd6;
  52'b00000000000000000000000000000000000000000001????????: frac_bin_val[12:0] = 13'h1fd5;
  52'b000000000000000000000000000000000000000000001???????: frac_bin_val[12:0] = 13'h1fd4;
  52'b0000000000000000000000000000000000000000000001??????: frac_bin_val[12:0] = 13'h1fd3;
  52'b00000000000000000000000000000000000000000000001?????: frac_bin_val[12:0] = 13'h1fd2;
  52'b000000000000000000000000000000000000000000000001????: frac_bin_val[12:0] = 13'h1fd1;
  52'b0000000000000000000000000000000000000000000000001???: frac_bin_val[12:0] = 13'h1fd0;
  52'b00000000000000000000000000000000000000000000000001??: frac_bin_val[12:0] = 13'h1fcf;
  52'b000000000000000000000000000000000000000000000000001?: frac_bin_val[12:0] = 13'h1fce;
  52'b0000000000000000000000000000000000000000000000000001: frac_bin_val[12:0] = 13'h1fcd;
  52'b0000000000000000000000000000000000000000000000000000: frac_bin_val[12:0] = 13'h1fcc;
  default                                                 : frac_bin_val[12:0] = 13'h000;
endcase
// &CombEnd; @85
end

// &CombBeg; @87
always @( frac_num[51:0])
begin
casez(frac_num[51:0])
  52'b1???????????????????????????????????????????????????: fanc_shift_num[51:0] = frac_num[51:0];
  52'b01??????????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[50:0],1'b0};
  52'b001?????????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[49:0],2'b0};
  52'b0001????????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[48:0],3'b0};
  52'b00001???????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[47:0],4'b0};
  52'b000001??????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[46:0],5'b0};
  52'b0000001?????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[45:0],6'b0};
  52'b00000001????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[44:0],7'b0};
  52'b000000001???????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[43:0],8'b0};
  52'b0000000001??????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[42:0],9'b0};
  52'b00000000001?????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[41:0],10'b0};
  52'b000000000001????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[40:0],11'b0};
  52'b0000000000001???????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[39:0],12'b0};
  52'b00000000000001??????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[38:0],13'b0};
  52'b000000000000001?????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[37:0],14'b0};
  52'b0000000000000001????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[36:0],15'b0};
  52'b00000000000000001???????????????????????????????????: fanc_shift_num[51:0] = {frac_num[35:0],16'b0};
  52'b000000000000000001??????????????????????????????????: fanc_shift_num[51:0] = {frac_num[34:0],17'b0};
  52'b0000000000000000001?????????????????????????????????: fanc_shift_num[51:0] = {frac_num[33:0],18'b0};
  52'b00000000000000000001????????????????????????????????: fanc_shift_num[51:0] = {frac_num[32:0],19'b0};
  52'b000000000000000000001???????????????????????????????: fanc_shift_num[51:0] = {frac_num[31:0],20'b0};
  52'b0000000000000000000001??????????????????????????????: fanc_shift_num[51:0] = {frac_num[30:0],21'b0};
  52'b00000000000000000000001?????????????????????????????: fanc_shift_num[51:0] = {frac_num[29:0],22'b0};
  52'b000000000000000000000001????????????????????????????: fanc_shift_num[51:0] = {frac_num[28:0],23'b0};
  52'b0000000000000000000000001???????????????????????????: fanc_shift_num[51:0] = {frac_num[27:0],24'b0};
  52'b00000000000000000000000001??????????????????????????: fanc_shift_num[51:0] = {frac_num[26:0],25'b0};
  52'b000000000000000000000000001?????????????????????????: fanc_shift_num[51:0] = {frac_num[25:0],26'b0};
  52'b0000000000000000000000000001????????????????????????: fanc_shift_num[51:0] = {frac_num[24:0],27'b0};
  52'b00000000000000000000000000001???????????????????????: fanc_shift_num[51:0] = {frac_num[23:0],28'b0};
  52'b000000000000000000000000000001??????????????????????: fanc_shift_num[51:0] = {frac_num[22:0],29'b0};
  52'b0000000000000000000000000000001?????????????????????: fanc_shift_num[51:0] = {frac_num[21:0],30'b0};
  52'b00000000000000000000000000000001????????????????????: fanc_shift_num[51:0] = {frac_num[20:0],31'b0};
  52'b000000000000000000000000000000001???????????????????: fanc_shift_num[51:0] = {frac_num[19:0],32'b0};
  52'b0000000000000000000000000000000001??????????????????: fanc_shift_num[51:0] = {frac_num[18:0],33'b0};
  52'b00000000000000000000000000000000001?????????????????: fanc_shift_num[51:0] = {frac_num[17:0],34'b0};
  52'b000000000000000000000000000000000001????????????????: fanc_shift_num[51:0] = {frac_num[16:0],35'b0};
  52'b0000000000000000000000000000000000001???????????????: fanc_shift_num[51:0] = {frac_num[15:0],36'b0};
  52'b00000000000000000000000000000000000001??????????????: fanc_shift_num[51:0] = {frac_num[14:0],37'b0};
  52'b000000000000000000000000000000000000001?????????????: fanc_shift_num[51:0] = {frac_num[13:0],38'b0};
  52'b0000000000000000000000000000000000000001????????????: fanc_shift_num[51:0] = {frac_num[12:0],39'b0};
  52'b00000000000000000000000000000000000000001???????????: fanc_shift_num[51:0] = {frac_num[11:0],40'b0};
  52'b000000000000000000000000000000000000000001??????????: fanc_shift_num[51:0] = {frac_num[10:0],41'b0};
  52'b0000000000000000000000000000000000000000001?????????: fanc_shift_num[51:0] = {frac_num[9:0],42'b0};
  52'b00000000000000000000000000000000000000000001????????: fanc_shift_num[51:0] = {frac_num[8:0],43'b0};
  52'b000000000000000000000000000000000000000000001???????: fanc_shift_num[51:0] = {frac_num[7:0],44'b0};
  52'b0000000000000000000000000000000000000000000001??????: fanc_shift_num[51:0] = {frac_num[6:0],45'b0};
  52'b00000000000000000000000000000000000000000000001?????: fanc_shift_num[51:0] = {frac_num[5:0],46'b0};
  52'b000000000000000000000000000000000000000000000001????: fanc_shift_num[51:0] = {frac_num[4:0],47'b0};
  52'b0000000000000000000000000000000000000000000000001???: fanc_shift_num[51:0] = {frac_num[3:0],48'b0};
  52'b00000000000000000000000000000000000000000000000001??: fanc_shift_num[51:0] = {frac_num[2:0],49'b0};
  52'b000000000000000000000000000000000000000000000000001?: fanc_shift_num[51:0] = {frac_num[1:0],50'b0};
  52'b0000000000000000000000000000000000000000000000000001: fanc_shift_num[51:0] = {frac_num[0:0],51'b0};
  52'b0000000000000000000000000000000000000000000000000000: fanc_shift_num[51:0] = {52'b0};
  default                                                 : fanc_shift_num[51:0] = {52'b0};
endcase
// &CombEnd; @144
end

// &ModuleEnd; @146
endmodule


// ----- 8< ----- FILE "./pa_fdsu_pack_single.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_pack_single(
  fdsu_ex4_denorm_to_tiny_frac,
  fdsu_ex4_frac,
  fdsu_ex4_nx,
  fdsu_ex4_potnt_norm,
  fdsu_ex4_result_nor,
  fdsu_frbus_data,
  fdsu_frbus_fflags,
  fdsu_frbus_freg,
  fdsu_yy_expnt_rst,
  fdsu_yy_of,
  fdsu_yy_of_rm_lfn,
  fdsu_yy_potnt_of,
  fdsu_yy_potnt_uf,
  fdsu_yy_result_inf,
  fdsu_yy_result_lfn,
  fdsu_yy_result_sign,
  fdsu_yy_rslt_denorm,
  fdsu_yy_uf,
  fdsu_yy_wb_freg
);

// &Ports; @24
input           fdsu_ex4_denorm_to_tiny_frac; 
input   [25:0]  fdsu_ex4_frac;               
input           fdsu_ex4_nx;                 
input   [1 :0]  fdsu_ex4_potnt_norm;         
input           fdsu_ex4_result_nor;         
input   [9 :0]  fdsu_yy_expnt_rst;           
input           fdsu_yy_of;                  
input           fdsu_yy_of_rm_lfn;           
input           fdsu_yy_potnt_of;            
input           fdsu_yy_potnt_uf;            
input           fdsu_yy_result_inf;          
input           fdsu_yy_result_lfn;          
input           fdsu_yy_result_sign;         
input           fdsu_yy_rslt_denorm;         
input           fdsu_yy_uf;                  
input   [4 :0]  fdsu_yy_wb_freg;             
output  [31:0]  fdsu_frbus_data;             
output  [4 :0]  fdsu_frbus_fflags;           
output  [4 :0]  fdsu_frbus_freg;             

// &Regs; @25
reg     [22:0]  ex4_frac_23;                 
reg     [31:0]  ex4_result;                  
reg     [22:0]  ex4_single_denorm_frac;      
reg     [9 :0]  expnt_add_op1;               

// &Wires; @26
wire            ex4_cor_nx;                  
wire            ex4_cor_uf;                  
wire            ex4_denorm_potnt_norm;       
wire    [31:0]  ex4_denorm_result;           
wire    [9 :0]  ex4_expnt_rst;               
wire    [4 :0]  ex4_expt;                    
wire            ex4_final_rst_norm;          
wire    [25:0]  ex4_frac;                    
wire            ex4_of_plus;                 
wire            ex4_result_inf;              
wire            ex4_result_lfn;              
wire            ex4_rslt_denorm;             
wire    [31:0]  ex4_rst_inf;                 
wire    [31:0]  ex4_rst_lfn;                 
wire            ex4_rst_nor;                 
wire    [31:0]  ex4_rst_norm;                
wire            ex4_uf_plus;                 
wire            fdsu_ex4_denorm_to_tiny_frac; 
wire            fdsu_ex4_dz;                 
wire    [9 :0]  fdsu_ex4_expnt_rst;          
wire    [25:0]  fdsu_ex4_frac;               
wire            fdsu_ex4_nv;                 
wire            fdsu_ex4_nx;                 
wire            fdsu_ex4_of;                 
wire            fdsu_ex4_of_rst_lfn;         
wire    [1 :0]  fdsu_ex4_potnt_norm;         
wire            fdsu_ex4_potnt_of;           
wire            fdsu_ex4_potnt_uf;           
wire            fdsu_ex4_result_inf;         
wire            fdsu_ex4_result_lfn;         
wire            fdsu_ex4_result_nor;         
wire            fdsu_ex4_result_sign;        
wire            fdsu_ex4_rslt_denorm;        
wire            fdsu_ex4_uf;                 
wire    [31:0]  fdsu_frbus_data;             
wire    [4 :0]  fdsu_frbus_fflags;           
wire    [4 :0]  fdsu_frbus_freg;             
wire    [9 :0]  fdsu_yy_expnt_rst;           
wire            fdsu_yy_of;                  
wire            fdsu_yy_of_rm_lfn;           
wire            fdsu_yy_potnt_of;            
wire            fdsu_yy_potnt_uf;            
wire            fdsu_yy_result_inf;          
wire            fdsu_yy_result_lfn;          
wire            fdsu_yy_result_sign;         
wire            fdsu_yy_rslt_denorm;         
wire            fdsu_yy_uf;                  
wire    [4 :0]  fdsu_yy_wb_freg;             


assign fdsu_ex4_result_sign     = fdsu_yy_result_sign;
assign fdsu_ex4_of_rst_lfn      = fdsu_yy_of_rm_lfn;
assign fdsu_ex4_result_inf      = fdsu_yy_result_inf;
assign fdsu_ex4_result_lfn      = fdsu_yy_result_lfn;
assign fdsu_ex4_of              = fdsu_yy_of;
assign fdsu_ex4_uf              = fdsu_yy_uf;
assign fdsu_ex4_potnt_of        = fdsu_yy_potnt_of;
assign fdsu_ex4_potnt_uf        = fdsu_yy_potnt_uf;
assign fdsu_ex4_nv              = 1'b0;
assign fdsu_ex4_dz              = 1'b0;
assign fdsu_ex4_expnt_rst[9:0] = fdsu_yy_expnt_rst[9:0];
assign fdsu_ex4_rslt_denorm     = fdsu_yy_rslt_denorm;
//============================EX4 STAGE=====================
assign ex4_frac[25:0] = fdsu_ex4_frac[25:0];
//exponent adder
// &CombBeg; @43
always @( ex4_frac[25:24])
begin
casez(ex4_frac[25:24])
  2'b00   : expnt_add_op1[9:0] = 10'h1ff;  //the expnt sub 1
  2'b01   : expnt_add_op1[9:0] = 10'h0;    //the expnt stay the origi
  2'b1?   : expnt_add_op1[9:0] = 10'h1;    // the exptn add 1
  default : expnt_add_op1[9:0] = 10'b0;  
endcase
// &CombEnd; @50
end
assign ex4_expnt_rst[9:0] = fdsu_ex4_expnt_rst[9:0] + 
                             expnt_add_op1[9:0];

//==========================Result Pack=====================

// result denormal pack 
// shift to the denormal number
// &CombBeg; @58
always @( fdsu_ex4_expnt_rst[9:0]
       or fdsu_ex4_denorm_to_tiny_frac
       or ex4_frac[25:1])
begin
case(fdsu_ex4_expnt_rst[9:0])
  10'h1:   ex4_single_denorm_frac[22:0] = {      ex4_frac[23:1]}; //-1022 1
  10'h0:   ex4_single_denorm_frac[22:0] = {      ex4_frac[24:2]}; //-1023 0
  10'h3ff:ex4_single_denorm_frac[22:0] = {      ex4_frac[25:3]}; //-1024 -1
  10'h3fe:ex4_single_denorm_frac[22:0] = {1'b0, ex4_frac[25:4]}; //-1025 -2
  10'h3fd:ex4_single_denorm_frac[22:0] = {2'b0, ex4_frac[25:5]}; //-1026 -3
  10'h3fc:ex4_single_denorm_frac[22:0] = {3'b0, ex4_frac[25:6]}; //-1027 -4
  10'h3fb:ex4_single_denorm_frac[22:0] = {4'b0, ex4_frac[25:7]}; //-1028 -5
  10'h3fa:ex4_single_denorm_frac[22:0] = {5'b0, ex4_frac[25:8]}; //-1029 -6
  10'h3f9:ex4_single_denorm_frac[22:0] = {6'b0, ex4_frac[25:9]}; //-1030 -7
  10'h3f8:ex4_single_denorm_frac[22:0] = {7'b0, ex4_frac[25:10]}; //-1031 -8
  10'h3f7:ex4_single_denorm_frac[22:0] = {8'b0, ex4_frac[25:11]}; //-1032 -9
  10'h3f6:ex4_single_denorm_frac[22:0] = {9'b0, ex4_frac[25:12]}; //-1033 -10
  10'h3f5:ex4_single_denorm_frac[22:0] = {10'b0,ex4_frac[25:13]}; //-1034 -11
  10'h3f4:ex4_single_denorm_frac[22:0] = {11'b0,ex4_frac[25:14]}; //-1035 -12
  10'h3f3:ex4_single_denorm_frac[22:0] = {12'b0,ex4_frac[25:15]}; //-1036 -13  
  10'h3f2:ex4_single_denorm_frac[22:0] = {13'b0,ex4_frac[25:16]}; // -1037
  10'h3f1:ex4_single_denorm_frac[22:0] = {14'b0,ex4_frac[25:17]}; //-1038
  10'h3f0:ex4_single_denorm_frac[22:0] = {15'b0,ex4_frac[25:18]}; //-1039
  10'h3ef:ex4_single_denorm_frac[22:0] = {16'b0,ex4_frac[25:19]}; //-1040
  10'h3ee:ex4_single_denorm_frac[22:0] = {17'b0,ex4_frac[25:20]}; //-1041
  10'h3ed:ex4_single_denorm_frac[22:0] = {18'b0,ex4_frac[25:21]}; //-1042
  10'h3ec:ex4_single_denorm_frac[22:0] = {19'b0,ex4_frac[25:22]}; //-1043
  10'h3eb:ex4_single_denorm_frac[22:0] = {20'b0,ex4_frac[25:23]}; //-1044
  10'h3ea:ex4_single_denorm_frac[22:0] = {21'b0,ex4_frac[25:24]}; //-1044
  default :ex4_single_denorm_frac[22:0] = fdsu_ex4_denorm_to_tiny_frac ? 23'b1 : 23'b0; //-1045
endcase                                                                  
// &CombEnd; @86
end
//here when denormal number round to add1, it will become normal number
assign ex4_denorm_potnt_norm    = (fdsu_ex4_potnt_norm[1] && ex4_frac[24]) || 
                                  (fdsu_ex4_potnt_norm[0] && ex4_frac[25]) ;
assign ex4_rslt_denorm          = fdsu_ex4_rslt_denorm && !ex4_denorm_potnt_norm;
assign ex4_denorm_result[31:0]  = {fdsu_ex4_result_sign,
                                        8'h0,ex4_single_denorm_frac[22:0]};
                                   
                                                              
//ex4 overflow/underflow plus                                 
assign ex4_rst_nor = fdsu_ex4_result_nor;                    
assign ex4_of_plus = fdsu_ex4_potnt_of  && 
                     (|ex4_frac[25:24])  && 
                     ex4_rst_nor;
assign ex4_uf_plus = fdsu_ex4_potnt_uf  && 
                     (~|ex4_frac[25:24]) && 
                     ex4_rst_nor;
//ex4 overflow round result
assign ex4_result_lfn = (ex4_of_plus &&  fdsu_ex4_of_rst_lfn) ||
                        fdsu_ex4_result_lfn;
assign ex4_result_inf = (ex4_of_plus && !fdsu_ex4_of_rst_lfn) ||
                        fdsu_ex4_result_inf;
//Special Result Form
// result largest finity number
assign ex4_rst_lfn[31:0]      = {fdsu_ex4_result_sign,8'hfe,{23{1'b1}}};
//result infinity
assign ex4_rst_inf[31:0]  = {fdsu_ex4_result_sign,8'hff,23'b0};
//result normal
// &CombBeg; @114
always @( ex4_frac[25:0])
begin
casez(ex4_frac[25:24])
  2'b00   : ex4_frac_23[22:0]  = ex4_frac[22:0];
  2'b01   : ex4_frac_23[22:0]  = ex4_frac[23:1];
  2'b1?   : ex4_frac_23[22:0]  = ex4_frac[24:2];
  default : ex4_frac_23[22:0]  = 23'b0;
endcase
// &CombEnd; @121
end
assign ex4_rst_norm[31:0] = {fdsu_ex4_result_sign,
                                  ex4_expnt_rst[7:0],
                                  ex4_frac_23[22:0]};
assign ex4_cor_uf            = (fdsu_ex4_uf || ex4_denorm_potnt_norm || ex4_uf_plus)
                               && fdsu_ex4_nx;
assign ex4_cor_nx            =  fdsu_ex4_nx 
                                || fdsu_ex4_of 
                                || ex4_of_plus;
                                        
assign ex4_expt[4:0]           = {
                                  fdsu_ex4_nv,
                                  fdsu_ex4_dz,
                                  fdsu_ex4_of | ex4_of_plus,
                                  ex4_cor_uf,
                                  ex4_cor_nx};

assign ex4_final_rst_norm      = !ex4_result_inf        &&
                                 !ex4_result_lfn        && 
                                 !ex4_rslt_denorm; 
// &CombBeg; @141
always @( ex4_denorm_result[31:0]
       or ex4_result_lfn
       or ex4_result_inf
       or ex4_final_rst_norm
       or ex4_rst_norm[31:0]
       or ex4_rst_lfn[31:0]
       or ex4_rst_inf[31:0]
       or ex4_rslt_denorm)
begin
case({ex4_rslt_denorm,
      ex4_result_inf,
      ex4_result_lfn,
      ex4_final_rst_norm})
  4'b1000 : ex4_result[31:0]  = ex4_denorm_result[31:0];
  4'b0100 : ex4_result[31:0]  = ex4_rst_inf[31:0];
  4'b0010 : ex4_result[31:0]  = ex4_rst_lfn[31:0];
  4'b0001 : ex4_result[31:0]  = ex4_rst_norm[31:0];
  default   : ex4_result[31:0]  = 32'b0;
endcase
// &CombEnd; @152
end

//==========================================================
//                     Result Generate
//==========================================================
assign fdsu_frbus_freg[4:0]   = fdsu_yy_wb_freg[4:0];
assign fdsu_frbus_data[31:0]  = ex4_result[31:0];
assign fdsu_frbus_fflags[4:0] = ex4_expt[4:0];

// &ModuleEnd; @161
endmodule



// ----- 8< ----- FILE "./pa_fdsu_prepare.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_prepare(
  dp_xx_ex1_rm,
  ex1_div,
  ex1_divisor,
  ex1_expnt_adder_op0,
  ex1_expnt_adder_op1,
  ex1_of_result_lfn,
  ex1_op0_id,
  ex1_op0_sign,
  ex1_op1_id,
  ex1_op1_id_vld,
  ex1_op1_sel,
  ex1_oper_id_expnt,
  ex1_oper_id_expnt_f,
  ex1_oper_id_frac,
  ex1_oper_id_frac_f,
  ex1_remainder,
  ex1_result_sign,
  ex1_rm,
  ex1_sqrt,
  fdsu_ex1_sel,
  idu_fpu_ex1_func,
  idu_fpu_ex1_srcf0,
  idu_fpu_ex1_srcf1
);

// &Ports; @24
input   [2 :0]  dp_xx_ex1_rm;            
input           ex1_op0_id;              
input           ex1_op1_id;              
input           ex1_op1_sel;             
input   [12:0]  ex1_oper_id_expnt_f;     
input   [51:0]  ex1_oper_id_frac_f;      
input           fdsu_ex1_sel;            
input   [9 :0]  idu_fpu_ex1_func;        
input   [31:0]  idu_fpu_ex1_srcf0;       
input   [31:0]  idu_fpu_ex1_srcf1;       
output          ex1_div;                 
output  [23:0]  ex1_divisor;             
output  [12:0]  ex1_expnt_adder_op0;     
output  [12:0]  ex1_expnt_adder_op1;     
output          ex1_of_result_lfn;       
output          ex1_op0_sign;            
output          ex1_op1_id_vld;          
output  [12:0]  ex1_oper_id_expnt;       
output  [51:0]  ex1_oper_id_frac;        
output  [31:0]  ex1_remainder;           
output          ex1_result_sign;         
output  [2 :0]  ex1_rm;                  
output          ex1_sqrt;                

// &Regs; @25
reg     [12:0]  ex1_expnt_adder_op1;     
reg             ex1_of_result_lfn;       

// &Wires; @26
wire            div_sign;                
wire    [2 :0]  dp_xx_ex1_rm;            
wire            ex1_div;                 
wire    [52:0]  ex1_div_noid_nor_srt_op0; 
wire    [52:0]  ex1_div_noid_nor_srt_op1; 
wire    [52:0]  ex1_div_nor_srt_op0;     
wire    [52:0]  ex1_div_nor_srt_op1;     
wire    [12:0]  ex1_div_op0_expnt;       
wire    [12:0]  ex1_div_op1_expnt;       
wire    [52:0]  ex1_div_srt_op0;         
wire    [52:0]  ex1_div_srt_op1;         
wire    [23:0]  ex1_divisor;             
wire            ex1_double;              
wire    [12:0]  ex1_expnt_adder_op0;     
wire            ex1_op0_id;              
wire            ex1_op0_id_nor;          
wire            ex1_op0_sign;            
wire            ex1_op1_id;              
wire            ex1_op1_id_nor;          
wire            ex1_op1_id_vld;          
wire            ex1_op1_sel;             
wire            ex1_op1_sign;            
wire    [63:0]  ex1_oper0;               
wire    [51:0]  ex1_oper0_frac;          
wire    [12:0]  ex1_oper0_id_expnt;      
wire    [51:0]  ex1_oper0_id_frac;       
wire    [63:0]  ex1_oper1;               
wire    [51:0]  ex1_oper1_frac;          
wire    [12:0]  ex1_oper1_id_expnt;      
wire    [51:0]  ex1_oper1_id_frac;       
wire    [51:0]  ex1_oper_frac;           
wire    [12:0]  ex1_oper_id_expnt;       
wire    [12:0]  ex1_oper_id_expnt_f;     
wire    [51:0]  ex1_oper_id_frac;        
wire    [51:0]  ex1_oper_id_frac_f;      
wire    [31:0]  ex1_remainder;           
wire            ex1_result_sign;         
wire    [2 :0]  ex1_rm;                  
wire            ex1_single;              
wire            ex1_sqrt;                
wire            ex1_sqrt_expnt_odd;      
wire            ex1_sqrt_op0_expnt_0;    
wire    [12:0]  ex1_sqrt_op1_expnt;      
wire    [52:0]  ex1_sqrt_srt_op0;        
wire            fdsu_ex1_sel;            
wire    [9 :0]  idu_fpu_ex1_func;        
wire    [31:0]  idu_fpu_ex1_srcf0;       
wire    [31:0]  idu_fpu_ex1_srcf1;       
wire    [59:0]  sqrt_remainder;          
wire            sqrt_sign;               


assign ex1_sqrt                    = idu_fpu_ex1_func[0];
assign ex1_div                     = idu_fpu_ex1_func[1];
assign ex1_oper0[63:0]             = {32'b0, idu_fpu_ex1_srcf0[31:0] & {32{fdsu_ex1_sel}}};
assign ex1_oper1[63:0]             = {32'b0, idu_fpu_ex1_srcf1[31:0] & {32{fdsu_ex1_sel}}};
assign ex1_double                  = 1'b0;
assign ex1_single                  = 1'b1;
// &Force("bus", "idu_fpu_ex1_func", 9, 0); @43
assign ex1_op0_id_nor              = ex1_op0_id;
assign ex1_op1_id_nor              = ex1_op1_id;

//Sign bit prepare
assign ex1_op0_sign                = ex1_double && ex1_oper0[63]
                                  || ex1_single && ex1_oper0[31];
assign ex1_op1_sign                = ex1_double && ex1_oper1[63]
                                  || ex1_single && ex1_oper1[31];
assign div_sign                    = ex1_op0_sign ^ ex1_op1_sign;
assign sqrt_sign                   = ex1_op0_sign;
assign ex1_result_sign             = (ex1_div)
                                   ? div_sign
                                   : sqrt_sign;

//=====================find first one=======================
// this is for the denormal number
assign ex1_oper_frac[51:0] = ex1_op1_sel ? ex1_oper1_frac[51:0]
                                         : ex1_oper0_frac[51:0];

// &Instance("pa_fdsu_ff1", "x_frac_expnt"); @63
pa_fdsu_ff1  x_frac_expnt (
  .fanc_shift_num          (ex1_oper_id_frac[51:0] ),
  .frac_bin_val            (ex1_oper_id_expnt[12:0]),
  .frac_num                (ex1_oper_frac[51:0]    )
);

// &Connect(.frac_num(ex1_oper_frac[51:0])); @64
// &Connect(.frac_bin_val(ex1_oper_id_expnt[12:0])); @65
// &Connect(.fanc_shift_num(ex1_oper_id_frac[51:0])); @66
// &Force("output", "ex1_oper_id_expnt"); &Force("bus", "ex1_oper_id_expnt", 12, 0); @67
// &Force("output", "ex1_oper_id_frac"); &Force("bus", "ex1_oper_id_frac", 51, 0); @68

assign ex1_oper0_id_expnt[12:0] = ex1_op1_sel ? ex1_oper_id_expnt_f[12:0]
                                              : ex1_oper_id_expnt[12:0];
assign ex1_oper0_id_frac[51:0]  = ex1_op1_sel ? ex1_oper_id_frac_f[51:0]
                                              : ex1_oper_id_frac[51:0];
assign ex1_oper1_id_expnt[12:0] = ex1_oper_id_expnt[12:0];
assign ex1_oper1_id_frac[51:0]  = ex1_oper_id_frac[51:0];

assign ex1_oper0_frac[51:0] = {52{ex1_double}} & ex1_oper0[51:0]
                            | {52{ex1_single}} & {ex1_oper0[22:0],29'b0};
assign ex1_oper1_frac[51:0] = {52{ex1_double}} & ex1_oper1[51:0]
                            | {52{ex1_single}} & {ex1_oper1[22:0],29'b0};

//=====================exponent add=========================
//exponent number 0
assign ex1_div_op0_expnt[12:0]     = {13{ex1_double}} & {2'b0,ex1_oper0[62:52]}
                                   | {13{ex1_single}} & {5'b0,ex1_oper0[30:23]};
assign ex1_expnt_adder_op0[12:0]   = ex1_op0_id_nor ? ex1_oper0_id_expnt[12:0]
                                                : ex1_div_op0_expnt[12:0];
//exponent number 1
assign ex1_div_op1_expnt[12:0]  = {13{ex1_double}} & {2'b0,ex1_oper1[62:52]}
                                | {13{ex1_single}} & {5'b0,ex1_oper1[30:23]};
assign ex1_sqrt_op1_expnt[12:0] = {13{ex1_double}} & {3'b0,{10{1'b1}}} //'d1023
                                | {13{ex1_single}} & {6'b0,{7{1'b1}}}; //'d127
// &CombBeg; @93
always @( ex1_oper1_id_expnt[12:0]
       or ex1_div
       or ex1_op1_id_nor
       or ex1_sqrt_op1_expnt[12:0]
       or ex1_sqrt
       or ex1_div_op1_expnt[12:0])
begin
case({ex1_div,ex1_sqrt})
  2'b10:   ex1_expnt_adder_op1[12:0] = ex1_op1_id_nor ? ex1_oper1_id_expnt[12:0]
                                                  : ex1_div_op1_expnt[12:0];
  2'b01:   ex1_expnt_adder_op1[12:0] = ex1_sqrt_op1_expnt[12:0];
  default: ex1_expnt_adder_op1[12:0] = 13'b0;
endcase
// &CombEnd; @100
end

//ex1_sqrt_expnt_odd
//fraction will shift left by 1
// adder_op0/1 timing is bad.
// assign ex1_sqrt_expnt_odd          = ex1_expnt_adder_op0[0] ^ ex1_expnt_adder_op1[0];

// sqrt_odd is only used when is sqrt.
assign ex1_sqrt_op0_expnt_0        = ex1_op0_id_nor ? ex1_oper_id_expnt[0]
                                                    : ex1_div_op0_expnt[0];
// ex1_expnt_adder_op1 is always 1'b1, so adder_op0[0] should be 0.
assign ex1_sqrt_expnt_odd          = !ex1_sqrt_op0_expnt_0;

assign ex1_rm[2:0]       = dp_xx_ex1_rm[2:0];
//RNE : Always inc 1 because round to nearest of 1.111...11
//RTZ : Always not inc 1
//RUP : Always not inc 1 when posetive
//RDN : Always not inc 1 when negative
//RMM : Always inc 1 because round to max magnitude
// &CombBeg; @119
always @( ex1_rm[2:0]
       or ex1_result_sign)
begin
case(ex1_rm[2:0])
  3'b000  : ex1_of_result_lfn = 1'b0;
  3'b001  : ex1_of_result_lfn = 1'b1;
  3'b010  : ex1_of_result_lfn = !ex1_result_sign;
  3'b011  : ex1_of_result_lfn = ex1_result_sign;
  3'b100  : ex1_of_result_lfn = 1'b0;
  default: ex1_of_result_lfn = 1'b0;
endcase
// &CombEnd; @128
end

//EX1 Remainder
//div  : 1/8  <= x < 1/4
//sqrt : 1/16 <= x < 1/4
assign ex1_remainder[31:0] = {32{ex1_div }} & {5'b0,ex1_div_srt_op0[52:28],2'b0} |
                             {32{ex1_sqrt}} & sqrt_remainder[59:28];

//EX1 Divisor
//1/2 <= y < 1
assign ex1_divisor[23:0]   = ex1_div_srt_op1[52:29];

//ex1_div_srt_op0
assign ex1_div_srt_op0[52:0]     = ex1_div_nor_srt_op0[52:0];
//ex1_div_srt_op1
assign ex1_div_srt_op1[52:0]     =  ex1_div_nor_srt_op1[52:0];
//ex1_div_nor_srt_op0
assign ex1_div_noid_nor_srt_op0[52:0] = {53{ex1_double}} & {1'b1,ex1_oper0[51:0]}
                                      | {53{ex1_single}} & {1'b1,ex1_oper0[22:0],29'b0};
assign ex1_div_nor_srt_op0[52:0] = ex1_op0_id_nor ? {ex1_oper0_id_frac[51:0],1'b0}
                                                  : ex1_div_noid_nor_srt_op0[52:0];
//ex1_div_nor_srt_op1
assign ex1_div_noid_nor_srt_op1[52:0] = {53{ex1_double}} & {1'b1,ex1_oper1[51:0]}
                                      | {53{ex1_single}} & {1'b1,ex1_oper1[22:0],29'b0};
assign ex1_div_nor_srt_op1[52:0] = ex1_op1_id_nor ? {ex1_oper1_id_frac[51:0],1'b0}
                                                  : ex1_div_noid_nor_srt_op1[52:0];
//sqrt_remainder
assign sqrt_remainder[59:0]      = (ex1_sqrt_expnt_odd)
                                 ? {5'b0,ex1_sqrt_srt_op0[52:0],2'b0}
                                 : {6'b0,ex1_sqrt_srt_op0[52:0],1'b0};
//ex1_sqrt_srt_op0
assign ex1_sqrt_srt_op0[52:0]    = ex1_div_srt_op0[52:0];

//========================Pipe to EX2=======================
//exponent register cal result
// &Force("output", "ex1_expnt_adder_op0"); &Force("bus", "ex1_expnt_adder_op0", 12, 0); @173
// &Force("output", "ex1_expnt_adder_op1"); &Force("bus", "ex1_expnt_adder_op1", 12, 0); @174
// &Force("output", "ex1_double"); @175
// &Force("output", "ex1_expnt_adder_op0"); &Force("bus", "ex1_expnt_adder_op0", 12, 0); @177
// &Force("output", "ex1_expnt_adder_op1"); &Force("bus", "ex1_expnt_adder_op1", 12, 0); @178
// &Force("output", "ex1_result_sign"); @180
// &Force("output", "ex1_div"); @181
// &Force("output", "ex1_sqrt"); @182
// &Force("output", "ex1_rm"); &Force("bus", "ex1_rm", 2, 0); @183
// &Force("output", "ex1_op0_sign"); @184

assign ex1_op1_id_vld = ex1_op1_id_nor && ex1_div;

// &ModuleEnd; @188
endmodule



// ----- 8< ----- FILE "./pa_fdsu_round_single.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_round_single(
  cp0_fpu_icg_en,
  cp0_yy_clk_en,
  ex3_expnt_adjust_result,
  ex3_frac_final_rst,
  ex3_pipedown,
  ex3_rslt_denorm,
  fdsu_ex3_id_srt_skip,
  fdsu_ex3_rem_sign,
  fdsu_ex3_rem_zero,
  fdsu_ex3_result_denorm_round_add_num,
  fdsu_ex4_denorm_to_tiny_frac,
  fdsu_ex4_nx,
  fdsu_ex4_potnt_norm,
  fdsu_ex4_result_nor,
  fdsu_yy_expnt_rst,
  fdsu_yy_result_inf,
  fdsu_yy_result_lfn,
  fdsu_yy_result_sign,
  fdsu_yy_rm,
  fdsu_yy_rslt_denorm,
  forever_cpuclk,
  pad_yy_icg_scan_en,
  total_qt_rt_30
);

// &Ports; @24
input           cp0_fpu_icg_en;                      
input           cp0_yy_clk_en;                       
input           ex3_pipedown;                        
input           fdsu_ex3_id_srt_skip;                
input           fdsu_ex3_rem_sign;                   
input           fdsu_ex3_rem_zero;                   
input   [23:0]  fdsu_ex3_result_denorm_round_add_num; 
input   [9 :0]  fdsu_yy_expnt_rst;                   
input           fdsu_yy_result_inf;                  
input           fdsu_yy_result_lfn;                  
input           fdsu_yy_result_sign;                 
input   [2 :0]  fdsu_yy_rm;                          
input           fdsu_yy_rslt_denorm;                 
input           forever_cpuclk;                      
input           pad_yy_icg_scan_en;                  
input   [29:0]  total_qt_rt_30;                      
output  [9 :0]  ex3_expnt_adjust_result;             
output  [25:0]  ex3_frac_final_rst;                  
output          ex3_rslt_denorm;                     
output          fdsu_ex4_denorm_to_tiny_frac;        
output          fdsu_ex4_nx;                         
output  [1 :0]  fdsu_ex4_potnt_norm;                 
output          fdsu_ex4_result_nor;                 

// &Regs; @25
reg             denorm_to_tiny_frac;                 
reg             fdsu_ex4_denorm_to_tiny_frac;        
reg             fdsu_ex4_nx;                         
reg     [1 :0]  fdsu_ex4_potnt_norm;                 
reg             fdsu_ex4_result_nor;                 
reg     [25:0]  frac_add1_op1;                       
reg             frac_add_1;                          
reg             frac_orig;                           
reg     [25:0]  frac_sub1_op1;                       
reg             frac_sub_1;                          
reg     [27:0]  qt_result_single_denorm_for_round;   
reg             single_denorm_lst_frac;              

// &Wires; @26
wire            cp0_fpu_icg_en;                      
wire            cp0_yy_clk_en;                       
wire            ex3_denorm_eq;                       
wire            ex3_denorm_gr;                       
wire            ex3_denorm_lst_frac;                 
wire            ex3_denorm_nx;                       
wire            ex3_denorm_plus;                     
wire            ex3_denorm_potnt_norm;               
wire            ex3_denorm_zero;                     
wire    [9 :0]  ex3_expnt_adjst;                     
wire    [9 :0]  ex3_expnt_adjust_result;             
wire    [25:0]  ex3_frac_final_rst;                  
wire            ex3_nx;                              
wire            ex3_pipe_clk;                        
wire            ex3_pipe_clk_en;                     
wire            ex3_pipedown;                        
wire    [1 :0]  ex3_potnt_norm;                      
wire            ex3_qt_eq;                           
wire            ex3_qt_gr;                           
wire            ex3_qt_sing_lo3_not0;                
wire            ex3_qt_sing_lo4_not0;                
wire            ex3_qt_zero;                         
wire            ex3_rslt_denorm;                     
wire            ex3_rst_eq_1;                        
wire            ex3_rst_nor;                         
wire            ex3_single_denorm_eq;                
wire            ex3_single_denorm_gr;                
wire            ex3_single_denorm_zero;              
wire            ex3_single_low_not_zero;             
wire    [9 :0]  fdsu_ex3_expnt_rst;                  
wire            fdsu_ex3_id_srt_skip;                
wire            fdsu_ex3_rem_sign;                   
wire            fdsu_ex3_rem_zero;                   
wire    [23:0]  fdsu_ex3_result_denorm_round_add_num; 
wire            fdsu_ex3_result_inf;                 
wire            fdsu_ex3_result_lfn;                 
wire            fdsu_ex3_result_sign;                
wire    [2 :0]  fdsu_ex3_rm;                         
wire            fdsu_ex3_rslt_denorm;                
wire    [9 :0]  fdsu_yy_expnt_rst;                   
wire            fdsu_yy_result_inf;                  
wire            fdsu_yy_result_lfn;                  
wire            fdsu_yy_result_sign;                 
wire    [2 :0]  fdsu_yy_rm;                          
wire            fdsu_yy_rslt_denorm;                 
wire            forever_cpuclk;                      
wire    [25:0]  frac_add1_op1_with_denorm;           
wire    [25:0]  frac_add1_rst;                       
wire            frac_denorm_rdn_add_1;               
wire            frac_denorm_rdn_sub_1;               
wire            frac_denorm_rmm_add_1;               
wire            frac_denorm_rne_add_1;               
wire            frac_denorm_rtz_sub_1;               
wire            frac_denorm_rup_add_1;               
wire            frac_denorm_rup_sub_1;               
wire    [25:0]  frac_final_rst;                      
wire            frac_rdn_add_1;                      
wire            frac_rdn_sub_1;                      
wire            frac_rmm_add_1;                      
wire            frac_rne_add_1;                      
wire            frac_rtz_sub_1;                      
wire            frac_rup_add_1;                      
wire            frac_rup_sub_1;                      
wire    [25:0]  frac_sub1_op1_with_denorm;           
wire    [25:0]  frac_sub1_rst;                       
wire            pad_yy_icg_scan_en;                  
wire    [29:0]  total_qt_rt_30;                      


assign fdsu_ex3_result_sign     = fdsu_yy_result_sign;
assign fdsu_ex3_expnt_rst[9:0]  = fdsu_yy_expnt_rst[9:0];
assign fdsu_ex3_result_inf      = fdsu_yy_result_inf;
assign fdsu_ex3_result_lfn      = fdsu_yy_result_lfn;
assign fdsu_ex3_rm[2:0]         = fdsu_yy_rm[2:0];
assign fdsu_ex3_rslt_denorm     = fdsu_yy_rslt_denorm;
//=======================Round Rule=========================
//1/8 <= x < 1/4, 1/2 <= y < 1, => 1/8 < z < 1/2
//q[29:0] represent the fraction part result of quotient, q[29] for 1/2
//Thus the first "1" in 30 bit quotient will be in q[28] or q[27]
//For Single Float
//15 round to get 30 bit quotient, 23+1 bit as valid result, other for round
//if q[28] is 1, q[28:5] as 1.xxxx valid result, [4:0] for round
//if q[28] is 0, q[27:4] as 1.xxxx valid result, [3:0] for round
// &Force("bus","total_qt_rt_30",29,0); @42
assign ex3_qt_sing_lo4_not0 = |total_qt_rt_30[3:0];
assign ex3_qt_sing_lo3_not0 = |total_qt_rt_30[2:0];
//the quotient round bits great than "10000"(ronnd bits 10..0)
assign ex3_qt_gr          = (total_qt_rt_30[28])
                            ?  total_qt_rt_30[4] && ex3_qt_sing_lo4_not0
                            :  total_qt_rt_30[3] && ex3_qt_sing_lo3_not0;

//the quotient round bits is equal to "10000"(ronnd bits 10..0)
assign ex3_qt_eq          = (total_qt_rt_30[28])
                            ?  total_qt_rt_30[4] && !ex3_qt_sing_lo4_not0
                            :  total_qt_rt_30[3] && !ex3_qt_sing_lo3_not0;
//the quotient round bits is zero
assign ex3_qt_zero        = (total_qt_rt_30[28])
                            ? ~|total_qt_rt_30[4:0]
                            : ~|total_qt_rt_30[3:0];
//quotient is 1.00000..00 need special dealt with in the following
assign ex3_rst_eq_1    = total_qt_rt_30[28] && ~|total_qt_rt_30[27:5];
// for denormal result, first select the quotation num for rounding
//  specially for the result e=-126 and e=-1022,the denorm depends on the
//  MSB of the quotient
assign ex3_denorm_plus       = !total_qt_rt_30[28] && (fdsu_ex3_expnt_rst[9:0] == 10'h382);
assign ex3_denorm_potnt_norm = total_qt_rt_30[28] && (fdsu_ex3_expnt_rst[9:0] == 10'h381);
assign ex3_rslt_denorm            = ex3_denorm_plus || fdsu_ex3_rslt_denorm;
// &Force("output", "ex3_rslt_denorm"); @66

//denomal result, check for rounding further optimization can be done in
//future
// &CombBeg; @70
always @( total_qt_rt_30[28:0]
       or fdsu_ex3_expnt_rst[9:0])
begin
case(fdsu_ex3_expnt_rst[9:0])
  10'h382:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[4:0],23'b0}; //-126 1
                single_denorm_lst_frac =  total_qt_rt_30[5];
			 		end//-1022 1
  10'h381:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[5:0],22'b0}; //-127 0
                single_denorm_lst_frac =  total_qt_rt_30[6];
			 		end//-1022 1
  10'h380:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[6:0],21'b0}; //-128 -1
                single_denorm_lst_frac =  total_qt_rt_30[7];
			 		end//-1022 1
  10'h37f:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[7:0],20'b0}; //-129 -2
                single_denorm_lst_frac =  total_qt_rt_30[8];
			 		end//-1022 1
  10'h37e:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[8:0],19'b0}; //-130 -3
                single_denorm_lst_frac =  total_qt_rt_30[9];
			 		end//-1022 1
  10'h37d:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[9:0],18'b0}; //-131 -4
                single_denorm_lst_frac =  total_qt_rt_30[10];
			 		end//-1022 1
  10'h37c:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[10:0],17'b0}; //-132 -5
                single_denorm_lst_frac =  total_qt_rt_30[11];
			 		end//-1022 1
  10'h37b:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[11:0],16'b0}; //-133 -6
                single_denorm_lst_frac =  total_qt_rt_30[12];
			 		end//-1022 1
  10'h37a:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[12:0],15'b0}; //-134 -7
                single_denorm_lst_frac =  total_qt_rt_30[13];
			 		end//-1022 1
  10'h379:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[13:0],14'b0}; //-135 -8
                single_denorm_lst_frac =  total_qt_rt_30[14];
			 		end//-1022 1
  10'h378:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[14:0],13'b0}; //-136 -9
                single_denorm_lst_frac =  total_qt_rt_30[15];
			 		end//-1022 1
  10'h377:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[15:0],12'b0}; //-137 -10
                single_denorm_lst_frac =  total_qt_rt_30[16];
			 		end//-1022 1
  10'h376:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[16:0],11'b0}; //-138 -11
                single_denorm_lst_frac =  total_qt_rt_30[17];
			 		end//-1022 1
  10'h375:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[17:0],10'b0}; //-139 -12
                single_denorm_lst_frac =  total_qt_rt_30[18];
			 		end//-1022 1
  10'h374:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[18:0],9'b0}; //-140 -13
                single_denorm_lst_frac =  total_qt_rt_30[19];
			 		end//-1022 1
  10'h373:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[19:0],8'b0}; // -141
                single_denorm_lst_frac =  total_qt_rt_30[20];
			 		end//-1022 1
  10'h372:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[20:0],7'b0};//-142
                single_denorm_lst_frac =  total_qt_rt_30[21];
			 		end//-1022 1
  10'h371:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[21:0],6'b0};//-143
                single_denorm_lst_frac =  total_qt_rt_30[22];
			 		end//-1022 1
  10'h370:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[22:0],5'b0}; //-144
                single_denorm_lst_frac =  total_qt_rt_30[23];
			 		end//-1022 1
  10'h36f:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[23:0],4'b0}; //-145
                single_denorm_lst_frac =  total_qt_rt_30[24];
			 		end//-1022 1
  10'h36e:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[24:0],3'b0}; //-146
                single_denorm_lst_frac =  total_qt_rt_30[25];
			 		end//-1022 1
  10'h36d:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[25:0],2'b0}; //-147
                single_denorm_lst_frac =  total_qt_rt_30[26];
			 		end//-1022 1
  10'h36c:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[26:0],1'b0}; //-148
                single_denorm_lst_frac =  total_qt_rt_30[27];
			 		end//-1022 1
  10'h36b: begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[27:0]};
                 single_denorm_lst_frac = total_qt_rt_30[28] ;
						end//-1022 1
  default:  begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[28:1]};
                 single_denorm_lst_frac = 1'b0;
						end//-1022 1
endcase
// &CombEnd; @148
end
//rounding evaluation for single denormalize number
assign ex3_single_denorm_eq      = qt_result_single_denorm_for_round[27]
                                   &&  !ex3_single_low_not_zero;
assign ex3_single_low_not_zero   = |qt_result_single_denorm_for_round[26:0];
assign ex3_single_denorm_gr      = qt_result_single_denorm_for_round[27]
                                   &&  ex3_single_low_not_zero;
assign ex3_single_denorm_zero    = !qt_result_single_denorm_for_round[27]
                                   && !ex3_single_low_not_zero;

//rounding check fo denormalize result
assign ex3_denorm_eq             = ex3_single_denorm_eq;
assign ex3_denorm_gr             = ex3_single_denorm_gr;
assign ex3_denorm_zero           = ex3_single_denorm_zero;
assign ex3_denorm_lst_frac       = single_denorm_lst_frac;
//Different Round Mode with different rounding rule
//Here we call rounding bit as "rb", remainder as "rem"
//RNE :
//  1.+1 : rb>10000 || rb==10000 && rem>0
//  2. 0 : Rest Condition
//  3.-1 : Never occur
//RTZ :
//  1.+1 : Never occur
//  2. 0 : Rest Condition
//  3.-1 : rb=10000 && rem<0
//RDN :
//  1.+1 : Q>0 Never occur   ; Q<0 Rest condition
//  2. 0 : Q>0 Rest condition; Q<0 Rem<0 && rb=0
//  3.-1 : Q>0 Rem<0 && rb=0 ; Q<0 Never occur
//RUP :
//  1.+1 : Q>0 Rest Condition; Q<0 Never occur
//  2. 0 : Q>0 Rem<0 && rb=0 ; Q<0 Rest condition
//  3.-1 : Q>0 Never occur   ; Q<0 Rem<0 && rb=0
//RMM :
//  1.+1 : rb>10000 || rb==10000 && rem>0
//  2. 0 : Rest Condition
//  3.-1 : Never occur
assign frac_rne_add_1 = ex3_qt_gr ||
                       (ex3_qt_eq && !fdsu_ex3_rem_sign);
assign frac_rtz_sub_1 = ex3_qt_zero && fdsu_ex3_rem_sign;
assign frac_rup_add_1 = !fdsu_ex3_result_sign &&
                       (!ex3_qt_zero ||
                       (!fdsu_ex3_rem_sign && !fdsu_ex3_rem_zero));
assign frac_rup_sub_1 = fdsu_ex3_result_sign &&
                       (ex3_qt_zero && fdsu_ex3_rem_sign);
assign frac_rdn_add_1 = fdsu_ex3_result_sign &&
                       (!ex3_qt_zero ||
                       (!fdsu_ex3_rem_sign && !fdsu_ex3_rem_zero));
assign frac_rdn_sub_1 = !fdsu_ex3_result_sign &&
                       (ex3_qt_zero && fdsu_ex3_rem_sign);
assign frac_rmm_add_1 = ex3_qt_gr ||
                       (ex3_qt_eq && !fdsu_ex3_rem_sign);
//denormal result
assign frac_denorm_rne_add_1 = ex3_denorm_gr ||
                               (ex3_denorm_eq &&
                               ((fdsu_ex3_rem_zero &&
                                ex3_denorm_lst_frac) ||
                               (!fdsu_ex3_rem_zero &&
                                !fdsu_ex3_rem_sign)));
assign frac_denorm_rtz_sub_1 = ex3_denorm_zero && fdsu_ex3_rem_sign;
assign frac_denorm_rup_add_1 = !fdsu_ex3_result_sign &&
                               (!ex3_denorm_zero ||
                               (!fdsu_ex3_rem_sign && !fdsu_ex3_rem_zero));
assign frac_denorm_rup_sub_1 = fdsu_ex3_result_sign &&
                       (ex3_denorm_zero && fdsu_ex3_rem_sign);
assign frac_denorm_rdn_add_1 = fdsu_ex3_result_sign &&
                       (!ex3_denorm_zero ||
                       (!fdsu_ex3_rem_sign && !fdsu_ex3_rem_zero));
assign frac_denorm_rdn_sub_1 = !fdsu_ex3_result_sign &&
                       (ex3_denorm_zero && fdsu_ex3_rem_sign);
assign frac_denorm_rmm_add_1 = ex3_denorm_gr ||
                       (ex3_denorm_eq && !fdsu_ex3_rem_sign);

//RM select
// &CombBeg; @222
always @( fdsu_ex3_rm[2:0]
       or frac_denorm_rdn_add_1
       or frac_rne_add_1
       or frac_denorm_rdn_sub_1
       or fdsu_ex3_result_sign
       or frac_rup_add_1
       or frac_denorm_rup_sub_1
       or frac_rdn_sub_1
       or frac_rtz_sub_1
       or frac_rdn_add_1
       or fdsu_ex3_id_srt_skip
       or frac_denorm_rtz_sub_1
       or ex3_rslt_denorm
       or frac_rup_sub_1
       or frac_denorm_rmm_add_1
       or frac_denorm_rup_add_1
       or frac_denorm_rne_add_1
       or frac_rmm_add_1)
begin
case(fdsu_ex3_rm[2:0])
  3'b000://round to nearst,ties to even
  begin
    frac_add_1          =  ex3_rslt_denorm ? frac_denorm_rne_add_1 : frac_rne_add_1;
    frac_sub_1          =  1'b0;
    frac_orig           =  ex3_rslt_denorm ? !frac_denorm_rne_add_1 : !frac_rne_add_1;
    denorm_to_tiny_frac =  fdsu_ex3_id_srt_skip ? 1'b0 : frac_denorm_rne_add_1;
  end
  3'b001:// round to 0
  begin
    frac_add_1           =  1'b0;
    frac_sub_1           =  ex3_rslt_denorm ? frac_denorm_rtz_sub_1 : frac_rtz_sub_1;
    frac_orig            =  ex3_rslt_denorm ? !frac_denorm_rtz_sub_1 : !frac_rtz_sub_1;
    denorm_to_tiny_frac  = 1'b0;
  end
  3'b010://round to -inf
  begin
    frac_add_1          =  ex3_rslt_denorm ? frac_denorm_rdn_add_1 : frac_rdn_add_1;
    frac_sub_1          =  ex3_rslt_denorm ? frac_denorm_rdn_sub_1 : frac_rdn_sub_1;
    frac_orig           =  ex3_rslt_denorm ? !frac_denorm_rdn_add_1 && !frac_denorm_rdn_sub_1
                                           : !frac_rdn_add_1 && !frac_rdn_sub_1;
    denorm_to_tiny_frac = fdsu_ex3_id_srt_skip ? fdsu_ex3_result_sign
                                                : frac_denorm_rdn_add_1;
  end
  3'b011://round to +inf
  begin
    frac_add_1          =  ex3_rslt_denorm ? frac_denorm_rup_add_1 : frac_rup_add_1;
    frac_sub_1          =  ex3_rslt_denorm ? frac_denorm_rup_sub_1 : frac_rup_sub_1;
    frac_orig           =  ex3_rslt_denorm ? !frac_denorm_rup_add_1 && !frac_denorm_rup_sub_1
                                           : !frac_rup_add_1 && !frac_rup_sub_1;
    denorm_to_tiny_frac = fdsu_ex3_id_srt_skip ? !fdsu_ex3_result_sign
                                                : frac_denorm_rup_add_1;
  end
  3'b100://round to nearest,ties to max magnitude
  begin
    frac_add_1          = ex3_rslt_denorm ? frac_denorm_rmm_add_1 : frac_rmm_add_1;
    frac_sub_1          = 1'b0;
    frac_orig           = ex3_rslt_denorm ? !frac_denorm_rmm_add_1 : !frac_rmm_add_1;
    denorm_to_tiny_frac = fdsu_ex3_id_srt_skip ? 1'b0 : frac_denorm_rmm_add_1;
  end
  default:
  begin
    frac_add_1          = 1'b0;
    frac_sub_1          = 1'b0;
    frac_orig           = 1'b0;
    denorm_to_tiny_frac = 1'b0;
  end
endcase
// &CombEnd; @271
end
//Add 1 or Sub 1 constant
// &CombBeg; @273
always @( total_qt_rt_30[28])
begin
case(total_qt_rt_30[28])
  1'b0:
  begin
    frac_add1_op1[25:0] = {2'b0,24'b1};
    frac_sub1_op1[25:0] = {2'b11,{24{1'b1}}};
  end
  1'b1:
  begin
    frac_add1_op1[25:0] = {25'b1,1'b0};
    frac_sub1_op1[25:0] = {{25{1'b1}},1'b0};
  end
  default:
  begin
    frac_add1_op1[25:0] = 26'b0;
    frac_sub1_op1[25:0] = 26'b0;
  end
endcase
// &CombEnd; @291
end

//Add 1 or Sub1 final result
//Conner case when quotient is 0.010000...00 and remainder is negative,
//The real quotient is actually 0.00fff..ff,
//The final result will need to sub 1 when
//RN : Never occur
//RP : sign of quotient is -
//RM : sign of quotient is +
assign frac_add1_rst[25:0]             = {1'b0,total_qt_rt_30[28:4]} +
                                         frac_add1_op1_with_denorm[25:0];
assign frac_add1_op1_with_denorm[25:0] = ex3_rslt_denorm ?
                                  {1'b0,fdsu_ex3_result_denorm_round_add_num[23:0],1'b0} :
                                  frac_add1_op1[25:0];
assign frac_sub1_rst[25:0]             = (ex3_rst_eq_1)
                                       ? {3'b0,{23{1'b1}}}
                                       : {1'b0,total_qt_rt_30[28:4]} +
                                         frac_sub1_op1_with_denorm[25:0] + {25'b0, ex3_rslt_denorm};
assign frac_sub1_op1_with_denorm[25:0] = ex3_rslt_denorm ?
                                ~{1'b0,fdsu_ex3_result_denorm_round_add_num[23:0],1'b0} :
                                frac_sub1_op1[25:0];
assign frac_final_rst[25:0]           = (frac_add1_rst[25:0]         & {26{frac_add_1}}) |
                                        (frac_sub1_rst[25:0]         & {26{frac_sub_1}}) |
                                        ({1'b0,total_qt_rt_30[28:4]} & {26{frac_orig}});

//===============Pipe down signal prepare===================
// assign ex3_rst_nor = !fdsu_ex3_result_zero &&
//                      !fdsu_ex3_result_qnan &&
//                      !fdsu_ex3_result_inf  &&
//                      !fdsu_ex3_result_lfn;
assign ex3_rst_nor = !fdsu_ex3_result_inf  &&
                     !fdsu_ex3_result_lfn;
assign ex3_nx      = ex3_rst_nor &&
                    (!ex3_qt_zero || !fdsu_ex3_rem_zero || ex3_denorm_nx);
assign ex3_denorm_nx = ex3_rslt_denorm && (!ex3_denorm_zero ||  !fdsu_ex3_rem_zero);
//Adjust expnt
//Div:Actural expnt should plus 1 when op0 is id, sub 1 when op1 id
assign ex3_expnt_adjst[9:0] = 10'h7f;

assign ex3_expnt_adjust_result[9:0] = fdsu_ex3_expnt_rst[9:0] +
                                       ex3_expnt_adjst[9:0];
//this information is for the packing, which determin the result is normal
//numer or not;
assign ex3_potnt_norm[1:0]    = {ex3_denorm_plus,ex3_denorm_potnt_norm};
//=======================Pipe to EX4========================
//gate clk
// &Instance("gated_clk_cell","x_ex3_pipe_clk"); @337
gated_clk_cell  x_ex3_pipe_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (ex3_pipe_clk      ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (ex3_pipe_clk_en   ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @338
//           .clk_out        (ex3_pipe_clk),//Out Clock @339
//           .external_en    (1'b0), @340
//           .global_en      (cp0_yy_clk_en), @341
//           .local_en       (ex3_pipe_clk_en),//Local Condition @342
//           .module_en      (cp0_fpu_icg_en) @343
//         ); @344
assign ex3_pipe_clk_en = ex3_pipedown;

always @(posedge ex3_pipe_clk)
begin
  if(ex3_pipedown)
  begin
    fdsu_ex4_result_nor      <= ex3_rst_nor;
    fdsu_ex4_nx              <= ex3_nx;
    fdsu_ex4_denorm_to_tiny_frac
                              <= denorm_to_tiny_frac;
    fdsu_ex4_potnt_norm[1:0] <= ex3_potnt_norm[1:0];
  end
  else
  begin
    fdsu_ex4_result_nor      <= fdsu_ex4_result_nor;
    fdsu_ex4_nx              <= fdsu_ex4_nx;
    fdsu_ex4_denorm_to_tiny_frac
                              <= fdsu_ex4_denorm_to_tiny_frac;
    fdsu_ex4_potnt_norm[1:0] <= fdsu_ex4_potnt_norm[1:0];
  end
end

// ex3_frac Pipedown to ex4 use srt_divisor.
assign ex3_frac_final_rst[25:0] = frac_final_rst[25:0];
// &Force("output","fdsu_ex4_result_nor"); @397
// &Force("output","fdsu_ex4_nx"); @398
// &Force("output","fdsu_ex4_denorm_to_tiny_frac"); @399
// &Force("output","fdsu_ex4_potnt_norm"); @400


// &ModuleEnd; @403
endmodule



// ----- 8< ----- FILE "./pa_fdsu_special.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_special(
  cp0_fpu_xx_dqnan,
  dp_xx_ex1_cnan,
  dp_xx_ex1_id,
  dp_xx_ex1_inf,
  dp_xx_ex1_qnan,
  dp_xx_ex1_snan,
  dp_xx_ex1_zero,
  ex1_div,
  ex1_op0_id,
  ex1_op0_norm,
  ex1_op0_sign,
  ex1_op1_id,
  ex1_op1_norm,
  ex1_result_sign,
  ex1_sqrt,
  ex1_srt_skip,
  fdsu_fpu_ex1_fflags,
  fdsu_fpu_ex1_special_sel,
  fdsu_fpu_ex1_special_sign
);

// &Ports; @24
input          cp0_fpu_xx_dqnan;         
input   [2:0]  dp_xx_ex1_cnan;           
input   [2:0]  dp_xx_ex1_id;             
input   [2:0]  dp_xx_ex1_inf;            
input   [2:0]  dp_xx_ex1_qnan;           
input   [2:0]  dp_xx_ex1_snan;           
input   [2:0]  dp_xx_ex1_zero;           
input          ex1_div;                  
input          ex1_op0_sign;             
input          ex1_result_sign;          
input          ex1_sqrt;                 
output         ex1_op0_id;               
output         ex1_op0_norm;             
output         ex1_op1_id;               
output         ex1_op1_norm;             
output         ex1_srt_skip;             
output  [4:0]  fdsu_fpu_ex1_fflags;      
output  [7:0]  fdsu_fpu_ex1_special_sel; 
output  [3:0]  fdsu_fpu_ex1_special_sign; 

// &Regs; @25
reg            ex1_result_cnan;          
reg            ex1_result_qnan_op0;      
reg            ex1_result_qnan_op1;      

// &Wires; @26
wire           cp0_fpu_xx_dqnan;         
wire    [2:0]  dp_xx_ex1_cnan;           
wire    [2:0]  dp_xx_ex1_id;             
wire    [2:0]  dp_xx_ex1_inf;            
wire    [2:0]  dp_xx_ex1_qnan;           
wire    [2:0]  dp_xx_ex1_snan;           
wire    [2:0]  dp_xx_ex1_zero;           
wire           ex1_div;                  
wire           ex1_div_dz;               
wire           ex1_div_nv;               
wire           ex1_div_rst_inf;          
wire           ex1_div_rst_qnan;         
wire           ex1_div_rst_zero;         
wire           ex1_dz;                   
wire    [4:0]  ex1_fflags;               
wire           ex1_nv;                   
wire           ex1_op0_cnan;             
wire           ex1_op0_id;               
wire           ex1_op0_inf;              
wire           ex1_op0_is_qnan;          
wire           ex1_op0_is_snan;          
wire           ex1_op0_norm;             
wire           ex1_op0_qnan;             
wire           ex1_op0_sign;             
wire           ex1_op0_snan;             
wire           ex1_op0_tt_zero;          
wire           ex1_op0_zero;             
wire           ex1_op1_cnan;             
wire           ex1_op1_id;               
wire           ex1_op1_inf;              
wire           ex1_op1_is_qnan;          
wire           ex1_op1_is_snan;          
wire           ex1_op1_norm;             
wire           ex1_op1_qnan;             
wire           ex1_op1_snan;             
wire           ex1_op1_tt_zero;          
wire           ex1_op1_zero;             
wire           ex1_result_inf;           
wire           ex1_result_lfn;           
wire           ex1_result_qnan;          
wire           ex1_result_sign;          
wire           ex1_result_zero;          
wire           ex1_rst_default_qnan;     
wire    [7:0]  ex1_special_sel;          
wire    [3:0]  ex1_special_sign;         
wire           ex1_sqrt;                 
wire           ex1_sqrt_nv;              
wire           ex1_sqrt_rst_inf;         
wire           ex1_sqrt_rst_qnan;        
wire           ex1_sqrt_rst_zero;        
wire           ex1_srt_skip;             
wire    [4:0]  fdsu_fpu_ex1_fflags;      
wire    [7:0]  fdsu_fpu_ex1_special_sel; 
wire    [3:0]  fdsu_fpu_ex1_special_sign; 


//infinity number
// &Force("bus", "dp_xx_ex1_inf", 2, 0); @29
assign  ex1_op0_inf                = dp_xx_ex1_inf[0];
assign  ex1_op1_inf                = dp_xx_ex1_inf[1];

//zero
// &Force("bus", "dp_xx_ex1_zero", 2, 0); @34
assign ex1_op0_zero                = dp_xx_ex1_zero[0];
assign ex1_op1_zero                = dp_xx_ex1_zero[1];

//denormalize number
// &Force("bus", "dp_xx_ex1_id", 2, 0); @39
assign ex1_op0_id                  = dp_xx_ex1_id[0];
assign ex1_op1_id                  = dp_xx_ex1_id[1];

//cNaN
// &Force("bus", "dp_xx_ex1_cnan", 2, 0); @44
assign ex1_op0_cnan                = dp_xx_ex1_cnan[0];
assign ex1_op1_cnan                = dp_xx_ex1_cnan[1];

//sNaN
// &Force("bus", "dp_xx_ex1_snan", 2, 0); @49
assign ex1_op0_snan                = dp_xx_ex1_snan[0];
assign ex1_op1_snan                = dp_xx_ex1_snan[1];

//qNaN
// &Force("bus", "dp_xx_ex1_qnan", 2, 0); @54
assign ex1_op0_qnan                = dp_xx_ex1_qnan[0];
assign ex1_op1_qnan                = dp_xx_ex1_qnan[1];


//======================EX1 expt detect=====================
//ex1_id_detect
//any opration is zero
// no input denormalize exception anymore
//
//ex1_nv_detect
//div_nv
//  1.any operation is sNaN
//  2.0/0(include DN flush to zero)
//  3.inf/inf
//sqrt_nv
//  1.any operation is sNaN
//  2.operation sign is 1 && operation is not zero/qNaN
assign ex1_nv      = ex1_div  && ex1_div_nv  ||
                     ex1_sqrt && ex1_sqrt_nv;
//ex1_div_nv
assign ex1_div_nv  = ex1_op0_snan ||
                     ex1_op1_snan ||
                    (ex1_op0_tt_zero && ex1_op1_tt_zero)||
                    (ex1_op0_inf && ex1_op1_inf);
assign ex1_op0_tt_zero = ex1_op0_zero;
assign ex1_op1_tt_zero = ex1_op1_zero;
//ex1_sqrt_nv
assign ex1_sqrt_nv = ex1_op0_snan ||
                     ex1_op0_sign &&
                    (ex1_op0_norm ||
                     ex1_op0_inf );

// This 'norm' also include denorm.
assign ex1_op0_norm = !ex1_op0_inf && !ex1_op0_zero && !ex1_op0_snan && !ex1_op0_qnan && !ex1_op0_cnan;
assign ex1_op1_norm = !ex1_op1_inf && !ex1_op1_zero && !ex1_op1_snan && !ex1_op1_qnan && !ex1_op1_cnan;

//ex1_of_detect
//div_of
//  1.only detect id overflow case
//assign ex1_of      = ex1_div && ex1_div_of;
//assign ex1_div_of  = ex1_op1_id_fm1 &&
//                     ex1_op0_norm &&
//                     ex1_div_id_of;
//
////ex1_uf_detect
////div_uf
////  1.only detect id underflow case
//assign ex1_uf      = ex1_div && ex1_div_uf;
//assign ex1_div_uf  = ex1_op0_id &&
//                     ex1_op1_norm &&
//                     ex1_div_id_uf;
//ex1_dz_detect
//div_dz
//  1.op0 is normal && op1 zero
assign ex1_dz      = ex1_div && ex1_div_dz;
assign ex1_div_dz  = ex1_op1_tt_zero && ex1_op0_norm;

//===================special cal result=====================
//ex1 result is zero
//div_zero
//  1.op0 is zero && op1 is normal
//  2.op0 is zero/normal && op1 is inf
//sqrt_zero
//  1.op0 is zero
assign ex1_result_zero   = ex1_div_rst_zero  && ex1_div  ||
                           ex1_sqrt_rst_zero && ex1_sqrt;
assign ex1_div_rst_zero  = (ex1_op0_tt_zero && ex1_op1_norm ) ||
                           // (!ex1_expnt0_max && !ex1_op0_cnan && ex1_op1_inf);
                           (!ex1_op0_inf && !ex1_op0_qnan && !ex1_op0_snan && !ex1_op0_cnan && ex1_op1_inf);
assign ex1_sqrt_rst_zero = ex1_op0_tt_zero;

//ex1 result is qNaN
//ex1_nv
//div_qnan
//  1.op0 is qnan || op1 is qnan
//sqrt_qnan
//  1.op0 is qnan
assign ex1_result_qnan   = ex1_div_rst_qnan  && ex1_div  ||
                           ex1_sqrt_rst_qnan && ex1_sqrt ||
                           ex1_nv;
assign ex1_div_rst_qnan  = ex1_op0_qnan ||
                           ex1_op1_qnan;
assign ex1_sqrt_rst_qnan = ex1_op0_qnan;

//ex1_rst_default_qnan
//0/0, inf/inf, sqrt negative should get default qNaN
assign ex1_rst_default_qnan = (ex1_div && ex1_op0_zero && ex1_op1_zero) ||
                              (ex1_div && ex1_op0_inf  && ex1_op1_inf)  ||
                              (ex1_sqrt&& ex1_op0_sign && (ex1_op0_norm || ex1_op0_inf));

//ex1 result is inf
//ex1_dz
//
//div_inf
//  1.op0 is inf && op1 is normal/zero
//sqrt_inf
//  1.op0 is inf
assign ex1_result_inf    = ex1_div_rst_inf  && ex1_div  ||
                           ex1_sqrt_rst_inf && ex1_sqrt ||
                           ex1_dz ;
// assign ex1_div_rst_inf   = ex1_op0_inf && !ex1_expnt1_max && !ex1_op1_cnan;
assign ex1_div_rst_inf   = ex1_op0_inf && !ex1_op1_inf && !ex1_op1_qnan && !ex1_op1_snan && !ex1_op1_cnan;
assign ex1_sqrt_rst_inf  = ex1_op0_inf && !ex1_op0_sign;

//ex1 result is lfn
//ex1_of && round result toward not inc 1
assign ex1_result_lfn = 1'b0;

//Default_qnan/Standard_qnan Select
assign ex1_op0_is_snan      = ex1_op0_snan;
assign ex1_op1_is_snan      = ex1_op1_snan && ex1_div;
assign ex1_op0_is_qnan      = ex1_op0_qnan;
assign ex1_op1_is_qnan      = ex1_op1_qnan && ex1_div;

// &CombBeg; @169
always @( ex1_op0_is_snan
       or ex1_op0_cnan
       or ex1_result_qnan
       or ex1_op0_is_qnan
       or ex1_rst_default_qnan
       or cp0_fpu_xx_dqnan
       or ex1_op1_cnan
       or ex1_op1_is_qnan
       or ex1_op1_is_snan)
begin
if(ex1_rst_default_qnan)
begin
  ex1_result_qnan_op0  = 1'b0;
  ex1_result_qnan_op1  = 1'b0;
  ex1_result_cnan      = ex1_result_qnan;
end
else if(ex1_op0_is_snan && cp0_fpu_xx_dqnan)
begin
  ex1_result_qnan_op0  = ex1_result_qnan;
  ex1_result_qnan_op1  = 1'b0;
  ex1_result_cnan      = 1'b0;
end
else if(ex1_op1_is_snan && cp0_fpu_xx_dqnan)
begin
  ex1_result_qnan_op0  = 1'b0;
  ex1_result_qnan_op1  = ex1_result_qnan;
  ex1_result_cnan      = 1'b0;
end
else if(ex1_op0_is_qnan && cp0_fpu_xx_dqnan)
begin
  ex1_result_qnan_op0  = ex1_result_qnan && !ex1_op0_cnan;
  ex1_result_qnan_op1  = 1'b0;
  ex1_result_cnan      = ex1_result_qnan &&  ex1_op0_cnan;
end
else if(ex1_op1_is_qnan && cp0_fpu_xx_dqnan)
begin
  ex1_result_qnan_op0  = 1'b0;
  ex1_result_qnan_op1  = ex1_result_qnan && !ex1_op1_cnan;
  ex1_result_cnan      = ex1_result_qnan &&  ex1_op1_cnan;
end
else
begin
  ex1_result_qnan_op0  = 1'b0;
  ex1_result_qnan_op1  = 1'b0;
  ex1_result_cnan      = ex1_result_qnan;
end
// &CombEnd; @206
end


//Special result should skip SRT logic
assign ex1_srt_skip = ex1_result_zero ||
                      ex1_result_qnan ||
                      ex1_result_lfn  ||
                      ex1_result_inf;
// fflags:
// NV, DZ, OF, UF, NX
assign ex1_fflags[4:0] = {ex1_nv, ex1_dz, 3'b0};
// Special Sel[7:0]:
// qnan_src2, qnan_src1, qnan_src0, cnan, lfn, inf, zero, src2
assign ex1_special_sel[7:0] = {1'b0, ex1_result_qnan_op1, ex1_result_qnan_op0,
                               ex1_result_cnan, ex1_result_lfn, ex1_result_inf,
                               ex1_result_zero, 1'b0};
// Special Sign[3:0]
// lfn, inf, zero, src2
assign ex1_special_sign[3:0] = {ex1_result_sign, ex1_result_sign, ex1_result_sign, 1'b0};

//==========================================================
//                      Output Signal
//==========================================================
assign fdsu_fpu_ex1_fflags[4:0]       = ex1_fflags[4:0];
assign fdsu_fpu_ex1_special_sel[7:0]  = ex1_special_sel[7:0];
assign fdsu_fpu_ex1_special_sign[3:0] = ex1_special_sign[3:0];

// &Force("output", "ex1_op0_norm"); @233
// &Force("output", "ex1_op1_norm"); @234

// &ModuleEnd; @236
endmodule



// ----- 8< ----- FILE "./pa_fdsu_srt_single.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_srt_single(
  cp0_fpu_icg_en,
  cp0_yy_clk_en,
  ex1_divisor,
  ex1_expnt_adder_op1,
  ex1_oper_id_frac,
  ex1_oper_id_frac_f,
  ex1_pipedown,
  ex1_pipedown_gate,
  ex1_remainder,
  ex1_save_op0,
  ex1_save_op0_gate,
  ex2_expnt_adder_op0,
  ex2_of,
  ex2_pipe_clk,
  ex2_pipedown,
  ex2_potnt_of,
  ex2_potnt_uf,
  ex2_result_inf,
  ex2_result_lfn,
  ex2_rslt_denorm,
  ex2_srt_expnt_rst,
  ex2_srt_first_round,
  ex2_uf,
  ex2_uf_srt_skip,
  ex3_frac_final_rst,
  ex3_pipedown,
  fdsu_ex3_id_srt_skip,
  fdsu_ex3_rem_sign,
  fdsu_ex3_rem_zero,
  fdsu_ex3_result_denorm_round_add_num,
  fdsu_ex4_frac,
  fdsu_yy_div,
  fdsu_yy_of_rm_lfn,
  fdsu_yy_op0_norm,
  fdsu_yy_op1_norm,
  fdsu_yy_sqrt,
  forever_cpuclk,
  pad_yy_icg_scan_en,
  srt_remainder_zero,
  srt_sm_on,
  total_qt_rt_30
);

// &Ports; @24
input           cp0_fpu_icg_en;                      
input           cp0_yy_clk_en;                       
input   [23:0]  ex1_divisor;                         
input   [12:0]  ex1_expnt_adder_op1;                 
input   [51:0]  ex1_oper_id_frac;                    
input           ex1_pipedown;                        
input           ex1_pipedown_gate;                   
input   [31:0]  ex1_remainder;                       
input           ex1_save_op0;                        
input           ex1_save_op0_gate;                   
input   [9 :0]  ex2_expnt_adder_op0;                 
input           ex2_pipe_clk;                        
input           ex2_pipedown;                        
input           ex2_srt_first_round;                 
input   [25:0]  ex3_frac_final_rst;                  
input           ex3_pipedown;                        
input           fdsu_yy_div;                         
input           fdsu_yy_of_rm_lfn;                   
input           fdsu_yy_op0_norm;                    
input           fdsu_yy_op1_norm;                    
input           fdsu_yy_sqrt;                        
input           forever_cpuclk;                      
input           pad_yy_icg_scan_en;                  
input           srt_sm_on;                           
output  [51:0]  ex1_oper_id_frac_f;                  
output          ex2_of;                              
output          ex2_potnt_of;                        
output          ex2_potnt_uf;                        
output          ex2_result_inf;                      
output          ex2_result_lfn;                      
output          ex2_rslt_denorm;                     
output  [9 :0]  ex2_srt_expnt_rst;                   
output          ex2_uf;                              
output          ex2_uf_srt_skip;                     
output          fdsu_ex3_id_srt_skip;                
output          fdsu_ex3_rem_sign;                   
output          fdsu_ex3_rem_zero;                   
output  [23:0]  fdsu_ex3_result_denorm_round_add_num; 
output  [25:0]  fdsu_ex4_frac;                       
output          srt_remainder_zero;                  
output  [29:0]  total_qt_rt_30;                      

// &Regs; @25
reg     [31:0]  cur_rem;                             
reg     [7 :0]  digit_bound_1;                       
reg     [7 :0]  digit_bound_2;                       
reg     [23:0]  ex2_result_denorm_round_add_num;     
reg             fdsu_ex3_id_srt_skip;                
reg             fdsu_ex3_rem_sign;                   
reg             fdsu_ex3_rem_zero;                   
reg     [23:0]  fdsu_ex3_result_denorm_round_add_num; 
reg     [29:0]  qt_rt_const_shift_std;               
reg     [7 :0]  qtrt_sel_rem;                        
reg     [31:0]  rem_add1_op1;                        
reg     [31:0]  rem_add2_op1;                        
reg     [25:0]  srt_divisor;                         
reg     [31:0]  srt_remainder;                       
reg     [29:0]  total_qt_rt_30;                      
reg     [29:0]  total_qt_rt_30_next;                 
reg     [29:0]  total_qt_rt_minus_30;                
reg     [29:0]  total_qt_rt_minus_30_next;           

// &Wires; @26
wire    [7 :0]  bound1_cmp_result;                   
wire            bound1_cmp_sign;                     
wire    [7 :0]  bound2_cmp_result;                   
wire            bound2_cmp_sign;                     
wire    [3 :0]  bound_sel;                           
wire            cp0_fpu_icg_en;                      
wire            cp0_yy_clk_en;                       
wire    [31:0]  cur_doub_rem_1;                      
wire    [31:0]  cur_doub_rem_2;                      
wire    [31:0]  cur_rem_1;                           
wire    [31:0]  cur_rem_2;                           
wire    [31:0]  div_qt_1_rem_add_op1;                
wire    [31:0]  div_qt_2_rem_add_op1;                
wire    [31:0]  div_qt_r1_rem_add_op1;               
wire    [31:0]  div_qt_r2_rem_add_op1;               
wire    [23:0]  ex1_divisor;                         
wire            ex1_ex2_pipe_clk;                    
wire            ex1_ex2_pipe_clk_en;                 
wire    [12:0]  ex1_expnt_adder_op1;                 
wire    [51:0]  ex1_oper_id_frac;                    
wire    [51:0]  ex1_oper_id_frac_f;                  
wire            ex1_pipedown;                        
wire            ex1_pipedown_gate;                   
wire    [31:0]  ex1_remainder;                       
wire            ex1_save_op0;                        
wire            ex1_save_op0_gate;                   
wire            ex2_div_of;                          
wire            ex2_div_uf;                          
wire    [9 :0]  ex2_expnt_adder_op0;                 
wire    [9 :0]  ex2_expnt_adder_op1;                 
wire            ex2_expnt_of;                        
wire    [9 :0]  ex2_expnt_result;                    
wire            ex2_expnt_uf;                        
wire            ex2_id_nor_srt_skip;                 
wire            ex2_of;                              
wire            ex2_of_plus;                         
wire            ex2_pipe_clk;                        
wire            ex2_pipedown;                        
wire            ex2_potnt_of;                        
wire            ex2_potnt_of_pre;                    
wire            ex2_potnt_uf;                        
wire            ex2_potnt_uf_pre;                    
wire            ex2_result_inf;                      
wire            ex2_result_lfn;                      
wire            ex2_rslt_denorm;                     
wire    [9 :0]  ex2_sqrt_expnt_result;               
wire    [9 :0]  ex2_srt_expnt_rst;                   
wire            ex2_srt_first_round;                 
wire            ex2_uf;                              
wire            ex2_uf_plus;                         
wire            ex2_uf_srt_skip;                     
wire    [25:0]  ex3_frac_final_rst;                  
wire            ex3_pipedown;                        
wire            fdsu_ex2_div;                        
wire    [9 :0]  fdsu_ex2_expnt_rst;                  
wire            fdsu_ex2_of_rm_lfn;                  
wire            fdsu_ex2_op0_norm;                   
wire            fdsu_ex2_op1_norm;                   
wire            fdsu_ex2_result_lfn;                 
wire            fdsu_ex2_sqrt;                       
wire    [25:0]  fdsu_ex4_frac;                       
wire            fdsu_yy_div;                         
wire            fdsu_yy_of_rm_lfn;                   
wire            fdsu_yy_op0_norm;                    
wire            fdsu_yy_op1_norm;                    
wire            fdsu_yy_sqrt;                        
wire            forever_cpuclk;                      
wire            pad_yy_icg_scan_en;                  
wire            qt_clk;                              
wire            qt_clk_en;                           
wire    [29:0]  qt_rt_const_pre_sel_q1;              
wire    [29:0]  qt_rt_const_pre_sel_q2;              
wire    [29:0]  qt_rt_const_q1;                      
wire    [29:0]  qt_rt_const_q2;                      
wire    [29:0]  qt_rt_const_q3;                      
wire    [29:0]  qt_rt_const_shift_std_next;          
wire    [29:0]  qt_rt_mins_const_pre_sel_q1;         
wire    [29:0]  qt_rt_mins_const_pre_sel_q2;         
wire            rem_sign;                            
wire    [31:0]  sqrt_qt_1_rem_add_op1;               
wire    [31:0]  sqrt_qt_2_rem_add_op1;               
wire    [31:0]  sqrt_qt_r1_rem_add_op1;              
wire    [31:0]  sqrt_qt_r2_rem_add_op1;              
wire            srt_div_clk;                         
wire            srt_div_clk_en;                      
wire    [31:0]  srt_remainder_nxt;                   
wire    [31:0]  srt_remainder_shift;                 
wire            srt_remainder_sign;                  
wire            srt_remainder_zero;                  
wire            srt_sm_on;                           
wire    [29:0]  total_qt_rt_pre_sel;                 


assign fdsu_ex2_div             = fdsu_yy_div;
assign fdsu_ex2_sqrt            = fdsu_yy_sqrt;
assign fdsu_ex2_op0_norm        = fdsu_yy_op0_norm;
assign fdsu_ex2_op1_norm        = fdsu_yy_op1_norm;
assign fdsu_ex2_of_rm_lfn       = fdsu_yy_of_rm_lfn;
assign fdsu_ex2_result_lfn      = 1'b0;

//==========================================================
//                    EX2 Expnt Generate
//==========================================================
//expnt0 sub expnt1
assign ex2_expnt_result[9:0] =  ex2_expnt_adder_op0[9:0] -
                                 ex2_expnt_adder_op1[9:0];

//===================sqrt exponent prepare==================
//sqrt exponent prepare
//afert E sub, div E by 2
assign ex2_sqrt_expnt_result[9:0] = {ex2_expnt_result[9],
                                      ex2_expnt_result[9:1]};

assign ex2_srt_expnt_rst[9:0] = (fdsu_ex2_sqrt)
                               ? ex2_sqrt_expnt_result[9:0]
                               : ex2_expnt_result[9:0];
// &Force("output", "ex2_srt_expnt_rst"); &Force("bus", "ex2_srt_expnt_rst", 9, 0); @51
assign fdsu_ex2_expnt_rst[9:0] = ex2_srt_expnt_rst[9:0];


//====================EX2 Expt info=========================
//EX1 only detect of/uf under id condition
//EX2 will deal with other condition

//When input is normal, overflow when E1-E2 > 128/1024
assign ex2_expnt_of = ~fdsu_ex2_expnt_rst[9] && (fdsu_ex2_expnt_rst[8]
                                                      || (fdsu_ex2_expnt_rst[7]  &&
                                                          |fdsu_ex2_expnt_rst[6:0]));
//potential overflow when E1-E2 = 128/1024
assign ex2_potnt_of_pre = ~fdsu_ex2_expnt_rst[9]  &&
                           ~fdsu_ex2_expnt_rst[8]  &&
                            fdsu_ex2_expnt_rst[7]  &&
                          ~|fdsu_ex2_expnt_rst[6:0];
assign ex2_potnt_of      = ex2_potnt_of_pre &&
                           fdsu_ex2_op0_norm &&
                           fdsu_ex2_op1_norm &&
                           fdsu_ex2_div;

//When input is normal, underflow when E1-E2 <= -127/-1023
assign ex2_expnt_uf = fdsu_ex2_expnt_rst[9] &&(fdsu_ex2_expnt_rst[8:0] <= 9'h181);
//potential underflow when E1-E2 = -126/-1022
assign ex2_potnt_uf_pre = &fdsu_ex2_expnt_rst[9:7]   &&
                          ~|fdsu_ex2_expnt_rst[6:2]   &&
                            fdsu_ex2_expnt_rst[1]     &&
                           !fdsu_ex2_expnt_rst[0];
assign ex2_potnt_uf      = (ex2_potnt_uf_pre &&
                            fdsu_ex2_op0_norm &&
                            fdsu_ex2_op1_norm &&
                            fdsu_ex2_div)     ||
                           (ex2_potnt_uf_pre   &&
                            fdsu_ex2_op0_norm);

//========================EX2 Overflow======================
//ex2 overflow when
//  1.op0 & op1 both norm && expnt overflow
//  2.ex1_id_of
// &Force("output","ex2_of"); @91
assign ex2_of      = ex2_of_plus;
assign ex2_of_plus = ex2_div_of  && fdsu_ex2_div;
assign ex2_div_of  = fdsu_ex2_op0_norm &&
                     fdsu_ex2_op1_norm &&
                     ex2_expnt_of;

//=======================EX2 Underflow======================
//ex2 underflow when
//  1.op0 & op1 both norm && expnt underflow
//  2.ex1_id_uf
//  and detect when to skip the srt, here, we have further optmization
assign ex2_uf      = ex2_uf_plus;
assign ex2_uf_plus = ex2_div_uf  && fdsu_ex2_div;
assign ex2_div_uf  = fdsu_ex2_op0_norm &&
                     fdsu_ex2_op1_norm &&
                     ex2_expnt_uf;
assign ex2_id_nor_srt_skip =  fdsu_ex2_expnt_rst[9]
                                     && (fdsu_ex2_expnt_rst[8:0]<9'h16a);
assign ex2_uf_srt_skip            = ex2_id_nor_srt_skip;
assign ex2_rslt_denorm            = ex2_uf;
//===============ex2 round prepare for denormal round======
// &CombBeg; @113
always @( fdsu_ex2_expnt_rst[9:0])
begin
case(fdsu_ex2_expnt_rst[9:0])
  10'h382:ex2_result_denorm_round_add_num[23:0] = 24'h1; //-126 1
  10'h381:ex2_result_denorm_round_add_num[23:0] = 24'h2; //-127 0
  10'h380:ex2_result_denorm_round_add_num[23:0] = 24'h4; //-128 -1
  10'h37f:ex2_result_denorm_round_add_num[23:0] = 24'h8; //-129 -2
  10'h37e:ex2_result_denorm_round_add_num[23:0] = 24'h10; //-130 -3
  10'h37d:ex2_result_denorm_round_add_num[23:0] = 24'h20; //-131 -4
  10'h37c:ex2_result_denorm_round_add_num[23:0] = 24'h40; //-132 -5
  10'h37b:ex2_result_denorm_round_add_num[23:0] = 24'h80; //-133 -6
  10'h37a:ex2_result_denorm_round_add_num[23:0] = 24'h100; //-134 -7
  10'h379:ex2_result_denorm_round_add_num[23:0] = 24'h200; //-135 -8
  10'h378:ex2_result_denorm_round_add_num[23:0] = 24'h400; //-136 -9
  10'h377:ex2_result_denorm_round_add_num[23:0] = 24'h800; //-137 -10
  10'h376:ex2_result_denorm_round_add_num[23:0] = 24'h1000; //-138 -11
  10'h375:ex2_result_denorm_round_add_num[23:0] = 24'h2000; //-139 -12
  10'h374:ex2_result_denorm_round_add_num[23:0] = 24'h4000; //-140 -13
  10'h373:ex2_result_denorm_round_add_num[23:0] = 24'h8000; // -141 -14
  10'h372:ex2_result_denorm_round_add_num[23:0] = 24'h10000;//-142  -15
  10'h371:ex2_result_denorm_round_add_num[23:0] = 24'h20000;//-143 -16
  10'h370:ex2_result_denorm_round_add_num[23:0] = 24'h40000; //-144 -17
  10'h36f:ex2_result_denorm_round_add_num[23:0] = 24'h80000; //-145 -18
  10'h36e:ex2_result_denorm_round_add_num[23:0] = 24'h100000; //-146 -19
  10'h36d:ex2_result_denorm_round_add_num[23:0] = 24'h200000; //-147 -20
  10'h36c:ex2_result_denorm_round_add_num[23:0] = 24'h400000; //-148 -21
  10'h36b:ex2_result_denorm_round_add_num[23:0] = 24'h800000; //-148 -22
  default: ex2_result_denorm_round_add_num[23:0] = 24'h0;  // -23
endcase
// &CombEnd; @141
end

//===================special result========================
assign ex2_result_inf  = ex2_of_plus && !fdsu_ex2_of_rm_lfn;
assign ex2_result_lfn  = fdsu_ex2_result_lfn ||
                         ex2_of_plus &&  fdsu_ex2_of_rm_lfn;



//====================Pipe to EX3===========================
always @(posedge ex1_ex2_pipe_clk)
begin
  if(ex1_pipedown)
  begin
    fdsu_ex3_result_denorm_round_add_num[23:0]
                              <= {14'b0, ex1_expnt_adder_op1[9:0]};
  end
  else if(ex2_pipedown)
  begin
    fdsu_ex3_result_denorm_round_add_num[23:0]
                              <= ex2_result_denorm_round_add_num[23:0];
  end
  else
  begin
    fdsu_ex3_result_denorm_round_add_num[23:0]
                              <= fdsu_ex3_result_denorm_round_add_num[23:0];
  end
end
assign ex2_expnt_adder_op1 = fdsu_ex3_result_denorm_round_add_num[9:0];
// &Force("bus", "ex1_expnt_adder_op1", 12, 0); @193

assign ex1_ex2_pipe_clk_en = ex1_pipedown_gate || ex2_pipedown;
// &Instance("gated_clk_cell", "x_ex1_ex2_pipe_clk"); @196
gated_clk_cell  x_ex1_ex2_pipe_clk (
  .clk_in              (forever_cpuclk     ),
  .clk_out             (ex1_ex2_pipe_clk   ),
  .external_en         (1'b0               ),
  .global_en           (cp0_yy_clk_en      ),
  .local_en            (ex1_ex2_pipe_clk_en),
  .module_en           (cp0_fpu_icg_en     ),
  .pad_yy_icg_scan_en  (pad_yy_icg_scan_en )
);

// &Connect(.clk_in      (forever_cpuclk), @197
//          .external_en (1'b0), @198
//          .global_en   (cp0_yy_clk_en), @199
//          .module_en   (cp0_fpu_icg_en), @200
//          .local_en    (ex1_ex2_pipe_clk_en), @201
//          .clk_out     (ex1_ex2_pipe_clk)); @202

always @(posedge ex2_pipe_clk)
begin
  if(ex2_pipedown)
  begin
    fdsu_ex3_rem_sign        <= srt_remainder_sign;
    fdsu_ex3_rem_zero        <= srt_remainder_zero;
    fdsu_ex3_id_srt_skip     <= ex2_id_nor_srt_skip;
  end
  else
  begin
    fdsu_ex3_rem_sign        <= fdsu_ex3_rem_sign;
    fdsu_ex3_rem_zero        <= fdsu_ex3_rem_zero;
    fdsu_ex3_id_srt_skip    <=  fdsu_ex3_id_srt_skip;
  end
end

// &Force("output","fdsu_ex3_rem_sign"); @243
// &Force("output","fdsu_ex3_rem_zero"); @244
// &Force("output","fdsu_ex3_result_denorm_round_add_num"); @245
// &Force("output","fdsu_ex3_id_srt_skip"); @246

//==========================================================
//    SRT Remainder & Divisor for Quotient/Root Generate
//==========================================================

//===================Remainder Generate=====================
//gate clk
// &Instance("gated_clk_cell","x_srt_rem_clk");
// // &Connect( .clk_in         (forever_cpuclk), @255
// //           .clk_out        (srt_rem_clk),//Out Clock @256
// //           .external_en    (1'b0), @257
// //           .global_en      (cp0_yy_clk_en), @258
// //           .local_en       (srt_rem_clk_en),//Local Condition @259
// //           .module_en      (cp0_fpu_icg_en) @260
// //         ); @261
// assign srt_rem_clk_en = ex1_pipedown ||
//                         srt_sm_on;

always @(posedge qt_clk)
begin
  if (ex1_pipedown)
    srt_remainder[31:0] <= ex1_remainder[31:0];
  else if (srt_sm_on)
    srt_remainder[31:0] <= srt_remainder_nxt[31:0];
  else
    srt_remainder[31:0] <= srt_remainder[31:0];
end

//=====================Divisor Generate=====================
//gate clk
// &Instance("gated_clk_cell","x_srt_div_clk"); @291
gated_clk_cell  x_srt_div_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (srt_div_clk       ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (srt_div_clk_en    ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @292
//           .clk_out        (srt_div_clk),//Out Clock @293
//           .external_en    (1'b0), @294
//           .global_en      (cp0_yy_clk_en), @295
//           .local_en       (srt_div_clk_en),//Local Condition @296
//           .module_en      (cp0_fpu_icg_en) @297
//         ); @298
assign srt_div_clk_en = ex1_pipedown_gate
                     || ex1_save_op0_gate
                     || ex3_pipedown;
// final_rst saved in srt_divisor.
// srt_divisor is 26 bits, final_rst is 24 bits.
always @(posedge srt_div_clk)
begin
  if (ex1_save_op0)
    srt_divisor[25:0] <= {3'b0, {ex1_oper_id_frac[51:29]}};
  else if (ex1_pipedown)
    srt_divisor[25:0] <= {2'b0, ex1_divisor[23:0]};
  else if (ex3_pipedown)
    srt_divisor[25:0] <= ex3_frac_final_rst[25:0];
  else
    srt_divisor[25:0] <= srt_divisor[25:0];
end
assign ex1_oper_id_frac_f[51:0] = {srt_divisor[22:0], 29'b0};
// &Force("bus", "ex1_oper_id_frac", 51, 0); @332
assign fdsu_ex4_frac[25:0] = srt_divisor[25:0];

//=======================Bound Select=======================
//---------------------------------------+
// K   | 8 | 9 | 10| 11| 12| 13| 14|15,16|
//---------------------------------------+
//32S1 | 7 | 7 | 8 | 9 | 9 | 10| 11|  12 |
//---------------------------------------+
//32S2 | 25| 28| 31| 33| 36| 39| 41|  47 |
//---------------------------------------+

//bound_sel[3:0]
//For div,  use divisor high four bit as K
//For sqrt, use 2qi high four bit as K next round and
//          use 1010 as K first round
assign bound_sel[3:0] = (fdsu_ex2_div)
                      ? srt_divisor[23:20]
                      : (ex2_srt_first_round)
                        ? 4'b1010
                        : total_qt_rt_30[28:25];
//Select bound as look up table
//   K = bound_sel[3:0]
//32S1 = digit_bound_1[7:0]
//32s2 = digit_bound_2[7:0]
// &CombBeg; @357
always @( bound_sel[3:0])
begin
case(bound_sel[3:0])
4'b0000:       //when first interation get "10", choose k=16
   begin
     digit_bound_1[7:0] = 8'b11110100;//-12
     digit_bound_2[7:0] = 8'b11010001;//-47
   end
4'b1000:
   begin
     digit_bound_1[7:0] = 8'b11111001;//-7
     digit_bound_2[7:0] = 8'b11100111;//-25
   end
4'b1001:
   begin
     digit_bound_1[7:0] = 8'b11111001;//-7
     digit_bound_2[7:0] = 8'b11100100;//-28
   end
4'b1010:
   begin
     digit_bound_1[7:0] = 8'b11111000;//-8
     digit_bound_2[7:0] = 8'b11100001;//-31
   end
4'b1011:
   begin
     digit_bound_1[7:0] = 8'b11110111;//-9
     digit_bound_2[7:0] = 8'b11011111;//-33
   end
4'b1100:
   begin
     digit_bound_1[7:0] = 8'b11110111;//-9
     digit_bound_2[7:0] = 8'b11011100;//-36
   end
4'b1101:
   begin
     digit_bound_1[7:0] = 8'b11110110;//-10
     digit_bound_2[7:0] = 8'b11011001;//-39
   end
4'b1110:
   begin
     digit_bound_1[7:0] = 8'b11110101;//-11
     digit_bound_2[7:0] = 8'b11010111;//-41
   end
4'b1111:
   begin
     digit_bound_1[7:0] = 8'b11110100;//-12
     digit_bound_2[7:0] = 8'b11010001;//-47
   end
default:
   begin
     digit_bound_1[7:0] = 8'b11111001;//-7
     digit_bound_2[7:0] = 8'b11100111;//-25
   end
endcase
// &CombEnd; @410
end

//==============Prepare for quotient generate===============
assign bound1_cmp_result[7:0] = qtrt_sel_rem[7:0] + digit_bound_1[7:0];
assign bound2_cmp_result[7:0] = qtrt_sel_rem[7:0] + digit_bound_2[7:0];
assign bound1_cmp_sign        = bound1_cmp_result[7];
assign bound2_cmp_sign        = bound2_cmp_result[7];
assign rem_sign               = srt_remainder[29];

//qtrt_sel_rem is use to select quotient
//Only when sqrt first round use 8R0 select quotient(special rule)
//4R0 is used to select quotient on other condition
//For negative remaider, we use ~rem not (~rem + 1)
//Because  bound1 <=  rem   <   bound2, when positive rem
//        -bound2 <=  rem   <  -bound1, when negative rem
//Thus     bound1 <  -rem   <=  bound2, when negative rem
//Thus     bound1 <= -rem-1 <   bound2, when negative rem
//Thus     bound1 <= ~rem   <   bound2, when negative rem
//srt_remainder[29] used as sign bit
// &CombBeg; @429
always @( ex2_srt_first_round
       or fdsu_ex2_sqrt
       or srt_remainder[29:21])
begin
if(ex2_srt_first_round && fdsu_ex2_sqrt)
  qtrt_sel_rem[7:0] = {srt_remainder[29],   srt_remainder[27:21]};
else
  qtrt_sel_rem[7:0] =  srt_remainder[29] ? ~srt_remainder[29:22]
                                         :  srt_remainder[29:22];
// &CombEnd; @435
end

//==========================================================
//     on fly round method to generate total quotient
//==========================================================
//gate clk
// &Instance("gated_clk_cell","x_qt_clk"); @441
gated_clk_cell  x_qt_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (qt_clk            ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (qt_clk_en         ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @442
//           .clk_out        (qt_clk),//Out Clock @443
//           .external_en    (1'b0), @444
//           .global_en      (cp0_yy_clk_en), @445
//           .local_en       (qt_clk_en),//Local Condition @446
//           .module_en      (cp0_fpu_icg_en) @447
//         ); @448
assign qt_clk_en = srt_sm_on ||
                   ex1_pipedown_gate;

//qt_rt_const_shift_std[29:0] is const data for on fly round
//                which is used to record the times of round
//
//total_qt_rt[29:0]       is total quotient
//total_qt_rt_minus[29:0] is total quotient minus
//                which is used to generate quotient rapidly
always @(posedge qt_clk)
begin
  if(ex1_pipedown)
  begin
    qt_rt_const_shift_std[29:0] <= {1'b0,1'b1,28'b0};
    total_qt_rt_30[29:0]        <= 30'b0;
    total_qt_rt_minus_30[29:0]  <= 30'b0;
  end
  else if(srt_sm_on)
  begin
    qt_rt_const_shift_std[29:0] <= qt_rt_const_shift_std_next[29:0];
    total_qt_rt_30[29:0]        <= total_qt_rt_30_next[29:0];
    total_qt_rt_minus_30[29:0]  <= total_qt_rt_minus_30_next[29:0];
  end
  else
  begin
    qt_rt_const_shift_std[29:0] <= qt_rt_const_shift_std[29:0];
    total_qt_rt_30[29:0]        <= total_qt_rt_30[29:0];
    total_qt_rt_minus_30[29:0]  <= total_qt_rt_minus_30[29:0];
  end
end
// &Force("output","total_qt_rt_30"); @508

//qt_rt_const_q1/q2/q3 for shift 1/2/3 in
assign qt_rt_const_q1[29:0] =  qt_rt_const_shift_std[29:0];
assign qt_rt_const_q2[29:0] = {qt_rt_const_shift_std[28:0],1'b0};
assign qt_rt_const_q3[29:0] =  qt_rt_const_q1[29:0] |
                               qt_rt_const_q2[29:0];
//qt_rt_const update value
assign qt_rt_const_shift_std_next[29:0] = {2'b0, qt_rt_const_shift_std[29:2]};

//========total_qt_rt & total_qt_rt_minus update value======
//q(i+1) is the total quotient/root after the (i+1) digit
//is calculated
//                 q(i+1)             qm(i+1)
//d(i+1)=-2     qm(i)+2*shift      qm(i)+1*shift
//d(i+1)=-1     qm(i)+3*shift      qm(i)+2*shift
//d(i+1)=0      q(i)               qm(i)+3*shift
//d(i+1)=1      q(i)+1*shift       q(i)
//d(i+1)=2      q(i)+2*shift       q(i)+1*shift
//Note:
//shift = 4^(-i-1), qm(i+1)=q(i+1)-shift

//pre select for quotient
assign total_qt_rt_pre_sel[29:0]         = (rem_sign) ?
                                           total_qt_rt_minus_30[29:0] :
                                           total_qt_rt_30[29:0];
//when the quotient is 2 or -2
assign qt_rt_const_pre_sel_q2[29:0]      = qt_rt_const_q2[29:0];
assign qt_rt_mins_const_pre_sel_q2[29:0] = qt_rt_const_q1[29:0];
//when the quotient is 1 or -1
assign qt_rt_const_pre_sel_q1[29:0]      = (rem_sign) ?
                                           qt_rt_const_q3[29:0] ://-1
                                           qt_rt_const_q1[29:0]; //1
assign qt_rt_mins_const_pre_sel_q1[29:0] = (rem_sign) ?
                                           qt_rt_const_q2[29:0] : //-1
                                           30'b0;

//After bound compare, the final selection
// &CombBeg; @546
always @( qt_rt_const_q3[29:0]
       or qt_rt_mins_const_pre_sel_q1[29:0]
       or bound1_cmp_sign
       or total_qt_rt_30[29:0]
       or qt_rt_mins_const_pre_sel_q2[29:0]
       or total_qt_rt_minus_30[29:0]
       or bound2_cmp_sign
       or qt_rt_const_pre_sel_q2[29:0]
       or qt_rt_const_pre_sel_q1[29:0]
       or total_qt_rt_pre_sel[29:0])
begin
casez({bound1_cmp_sign,bound2_cmp_sign})
  2'b00:// the quotient is -2 or 2
  begin
    total_qt_rt_30_next[29:0]       = total_qt_rt_pre_sel[29:0] |
                                      qt_rt_const_pre_sel_q2[29:0];
    total_qt_rt_minus_30_next[29:0] = total_qt_rt_pre_sel[29:0] |
                                      qt_rt_mins_const_pre_sel_q2[29:0];
  end
  2'b01:// quotient is -1 or 1
  begin
    total_qt_rt_30_next[29:0]       = total_qt_rt_pre_sel[29:0] |
                                      qt_rt_const_pre_sel_q1[29:0];
    total_qt_rt_minus_30_next[29:0] = total_qt_rt_pre_sel[29:0] |
                                      qt_rt_mins_const_pre_sel_q1[29:0];
  end
  2'b1?: // quotient is 0
  begin
    total_qt_rt_30_next[29:0]       = total_qt_rt_30[29:0];
    total_qt_rt_minus_30_next[29:0] = total_qt_rt_minus_30[29:0] |
                                      qt_rt_const_q3[29:0];
  end
  default:
  begin
    total_qt_rt_30_next[29:0]       = 30'b0;
    total_qt_rt_minus_30_next[29:0] = 30'b0;
  end
endcase
// &CombEnd; @574
end

//==========================================================
//      on fly round method to generate cur remainder
//==========================================================
//Division emainder add value
//Quoit 1
assign div_qt_1_rem_add_op1[31:0]   = ~{3'b0,srt_divisor[23:0],5'b0};
//Quoit 2
assign div_qt_2_rem_add_op1[31:0]   = ~{2'b0,srt_divisor[23:0],6'b0};
//Quoit -1
assign div_qt_r1_rem_add_op1[31:0]  =  {3'b0,srt_divisor[23:0],5'b0};
//Quoit -2
assign div_qt_r2_rem_add_op1[31:0]  =  {2'b0,srt_divisor[23:0],6'b0};

//Sqrt remainder add value op1
//Quoit 1
assign sqrt_qt_1_rem_add_op1[31:0]  = ~({2'b0,total_qt_rt_30[29:0]} |
                                        {3'b0,qt_rt_const_q1[29:1]});
//Quoit 2
assign sqrt_qt_2_rem_add_op1[31:0]  = ~({1'b0,total_qt_rt_30[29:0],1'b0} |
                                        {1'b0,qt_rt_const_q1[29:0],1'b0});
//Quoit -1
assign sqrt_qt_r1_rem_add_op1[31:0] =   {2'b0,total_qt_rt_minus_30[29:0]} |
                                        {1'b0,qt_rt_const_q1[29:0],1'b0}  |
                                        {2'b0,qt_rt_const_q1[29:0]}       |
                                        {3'b0,qt_rt_const_q1[29:1]};
//Quoit -2
assign sqrt_qt_r2_rem_add_op1[31:0] =   {1'b0,
                                         total_qt_rt_minus_30[29:0],1'b0} |
                                        {qt_rt_const_q1[29:0],2'b0}       |
                                        {1'b0,qt_rt_const_q1[29:0],1'b0};
//Remainder Adder select logic
// &CombBeg; @607
always @( div_qt_2_rem_add_op1[31:0]
       or sqrt_qt_r2_rem_add_op1[31:0]
       or sqrt_qt_r1_rem_add_op1[31:0]
       or rem_sign
       or div_qt_r2_rem_add_op1[31:0]
       or div_qt_1_rem_add_op1[31:0]
       or sqrt_qt_2_rem_add_op1[31:0]
       or fdsu_ex2_sqrt
       or div_qt_r1_rem_add_op1[31:0]
       or sqrt_qt_1_rem_add_op1[31:0])
begin
case({rem_sign,fdsu_ex2_sqrt})
  2'b01:
  begin
        rem_add1_op1[31:0] = sqrt_qt_1_rem_add_op1[31:0];
        rem_add2_op1[31:0] = sqrt_qt_2_rem_add_op1[31:0];
  end
  2'b00:
  begin
        rem_add1_op1[31:0] = div_qt_1_rem_add_op1[31:0];
        rem_add2_op1[31:0] = div_qt_2_rem_add_op1[31:0];
  end
  2'b11:
  begin
        rem_add1_op1[31:0] = sqrt_qt_r1_rem_add_op1[31:0];
        rem_add2_op1[31:0] = sqrt_qt_r2_rem_add_op1[31:0];
  end
  2'b10:
  begin
        rem_add1_op1[31:0] = div_qt_r1_rem_add_op1[31:0];
        rem_add2_op1[31:0] = div_qt_r2_rem_add_op1[31:0];
  end
  default :
  begin
        rem_add1_op1[31:0] = 32'b0;
        rem_add2_op1[31:0] = 32'b0;
  end
  endcase
// &CombEnd; @635
end
assign srt_remainder_shift[31:0] = {srt_remainder[31],
                                    srt_remainder[28:0],2'b0};
//Remainder add
assign cur_doub_rem_1[31:0]      = srt_remainder_shift[31:0] +
                                   rem_add1_op1[31:0]    +
                                   {31'b0, ~rem_sign};
assign cur_doub_rem_2[31:0]      = srt_remainder_shift[31:0] +
                                   rem_add2_op1[31:0]    +
                                   {31'b0, ~rem_sign};
assign cur_rem_1[31:0]           = cur_doub_rem_1[31:0];
assign cur_rem_2[31:0]           = cur_doub_rem_2[31:0];
//Generate srt remainder update value
// &CombBeg; @648
always @( cur_rem_2[31:0]
       or bound1_cmp_sign
       or srt_remainder_shift[31:0]
       or bound2_cmp_sign
       or cur_rem_1[31:0])
begin
case({bound1_cmp_sign,bound2_cmp_sign})
  2'b00:   cur_rem[31:0]         = cur_rem_2[31:0];  //+-2
  2'b01:   cur_rem[31:0]         = cur_rem_1[31:0];  //+-1
  default: cur_rem[31:0]         = srt_remainder_shift[31:0]; //0
endcase
// &CombEnd; @654
end
assign srt_remainder_nxt[31:0]   = cur_rem[31:0];

//Remainder is zero signal in EX3
assign srt_remainder_zero        = ~|srt_remainder[31:0];
// &Force("output","srt_remainder_zero"); @659
assign srt_remainder_sign        =   srt_remainder[31];

// &Force("output", "ex2_uf"); @662
// &ModuleEnd; @663
endmodule



// ----- 8< ----- FILE "./pa_fdsu_top.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_top(
  cp0_fpu_icg_en,
  cp0_fpu_xx_dqnan,
  cp0_yy_clk_en,
  cpurst_b,
  ctrl_fdsu_ex1_sel,
  ctrl_xx_ex1_cmplt_dp,
  ctrl_xx_ex1_inst_vld,
  ctrl_xx_ex1_stall,
  ctrl_xx_ex1_warm_up,
  ctrl_xx_ex2_warm_up,
  ctrl_xx_ex3_warm_up,
  dp_xx_ex1_cnan,
  dp_xx_ex1_id,
  dp_xx_ex1_inf,
  dp_xx_ex1_qnan,
  dp_xx_ex1_rm,
  dp_xx_ex1_snan,
  dp_xx_ex1_zero,
  fdsu_fpu_debug_info,
  fdsu_fpu_ex1_cmplt,
  fdsu_fpu_ex1_cmplt_dp,
  fdsu_fpu_ex1_fflags,
  fdsu_fpu_ex1_special_sel,
  fdsu_fpu_ex1_special_sign,
  fdsu_fpu_ex1_stall,
  fdsu_fpu_no_op,
  fdsu_frbus_data,
  fdsu_frbus_fflags,
  fdsu_frbus_freg,
  fdsu_frbus_wb_vld,
  forever_cpuclk,
  frbus_fdsu_wb_grant,
  idu_fpu_ex1_dst_freg,
  idu_fpu_ex1_eu_sel,
  idu_fpu_ex1_func,
  idu_fpu_ex1_srcf0,
  idu_fpu_ex1_srcf1,
  pad_yy_icg_scan_en,
  rtu_xx_ex1_cancel,
  rtu_xx_ex2_cancel,
  rtu_yy_xx_async_flush,
  rtu_yy_xx_flush
);

// &Ports; @24
input           cp0_fpu_icg_en;                      
input           cp0_fpu_xx_dqnan;                    
input           cp0_yy_clk_en;                       
input           cpurst_b;                            
input           ctrl_fdsu_ex1_sel;                   
input           ctrl_xx_ex1_cmplt_dp;                
input           ctrl_xx_ex1_inst_vld;                
input           ctrl_xx_ex1_stall;                   
input           ctrl_xx_ex1_warm_up;                 
input           ctrl_xx_ex2_warm_up;                 
input           ctrl_xx_ex3_warm_up;                 
input   [2 :0]  dp_xx_ex1_cnan;                      
input   [2 :0]  dp_xx_ex1_id;                        
input   [2 :0]  dp_xx_ex1_inf;                       
input   [2 :0]  dp_xx_ex1_qnan;                      
input   [2 :0]  dp_xx_ex1_rm;                        
input   [2 :0]  dp_xx_ex1_snan;                      
input   [2 :0]  dp_xx_ex1_zero;                      
input           forever_cpuclk;                      
input           frbus_fdsu_wb_grant;                 
input   [4 :0]  idu_fpu_ex1_dst_freg;                
input   [2 :0]  idu_fpu_ex1_eu_sel;                  
input   [9 :0]  idu_fpu_ex1_func;                    
input   [31:0]  idu_fpu_ex1_srcf0;                   
input   [31:0]  idu_fpu_ex1_srcf1;                   
input           pad_yy_icg_scan_en;                  
input           rtu_xx_ex1_cancel;                   
input           rtu_xx_ex2_cancel;                   
input           rtu_yy_xx_async_flush;               
input           rtu_yy_xx_flush;                     
output  [4 :0]  fdsu_fpu_debug_info;                 
output          fdsu_fpu_ex1_cmplt;                  
output          fdsu_fpu_ex1_cmplt_dp;               
output  [4 :0]  fdsu_fpu_ex1_fflags;                 
output  [7 :0]  fdsu_fpu_ex1_special_sel;            
output  [3 :0]  fdsu_fpu_ex1_special_sign;           
output          fdsu_fpu_ex1_stall;                  
output          fdsu_fpu_no_op;                      
output  [31:0]  fdsu_frbus_data;                     
output  [4 :0]  fdsu_frbus_fflags;                   
output  [4 :0]  fdsu_frbus_freg;                     
output          fdsu_frbus_wb_vld;                   

// &Regs; @25

// &Wires; @26
wire            cp0_fpu_icg_en;                      
wire            cp0_fpu_xx_dqnan;                    
wire            cp0_yy_clk_en;                       
wire            cpurst_b;                            
wire            ctrl_fdsu_ex1_sel;                   
wire            ctrl_xx_ex1_cmplt_dp;                
wire            ctrl_xx_ex1_inst_vld;                
wire            ctrl_xx_ex1_stall;                   
wire            ctrl_xx_ex1_warm_up;                 
wire            ctrl_xx_ex2_warm_up;                 
wire            ctrl_xx_ex3_warm_up;                 
wire    [2 :0]  dp_xx_ex1_cnan;                      
wire    [2 :0]  dp_xx_ex1_id;                        
wire    [2 :0]  dp_xx_ex1_inf;                       
wire    [2 :0]  dp_xx_ex1_qnan;                      
wire    [2 :0]  dp_xx_ex1_rm;                        
wire    [2 :0]  dp_xx_ex1_snan;                      
wire    [2 :0]  dp_xx_ex1_zero;                      
wire            ex1_div;                             
wire    [23:0]  ex1_divisor;                         
wire    [12:0]  ex1_expnt_adder_op0;                 
wire    [12:0]  ex1_expnt_adder_op1;                 
wire            ex1_of_result_lfn;                   
wire            ex1_op0_id;                          
wire            ex1_op0_norm;                        
wire            ex1_op0_sign;                        
wire            ex1_op1_id;                          
wire            ex1_op1_id_vld;                      
wire            ex1_op1_norm;                        
wire            ex1_op1_sel;                         
wire    [12:0]  ex1_oper_id_expnt;                   
wire    [12:0]  ex1_oper_id_expnt_f;                 
wire    [51:0]  ex1_oper_id_frac;                    
wire    [51:0]  ex1_oper_id_frac_f;                  
wire            ex1_pipedown;                        
wire            ex1_pipedown_gate;                   
wire    [31:0]  ex1_remainder;                       
wire            ex1_result_sign;                     
wire    [2 :0]  ex1_rm;                              
wire            ex1_save_op0;                        
wire            ex1_save_op0_gate;                   
wire            ex1_sqrt;                            
wire            ex1_srt_skip;                        
wire    [9 :0]  ex2_expnt_adder_op0;                 
wire            ex2_of;                              
wire            ex2_pipe_clk;                        
wire            ex2_pipedown;                        
wire            ex2_potnt_of;                        
wire            ex2_potnt_uf;                        
wire            ex2_result_inf;                      
wire            ex2_result_lfn;                      
wire            ex2_rslt_denorm;                     
wire    [9 :0]  ex2_srt_expnt_rst;                   
wire            ex2_srt_first_round;                 
wire            ex2_uf;                              
wire            ex2_uf_srt_skip;                     
wire    [9 :0]  ex3_expnt_adjust_result;             
wire    [25:0]  ex3_frac_final_rst;                  
wire            ex3_pipedown;                        
wire            ex3_rslt_denorm;                     
wire            fdsu_ex1_sel;                        
wire            fdsu_ex3_id_srt_skip;                
wire            fdsu_ex3_rem_sign;                   
wire            fdsu_ex3_rem_zero;                   
wire    [23:0]  fdsu_ex3_result_denorm_round_add_num; 
wire            fdsu_ex4_denorm_to_tiny_frac;        
wire    [25:0]  fdsu_ex4_frac;                       
wire            fdsu_ex4_nx;                         
wire    [1 :0]  fdsu_ex4_potnt_norm;                 
wire            fdsu_ex4_result_nor;                 
wire    [4 :0]  fdsu_fpu_debug_info;                 
wire            fdsu_fpu_ex1_cmplt;                  
wire            fdsu_fpu_ex1_cmplt_dp;               
wire    [4 :0]  fdsu_fpu_ex1_fflags;                 
wire    [7 :0]  fdsu_fpu_ex1_special_sel;            
wire    [3 :0]  fdsu_fpu_ex1_special_sign;           
wire            fdsu_fpu_ex1_stall;                  
wire            fdsu_fpu_no_op;                      
wire    [31:0]  fdsu_frbus_data;                     
wire    [4 :0]  fdsu_frbus_fflags;                   
wire    [4 :0]  fdsu_frbus_freg;                     
wire            fdsu_frbus_wb_vld;                   
wire            fdsu_yy_div;                         
wire    [9 :0]  fdsu_yy_expnt_rst;                   
wire            fdsu_yy_of;                          
wire            fdsu_yy_of_rm_lfn;                   
wire            fdsu_yy_op0_norm;                    
wire            fdsu_yy_op1_norm;                    
wire            fdsu_yy_potnt_of;                    
wire            fdsu_yy_potnt_uf;                    
wire            fdsu_yy_result_inf;                  
wire            fdsu_yy_result_lfn;                  
wire            fdsu_yy_result_sign;                 
wire    [2 :0]  fdsu_yy_rm;                          
wire            fdsu_yy_rslt_denorm;                 
wire            fdsu_yy_sqrt;                        
wire            fdsu_yy_uf;                          
wire    [4 :0]  fdsu_yy_wb_freg;                     
wire            forever_cpuclk;                      
wire            frbus_fdsu_wb_grant;                 
wire    [4 :0]  idu_fpu_ex1_dst_freg;                
wire    [2 :0]  idu_fpu_ex1_eu_sel;                  
wire    [9 :0]  idu_fpu_ex1_func;                    
wire    [31:0]  idu_fpu_ex1_srcf0;                   
wire    [31:0]  idu_fpu_ex1_srcf1;                   
wire            pad_yy_icg_scan_en;                  
wire            rtu_xx_ex1_cancel;                   
wire            rtu_xx_ex2_cancel;                   
wire            rtu_yy_xx_async_flush;               
wire            rtu_yy_xx_flush;                     
wire            srt_remainder_zero;                  
wire            srt_sm_on;                           
wire    [29:0]  total_qt_rt_30;                      



// &Instance("pa_fdsu_special"); @29
pa_fdsu_special  x_pa_fdsu_special (
  .cp0_fpu_xx_dqnan          (cp0_fpu_xx_dqnan         ),
  .dp_xx_ex1_cnan            (dp_xx_ex1_cnan           ),
  .dp_xx_ex1_id              (dp_xx_ex1_id             ),
  .dp_xx_ex1_inf             (dp_xx_ex1_inf            ),
  .dp_xx_ex1_qnan            (dp_xx_ex1_qnan           ),
  .dp_xx_ex1_snan            (dp_xx_ex1_snan           ),
  .dp_xx_ex1_zero            (dp_xx_ex1_zero           ),
  .ex1_div                   (ex1_div                  ),
  .ex1_op0_id                (ex1_op0_id               ),
  .ex1_op0_norm              (ex1_op0_norm             ),
  .ex1_op0_sign              (ex1_op0_sign             ),
  .ex1_op1_id                (ex1_op1_id               ),
  .ex1_op1_norm              (ex1_op1_norm             ),
  .ex1_result_sign           (ex1_result_sign          ),
  .ex1_sqrt                  (ex1_sqrt                 ),
  .ex1_srt_skip              (ex1_srt_skip             ),
  .fdsu_fpu_ex1_fflags       (fdsu_fpu_ex1_fflags      ),
  .fdsu_fpu_ex1_special_sel  (fdsu_fpu_ex1_special_sel ),
  .fdsu_fpu_ex1_special_sign (fdsu_fpu_ex1_special_sign)
);

// &Instance("pa_fdsu_prepare"); @30
pa_fdsu_prepare  x_pa_fdsu_prepare (
  .dp_xx_ex1_rm        (dp_xx_ex1_rm       ),
  .ex1_div             (ex1_div            ),
  .ex1_divisor         (ex1_divisor        ),
  .ex1_expnt_adder_op0 (ex1_expnt_adder_op0),
  .ex1_expnt_adder_op1 (ex1_expnt_adder_op1),
  .ex1_of_result_lfn   (ex1_of_result_lfn  ),
  .ex1_op0_id          (ex1_op0_id         ),
  .ex1_op0_sign        (ex1_op0_sign       ),
  .ex1_op1_id          (ex1_op1_id         ),
  .ex1_op1_id_vld      (ex1_op1_id_vld     ),
  .ex1_op1_sel         (ex1_op1_sel        ),
  .ex1_oper_id_expnt   (ex1_oper_id_expnt  ),
  .ex1_oper_id_expnt_f (ex1_oper_id_expnt_f),
  .ex1_oper_id_frac    (ex1_oper_id_frac   ),
  .ex1_oper_id_frac_f  (ex1_oper_id_frac_f ),
  .ex1_remainder       (ex1_remainder      ),
  .ex1_result_sign     (ex1_result_sign    ),
  .ex1_rm              (ex1_rm             ),
  .ex1_sqrt            (ex1_sqrt           ),
  .fdsu_ex1_sel        (fdsu_ex1_sel       ),
  .idu_fpu_ex1_func    (idu_fpu_ex1_func   ),
  .idu_fpu_ex1_srcf0   (idu_fpu_ex1_srcf0  ),
  .idu_fpu_ex1_srcf1   (idu_fpu_ex1_srcf1  )
);

// &Instance("pa_fdsu_srt"); @32
// &Instance("pa_fdsu_round"); @33
// &Instance("pa_fdsu_pack"); @34
// &Instance("pa_fdsu_srt_single", "x_pa_fdsu_srt"); @36
pa_fdsu_srt_single  x_pa_fdsu_srt (
  .cp0_fpu_icg_en                       (cp0_fpu_icg_en                      ),
  .cp0_yy_clk_en                        (cp0_yy_clk_en                       ),
  .ex1_divisor                          (ex1_divisor                         ),
  .ex1_expnt_adder_op1                  (ex1_expnt_adder_op1                 ),
  .ex1_oper_id_frac                     (ex1_oper_id_frac                    ),
  .ex1_oper_id_frac_f                   (ex1_oper_id_frac_f                  ),
  .ex1_pipedown                         (ex1_pipedown                        ),
  .ex1_pipedown_gate                    (ex1_pipedown_gate                   ),
  .ex1_remainder                        (ex1_remainder                       ),
  .ex1_save_op0                         (ex1_save_op0                        ),
  .ex1_save_op0_gate                    (ex1_save_op0_gate                   ),
  .ex2_expnt_adder_op0                  (ex2_expnt_adder_op0                 ),
  .ex2_of                               (ex2_of                              ),
  .ex2_pipe_clk                         (ex2_pipe_clk                        ),
  .ex2_pipedown                         (ex2_pipedown                        ),
  .ex2_potnt_of                         (ex2_potnt_of                        ),
  .ex2_potnt_uf                         (ex2_potnt_uf                        ),
  .ex2_result_inf                       (ex2_result_inf                      ),
  .ex2_result_lfn                       (ex2_result_lfn                      ),
  .ex2_rslt_denorm                      (ex2_rslt_denorm                     ),
  .ex2_srt_expnt_rst                    (ex2_srt_expnt_rst                   ),
  .ex2_srt_first_round                  (ex2_srt_first_round                 ),
  .ex2_uf                               (ex2_uf                              ),
  .ex2_uf_srt_skip                      (ex2_uf_srt_skip                     ),
  .ex3_frac_final_rst                   (ex3_frac_final_rst                  ),
  .ex3_pipedown                         (ex3_pipedown                        ),
  .fdsu_ex3_id_srt_skip                 (fdsu_ex3_id_srt_skip                ),
  .fdsu_ex3_rem_sign                    (fdsu_ex3_rem_sign                   ),
  .fdsu_ex3_rem_zero                    (fdsu_ex3_rem_zero                   ),
  .fdsu_ex3_result_denorm_round_add_num (fdsu_ex3_result_denorm_round_add_num),
  .fdsu_ex4_frac                        (fdsu_ex4_frac                       ),
  .fdsu_yy_div                          (fdsu_yy_div                         ),
  .fdsu_yy_of_rm_lfn                    (fdsu_yy_of_rm_lfn                   ),
  .fdsu_yy_op0_norm                     (fdsu_yy_op0_norm                    ),
  .fdsu_yy_op1_norm                     (fdsu_yy_op1_norm                    ),
  .fdsu_yy_sqrt                         (fdsu_yy_sqrt                        ),
  .forever_cpuclk                       (forever_cpuclk                      ),
  .pad_yy_icg_scan_en                   (pad_yy_icg_scan_en                  ),
  .srt_remainder_zero                   (srt_remainder_zero                  ),
  .srt_sm_on                            (srt_sm_on                           ),
  .total_qt_rt_30                       (total_qt_rt_30                      )
);

// &Instance("pa_fdsu_round_single", "x_pa_fdsu_round"); @37
pa_fdsu_round_single  x_pa_fdsu_round (
  .cp0_fpu_icg_en                       (cp0_fpu_icg_en                      ),
  .cp0_yy_clk_en                        (cp0_yy_clk_en                       ),
  .ex3_expnt_adjust_result              (ex3_expnt_adjust_result             ),
  .ex3_frac_final_rst                   (ex3_frac_final_rst                  ),
  .ex3_pipedown                         (ex3_pipedown                        ),
  .ex3_rslt_denorm                      (ex3_rslt_denorm                     ),
  .fdsu_ex3_id_srt_skip                 (fdsu_ex3_id_srt_skip                ),
  .fdsu_ex3_rem_sign                    (fdsu_ex3_rem_sign                   ),
  .fdsu_ex3_rem_zero                    (fdsu_ex3_rem_zero                   ),
  .fdsu_ex3_result_denorm_round_add_num (fdsu_ex3_result_denorm_round_add_num),
  .fdsu_ex4_denorm_to_tiny_frac         (fdsu_ex4_denorm_to_tiny_frac        ),
  .fdsu_ex4_nx                          (fdsu_ex4_nx                         ),
  .fdsu_ex4_potnt_norm                  (fdsu_ex4_potnt_norm                 ),
  .fdsu_ex4_result_nor                  (fdsu_ex4_result_nor                 ),
  .fdsu_yy_expnt_rst                    (fdsu_yy_expnt_rst                   ),
  .fdsu_yy_result_inf                   (fdsu_yy_result_inf                  ),
  .fdsu_yy_result_lfn                   (fdsu_yy_result_lfn                  ),
  .fdsu_yy_result_sign                  (fdsu_yy_result_sign                 ),
  .fdsu_yy_rm                           (fdsu_yy_rm                          ),
  .fdsu_yy_rslt_denorm                  (fdsu_yy_rslt_denorm                 ),
  .forever_cpuclk                       (forever_cpuclk                      ),
  .pad_yy_icg_scan_en                   (pad_yy_icg_scan_en                  ),
  .total_qt_rt_30                       (total_qt_rt_30                      )
);

// &Instance("pa_fdsu_pack_single", "x_pa_fdsu_pack"); @38
pa_fdsu_pack_single  x_pa_fdsu_pack (
  .fdsu_ex4_denorm_to_tiny_frac (fdsu_ex4_denorm_to_tiny_frac),
  .fdsu_ex4_frac                (fdsu_ex4_frac               ),
  .fdsu_ex4_nx                  (fdsu_ex4_nx                 ),
  .fdsu_ex4_potnt_norm          (fdsu_ex4_potnt_norm         ),
  .fdsu_ex4_result_nor          (fdsu_ex4_result_nor         ),
  .fdsu_frbus_data              (fdsu_frbus_data             ),
  .fdsu_frbus_fflags            (fdsu_frbus_fflags           ),
  .fdsu_frbus_freg              (fdsu_frbus_freg             ),
  .fdsu_yy_expnt_rst            (fdsu_yy_expnt_rst           ),
  .fdsu_yy_of                   (fdsu_yy_of                  ),
  .fdsu_yy_of_rm_lfn            (fdsu_yy_of_rm_lfn           ),
  .fdsu_yy_potnt_of             (fdsu_yy_potnt_of            ),
  .fdsu_yy_potnt_uf             (fdsu_yy_potnt_uf            ),
  .fdsu_yy_result_inf           (fdsu_yy_result_inf          ),
  .fdsu_yy_result_lfn           (fdsu_yy_result_lfn          ),
  .fdsu_yy_result_sign          (fdsu_yy_result_sign         ),
  .fdsu_yy_rslt_denorm          (fdsu_yy_rslt_denorm         ),
  .fdsu_yy_uf                   (fdsu_yy_uf                  ),
  .fdsu_yy_wb_freg              (fdsu_yy_wb_freg             )
);


// &Instance("pa_fdsu_ctrl"); @41
pa_fdsu_ctrl  x_pa_fdsu_ctrl (
  .cp0_fpu_icg_en          (cp0_fpu_icg_en         ),
  .cp0_yy_clk_en           (cp0_yy_clk_en          ),
  .cpurst_b                (cpurst_b               ),
  .ctrl_fdsu_ex1_sel       (ctrl_fdsu_ex1_sel      ),
  .ctrl_xx_ex1_cmplt_dp    (ctrl_xx_ex1_cmplt_dp   ),
  .ctrl_xx_ex1_inst_vld    (ctrl_xx_ex1_inst_vld   ),
  .ctrl_xx_ex1_stall       (ctrl_xx_ex1_stall      ),
  .ctrl_xx_ex1_warm_up     (ctrl_xx_ex1_warm_up    ),
  .ctrl_xx_ex2_warm_up     (ctrl_xx_ex2_warm_up    ),
  .ctrl_xx_ex3_warm_up     (ctrl_xx_ex3_warm_up    ),
  .ex1_div                 (ex1_div                ),
  .ex1_expnt_adder_op0     (ex1_expnt_adder_op0    ),
  .ex1_of_result_lfn       (ex1_of_result_lfn      ),
  .ex1_op0_id              (ex1_op0_id             ),
  .ex1_op0_norm            (ex1_op0_norm           ),
  .ex1_op1_id_vld          (ex1_op1_id_vld         ),
  .ex1_op1_norm            (ex1_op1_norm           ),
  .ex1_op1_sel             (ex1_op1_sel            ),
  .ex1_oper_id_expnt       (ex1_oper_id_expnt      ),
  .ex1_oper_id_expnt_f     (ex1_oper_id_expnt_f    ),
  .ex1_pipedown            (ex1_pipedown           ),
  .ex1_pipedown_gate       (ex1_pipedown_gate      ),
  .ex1_result_sign         (ex1_result_sign        ),
  .ex1_rm                  (ex1_rm                 ),
  .ex1_save_op0            (ex1_save_op0           ),
  .ex1_save_op0_gate       (ex1_save_op0_gate      ),
  .ex1_sqrt                (ex1_sqrt               ),
  .ex1_srt_skip            (ex1_srt_skip           ),
  .ex2_expnt_adder_op0     (ex2_expnt_adder_op0    ),
  .ex2_of                  (ex2_of                 ),
  .ex2_pipe_clk            (ex2_pipe_clk           ),
  .ex2_pipedown            (ex2_pipedown           ),
  .ex2_potnt_of            (ex2_potnt_of           ),
  .ex2_potnt_uf            (ex2_potnt_uf           ),
  .ex2_result_inf          (ex2_result_inf         ),
  .ex2_result_lfn          (ex2_result_lfn         ),
  .ex2_rslt_denorm         (ex2_rslt_denorm        ),
  .ex2_srt_expnt_rst       (ex2_srt_expnt_rst      ),
  .ex2_srt_first_round     (ex2_srt_first_round    ),
  .ex2_uf                  (ex2_uf                 ),
  .ex2_uf_srt_skip         (ex2_uf_srt_skip        ),
  .ex3_expnt_adjust_result (ex3_expnt_adjust_result),
  .ex3_pipedown            (ex3_pipedown           ),
  .ex3_rslt_denorm         (ex3_rslt_denorm        ),
  .fdsu_ex1_sel            (fdsu_ex1_sel           ),
  .fdsu_fpu_debug_info     (fdsu_fpu_debug_info    ),
  .fdsu_fpu_ex1_cmplt      (fdsu_fpu_ex1_cmplt     ),
  .fdsu_fpu_ex1_cmplt_dp   (fdsu_fpu_ex1_cmplt_dp  ),
  .fdsu_fpu_ex1_stall      (fdsu_fpu_ex1_stall     ),
  .fdsu_fpu_no_op          (fdsu_fpu_no_op         ),
  .fdsu_frbus_wb_vld       (fdsu_frbus_wb_vld      ),
  .fdsu_yy_div             (fdsu_yy_div            ),
  .fdsu_yy_expnt_rst       (fdsu_yy_expnt_rst      ),
  .fdsu_yy_of              (fdsu_yy_of             ),
  .fdsu_yy_of_rm_lfn       (fdsu_yy_of_rm_lfn      ),
  .fdsu_yy_op0_norm        (fdsu_yy_op0_norm       ),
  .fdsu_yy_op1_norm        (fdsu_yy_op1_norm       ),
  .fdsu_yy_potnt_of        (fdsu_yy_potnt_of       ),
  .fdsu_yy_potnt_uf        (fdsu_yy_potnt_uf       ),
  .fdsu_yy_result_inf      (fdsu_yy_result_inf     ),
  .fdsu_yy_result_lfn      (fdsu_yy_result_lfn     ),
  .fdsu_yy_result_sign     (fdsu_yy_result_sign    ),
  .fdsu_yy_rm              (fdsu_yy_rm             ),
  .fdsu_yy_rslt_denorm     (fdsu_yy_rslt_denorm    ),
  .fdsu_yy_sqrt            (fdsu_yy_sqrt           ),
  .fdsu_yy_uf              (fdsu_yy_uf             ),
  .fdsu_yy_wb_freg         (fdsu_yy_wb_freg        ),
  .forever_cpuclk          (forever_cpuclk         ),
  .frbus_fdsu_wb_grant     (frbus_fdsu_wb_grant    ),
  .idu_fpu_ex1_dst_freg    (idu_fpu_ex1_dst_freg   ),
  .idu_fpu_ex1_eu_sel      (idu_fpu_ex1_eu_sel     ),
  .pad_yy_icg_scan_en      (pad_yy_icg_scan_en     ),
  .rtu_xx_ex1_cancel       (rtu_xx_ex1_cancel      ),
  .rtu_xx_ex2_cancel       (rtu_xx_ex2_cancel      ),
  .rtu_yy_xx_async_flush   (rtu_yy_xx_async_flush  ),
  .rtu_yy_xx_flush         (rtu_yy_xx_flush        ),
  .srt_remainder_zero      (srt_remainder_zero     ),
  .srt_sm_on               (srt_sm_on              )
);



// &ModuleEnd; @44
endmodule


// ----- 8< ----- FILE "./pa_fpu_dp.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

module pa_fpu_dp(
  cp0_fpu_icg_en,
  cp0_fpu_xx_rm,
  cp0_yy_clk_en,
  ctrl_xx_ex1_inst_vld,
  ctrl_xx_ex1_stall,
  ctrl_xx_ex1_warm_up,
  dp_frbus_ex2_data,
  dp_frbus_ex2_fflags,
  dp_xx_ex1_cnan,
  dp_xx_ex1_id,
  dp_xx_ex1_inf,
  dp_xx_ex1_norm,
  dp_xx_ex1_qnan,
  dp_xx_ex1_snan,
  dp_xx_ex1_zero,
  ex2_inst_wb,
  fdsu_fpu_ex1_fflags,
  fdsu_fpu_ex1_special_sel,
  fdsu_fpu_ex1_special_sign,
  forever_cpuclk,
  idu_fpu_ex1_eu_sel,
  idu_fpu_ex1_func,
  idu_fpu_ex1_gateclk_vld,
  idu_fpu_ex1_rm,
  idu_fpu_ex1_srcf0,
  idu_fpu_ex1_srcf1,
  idu_fpu_ex1_srcf2,
  pad_yy_icg_scan_en
);

input           cp0_fpu_icg_en;             
input   [2 :0]  cp0_fpu_xx_rm;              
input           cp0_yy_clk_en;              
input           ctrl_xx_ex1_inst_vld;       
input           ctrl_xx_ex1_stall;          
input           ctrl_xx_ex1_warm_up;
input   [4 :0]  fdsu_fpu_ex1_fflags;        
input   [7 :0]  fdsu_fpu_ex1_special_sel;   
input   [3 :0]  fdsu_fpu_ex1_special_sign;
input           forever_cpuclk;
input   [2 :0]  idu_fpu_ex1_eu_sel;         
input   [9 :0]  idu_fpu_ex1_func;           
input           idu_fpu_ex1_gateclk_vld;    
input   [2 :0]  idu_fpu_ex1_rm;             
input   [31:0]  idu_fpu_ex1_srcf0;          
input   [31:0]  idu_fpu_ex1_srcf1;          
input   [31:0]  idu_fpu_ex1_srcf2;          
input           pad_yy_icg_scan_en;         
output  [31:0]  dp_frbus_ex2_data;          
output  [4 :0]  dp_frbus_ex2_fflags;
output  [2 :0]  dp_xx_ex1_cnan;             
output  [2 :0]  dp_xx_ex1_id;               
output  [2 :0]  dp_xx_ex1_inf;              
output  [2 :0]  dp_xx_ex1_norm;             
output  [2 :0]  dp_xx_ex1_qnan;
output  [2 :0]  dp_xx_ex1_snan;
output  [2 :0]  dp_xx_ex1_zero;
output          ex2_inst_wb;                

reg     [4 :0]  ex1_fflags;                 
reg     [31:0]  ex1_special_data;           
reg     [8 :0]  ex1_special_sel;            
reg     [3 :0]  ex1_special_sign;           
reg     [4 :0]  ex2_fflags;
reg     [31:0]  ex2_result;
reg     [31:0]  ex2_special_data;           
reg     [6 :0]  ex2_special_sel;            
reg     [3 :0]  ex2_special_sign;

wire            cp0_fpu_icg_en;             
wire    [2 :0]  cp0_fpu_xx_rm;              
wire            cp0_yy_clk_en;              
wire            ctrl_xx_ex1_inst_vld;       
wire            ctrl_xx_ex1_stall;          
wire            ctrl_xx_ex1_warm_up;
wire    [31:0]  dp_frbus_ex2_data;          
wire    [4 :0]  dp_frbus_ex2_fflags;
wire    [2 :0]  dp_xx_ex1_cnan;             
wire    [2 :0]  dp_xx_ex1_id;               
wire    [2 :0]  dp_xx_ex1_inf;              
wire    [2 :0]  dp_xx_ex1_norm;             
wire    [2 :0]  dp_xx_ex1_qnan;
wire    [2 :0]  dp_xx_ex1_snan;
wire    [2 :0]  dp_xx_ex1_zero;
wire    [2 :0]  ex1_decode_rm;              
wire            ex1_double;                 
wire    [2 :0]  ex1_eu_sel;
wire    [9 :0]  ex1_func;                   
wire    [2 :0]  ex1_global_rm;              
wire    [2 :0]  ex1_rm;                     
wire            ex1_single;                 
wire    [31:0]  ex1_special_data_final;     
wire    [63:0]  ex1_src0;                   
wire    [63:0]  ex1_src1;                   
wire    [63:0]  ex1_src2;                   
wire            ex1_src2_vld;               
wire    [2 :0]  ex1_src_cnan;               
wire    [2 :0]  ex1_src_id;                 
wire    [2 :0]  ex1_src_inf;                
wire    [2 :0]  ex1_src_norm;               
wire    [2 :0]  ex1_src_qnan;               
wire    [2 :0]  ex1_src_snan;               
wire    [2 :0]  ex1_src_zero;               
wire            ex2_data_clk;               
wire            ex2_data_clk_en;            
wire            ex2_inst_wb;
wire    [4 :0]  fdsu_fpu_ex1_fflags;        
wire    [7 :0]  fdsu_fpu_ex1_special_sel;   
wire    [3 :0]  fdsu_fpu_ex1_special_sign;
wire            forever_cpuclk;
wire    [2 :0]  idu_fpu_ex1_eu_sel;         
wire    [9 :0]  idu_fpu_ex1_func;           
wire            idu_fpu_ex1_gateclk_vld;    
wire    [2 :0]  idu_fpu_ex1_rm;             
wire    [31:0]  idu_fpu_ex1_srcf0;          
wire    [31:0]  idu_fpu_ex1_srcf1;          
wire    [31:0]  idu_fpu_ex1_srcf2;          
wire            pad_yy_icg_scan_en;         


parameter DOUBLE_WIDTH =64;
parameter SINGLE_WIDTH =32;
parameter FUNC_WIDTH   =10;
//==========================================================
//                     EX1 special data path
//==========================================================
assign ex1_eu_sel[2:0]            = idu_fpu_ex1_eu_sel[2:0];  //3'h4
assign ex1_func[FUNC_WIDTH-1:0]   = idu_fpu_ex1_func[FUNC_WIDTH-1:0];
assign ex1_global_rm[2:0]         = cp0_fpu_xx_rm[2:0];
assign ex1_decode_rm[2:0]         = idu_fpu_ex1_rm[2:0];

assign ex1_rm[2:0]                = (ex1_decode_rm[2:0]==3'b111) 
                                  ?  ex1_global_rm[2:0] : ex1_decode_rm[2:0]; 

assign ex1_src2_vld               = idu_fpu_ex1_eu_sel[1] && ex1_func[0];

assign ex1_src0[DOUBLE_WIDTH-1:0] = { {SINGLE_WIDTH{1'b1}},idu_fpu_ex1_srcf0[SINGLE_WIDTH-1:0]};
assign ex1_src1[DOUBLE_WIDTH-1:0] = { {SINGLE_WIDTH{1'b1}},idu_fpu_ex1_srcf1[SINGLE_WIDTH-1:0]};
assign ex1_src2[DOUBLE_WIDTH-1:0] = ex1_src2_vld ? { {SINGLE_WIDTH{1'b1}},idu_fpu_ex1_srcf2[SINGLE_WIDTH-1:0]}
                                                 : { {SINGLE_WIDTH{1'b1}},{SINGLE_WIDTH{1'b0}} };

assign ex1_double = 1'b0;
assign ex1_single = 1'b1;

//==========================================================
//                EX1 special src data judge
//==========================================================
pa_fpu_src_type  x_pa_fpu_ex1_srcf0_type (
  .inst_double     (ex1_double     ),
  .inst_single     (ex1_single     ),
  .src_cnan        (ex1_src_cnan[0]),
  .src_id          (ex1_src_id[0]  ),
  .src_in          (ex1_src0       ),
  .src_inf         (ex1_src_inf[0] ),
  .src_norm        (ex1_src_norm[0]),
  .src_qnan        (ex1_src_qnan[0]),
  .src_snan        (ex1_src_snan[0]),
  .src_zero        (ex1_src_zero[0])
);

pa_fpu_src_type  x_pa_fpu_ex1_srcf1_type (
  .inst_double     (ex1_double     ),
  .inst_single     (ex1_single     ),
  .src_cnan        (ex1_src_cnan[1]),
  .src_id          (ex1_src_id[1]  ),
  .src_in          (ex1_src1       ),
  .src_inf         (ex1_src_inf[1] ),
  .src_norm        (ex1_src_norm[1]),
  .src_qnan        (ex1_src_qnan[1]),
  .src_snan        (ex1_src_snan[1]),
  .src_zero        (ex1_src_zero[1])
);

pa_fpu_src_type  x_pa_fpu_ex1_srcf2_type (
  .inst_double     (ex1_double     ),
  .inst_single     (ex1_single     ),
  .src_cnan        (ex1_src_cnan[2]),
  .src_id          (ex1_src_id[2]  ),
  .src_in          (ex1_src2       ),
  .src_inf         (ex1_src_inf[2] ),
  .src_norm        (ex1_src_norm[2]),
  .src_qnan        (ex1_src_qnan[2]),
  .src_snan        (ex1_src_snan[2]),
  .src_zero        (ex1_src_zero[2])
);

assign dp_xx_ex1_cnan[2:0] = ex1_src_cnan[2:0];
assign dp_xx_ex1_snan[2:0] = ex1_src_snan[2:0];
assign dp_xx_ex1_qnan[2:0] = ex1_src_qnan[2:0];
assign dp_xx_ex1_norm[2:0] = ex1_src_norm[2:0];
assign dp_xx_ex1_zero[2:0] = ex1_src_zero[2:0];
assign dp_xx_ex1_inf[2:0]  = ex1_src_inf[2:0];
assign dp_xx_ex1_id[2:0]   = ex1_src_id[2:0];

//==========================================================
//                EX1 special result judge
//==========================================================

always @( fdsu_fpu_ex1_special_sign[3:0]
       or fdsu_fpu_ex1_fflags[4:0]
       or ex1_eu_sel[2:0]
       or fdsu_fpu_ex1_special_sel[7:0])
begin
case(ex1_eu_sel[2:0])  //3'h4
   3'b100: begin//FDSU
         ex1_fflags[4:0]       = fdsu_fpu_ex1_fflags[4:0];
         ex1_special_sel[8:0]  ={1'b0,fdsu_fpu_ex1_special_sel[7:0]};
         ex1_special_sign[3:0] = fdsu_fpu_ex1_special_sign[3:0];
         end
default: begin//FDSU
         ex1_fflags[4:0]       = {5{1'b0}};
         ex1_special_sel[8:0]  = {9{1'b0}};
         ex1_special_sign[3:0] = {4{1'b0}};
         end
endcase
end

always @( ex1_special_sel[8:5]
       or ex1_src0[31:0]
       or ex1_src1[31:0]
       or ex1_src2[31:0])
begin
case(ex1_special_sel[8:5])
  4'b0001: ex1_special_data[SINGLE_WIDTH-1:0] = ex1_src0[SINGLE_WIDTH-1:0];
  4'b0010: ex1_special_data[SINGLE_WIDTH-1:0] = ex1_src1[SINGLE_WIDTH-1:0];
  4'b0100: ex1_special_data[SINGLE_WIDTH-1:0] = ex1_src2[SINGLE_WIDTH-1:0];
default  : ex1_special_data[SINGLE_WIDTH-1:0] = ex1_src2[SINGLE_WIDTH-1:0];
endcase
end

assign ex1_special_data_final[SINGLE_WIDTH-1:0] = ex1_special_data[SINGLE_WIDTH-1:0];

//==========================================================
//                     EX1-EX2 data pipedown
//==========================================================
assign ex2_data_clk_en = idu_fpu_ex1_gateclk_vld || ctrl_xx_ex1_warm_up;

gated_clk_cell  x_fpu_data_ex2_gated_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (ex2_data_clk      ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (ex2_data_clk_en   ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

always @(posedge ex2_data_clk)
begin
  if(ctrl_xx_ex1_inst_vld && !ctrl_xx_ex1_stall || ctrl_xx_ex1_warm_up)
  begin
    ex2_fflags[4:0]       <= ex1_fflags[4:0];
    ex2_special_sign[3:0] <= ex1_special_sign[3:0];
    ex2_special_sel[6:0]  <={ex1_special_sel[8],|ex1_special_sel[7:5],ex1_special_sel[4:0]};
    ex2_special_data[SINGLE_WIDTH-1:0] <= ex1_special_data_final[SINGLE_WIDTH-1:0];
  end
end

assign ex2_inst_wb = (|ex2_special_sel[6:0]);

always @( ex2_special_sel[6:0]
       or ex2_special_data[31:0]
       or ex2_special_sign[3:0])
begin
case(ex2_special_sel[6:0])
  7'b0000_001: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_sign[0],ex2_special_data[SINGLE_WIDTH-2:0]};//src2
  7'b0000_010: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_sign[1], {31{1'b0}} };//zero
  7'b0000_100: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_sign[2], {8{1'b1}},{23{1'b0}} };//inf
  7'b0001_000: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_sign[3], {7{1'b1}},1'b0,{23{1'b1}} };//lfn
  7'b0010_000: ex2_result[SINGLE_WIDTH-1:0]  = { 1'b0, {8{1'b1}},1'b1, {22{1'b0}} };//cnan
  7'b0100_000: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_data[31],{8{1'b1}}, 1'b1, ex2_special_data[21:0]};//propagate qnan
  7'b1000_000: ex2_result[SINGLE_WIDTH-1:0]  = ex2_special_data[SINGLE_WIDTH-1:0]; //ex1 falu special result
      default: ex2_result[SINGLE_WIDTH-1:0]  = {SINGLE_WIDTH{1'b0}};
endcase
end

assign dp_frbus_ex2_data[SINGLE_WIDTH-1:0]  = ex2_result[SINGLE_WIDTH-1:0];
assign dp_frbus_ex2_fflags[4:0] = ex2_fflags[4:0];

endmodule



// ----- 8< ----- FILE "./pa_fpu_frbus.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

module pa_fpu_frbus(
  ctrl_frbus_ex2_wb_req,
  dp_frbus_ex2_data,
  dp_frbus_ex2_fflags,
  fdsu_frbus_data,
  fdsu_frbus_fflags,
  fdsu_frbus_wb_vld,
  fpu_idu_fwd_data,
  fpu_idu_fwd_fflags,
  fpu_idu_fwd_vld
);

input           ctrl_frbus_ex2_wb_req;
input   [31:0]  dp_frbus_ex2_data;        
input   [4 :0]  dp_frbus_ex2_fflags;
input   [31:0]  fdsu_frbus_data;          
input   [4 :0]  fdsu_frbus_fflags;
input           fdsu_frbus_wb_vld;
output  [31:0]  fpu_idu_fwd_data;
output  [4 :0]  fpu_idu_fwd_fflags;
output          fpu_idu_fwd_vld;

reg     [31:0]  frbus_wb_data;            
reg     [4 :0]  frbus_wb_fflags;

wire            ctrl_frbus_ex2_wb_req;
wire    [31:0]  fdsu_frbus_data;          
wire    [4 :0]  fdsu_frbus_fflags;
wire            fdsu_frbus_wb_vld;
wire    [31:0]  fpu_idu_fwd_data;
wire    [4 :0]  fpu_idu_fwd_fflags;
wire            fpu_idu_fwd_vld;
wire            frbus_ex2_wb_vld;
wire            frbus_fdsu_wb_vld;
wire            frbus_wb_vld;
wire    [3 :0]  frbus_source_vld;


//==========================================================
//                   Input Signal Rename
//==========================================================
assign frbus_fdsu_wb_vld = fdsu_frbus_wb_vld;
assign frbus_ex2_wb_vld  = ctrl_frbus_ex2_wb_req;
assign frbus_source_vld[3:0]     = {1'b0, 1'b0, frbus_ex2_wb_vld, frbus_fdsu_wb_vld};
assign frbus_wb_vld = frbus_ex2_wb_vld | frbus_fdsu_wb_vld;

always @( frbus_source_vld[3:0]
       or fdsu_frbus_data[31:0]
       or dp_frbus_ex2_data[31:0]
       or fdsu_frbus_fflags[4:0]
       or dp_frbus_ex2_fflags[4:0])
begin
  case(frbus_source_vld[3:0])
    4'b0001: begin // DIV
      frbus_wb_data[31:0] = fdsu_frbus_data[31:0];
      frbus_wb_fflags[4:0]    = fdsu_frbus_fflags[4:0];
    end
    4'b0010: begin // EX2
      frbus_wb_data[31:0] = dp_frbus_ex2_data[31:0];
      frbus_wb_fflags[4:0]    = dp_frbus_ex2_fflags[4:0];
    end
    default: begin
      frbus_wb_data[31:0] = {31{1'b0}};
      frbus_wb_fflags[4:0]    = 5'b0;
    end
  endcase
end

assign fpu_idu_fwd_vld            = frbus_wb_vld;
assign fpu_idu_fwd_fflags[4:0]    = frbus_wb_fflags[4:0];
assign fpu_idu_fwd_data[31:0] = frbus_wb_data[31:0];

endmodule


// ----- 8< ----- FILE "./pa_fpu_src_type.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @24
module pa_fpu_src_type(
  inst_double,
  inst_single,
  src_cnan,
  src_id,
  src_in,
  src_inf,
  src_norm,
  src_qnan,
  src_snan,
  src_zero
);

// &Ports; @25
input           inst_double;  
input           inst_single;  
input   [63:0]  src_in;       
output          src_cnan;     
output          src_id;       
output          src_inf;      
output          src_norm;     
output          src_qnan;     
output          src_snan;     
output          src_zero;     

// &Regs; @26

// &Wires; @27
wire            inst_double;  
wire            inst_single;  
wire    [63:0]  src;          
wire            src_cnan;     
wire            src_expn_max; 
wire            src_expn_zero; 
wire            src_frac_msb; 
wire            src_frac_zero; 
wire            src_id;       
wire    [63:0]  src_in;       
wire            src_inf;      
wire            src_norm;     
wire            src_qnan;     
wire            src_snan;     
wire            src_zero;     


// &Depend("cpu_cfig.h"); @29
assign src[63:0] = src_in[63:0];

assign src_cnan  = !(&src[63:32]) && inst_single;

assign src_expn_zero = !(|src[62:52]) && inst_double ||
                       !(|src[30:23]) && inst_single;

assign src_expn_max  =  (&src[62:52]) && inst_double ||
                        (&src[30:23]) && inst_single;

assign src_frac_zero = !(|src[51:0]) && inst_double ||
                       !(|src[22:0]) && inst_single;

assign src_frac_msb  = src[51] && inst_double || src[22] && inst_single;

assign src_snan = src_expn_max  && !src_frac_msb && !src_frac_zero && !src_cnan;
assign src_qnan = src_expn_max  &&  src_frac_msb || src_cnan;
assign src_zero = src_expn_zero &&  src_frac_zero && !src_cnan;
assign src_id   = src_expn_zero && !src_frac_zero && !src_cnan;
assign src_inf  = src_expn_max  &&  src_frac_zero && !src_cnan;
assign src_norm =!(src_expn_zero && src_frac_zero) &&
                 ! src_expn_max  && !src_cnan;

// &Force("output","src_cnan"); @53

// &ModuleEnd; @55
endmodule



// ----- 8< ----- FILE "./fpnew_divsqrt_th_32.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019-2022 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Authors: Stefan Mach <smach@iis.ee.ethz.ch>
//          Luca Bertaccini <lbertaccini@iis.ee.ethz.ch>
//          Jiang Lannan <jiangl@ethz.ch>
//          Kexin Li <likexi@ethz.ch>



module fpnew_divsqrt_th_32 #(
  // FP32-only DivSqrt
  // FPU configuration
  parameter int unsigned             NumPipeRegs = 0,
  parameter fpnew_pkg::pipe_config_t PipeConfig  = fpnew_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH       = 32,
  localparam int unsigned NUM_FORMATS = fpnew_pkg::NUM_FP_FORMATS,
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input  logic                        clk_i,
  input  logic                        rst_ni,
  // Input signals
  input  logic [1:0][WIDTH-1:0]       operands_i, // 2 operands
  input  logic [NUM_FORMATS-1:0][1:0] is_boxed_i, // 2 operands
  input  fpnew_pkg::roundmode_e       rnd_mode_i,
  input  fpnew_pkg::operation_e       op_i,
  input  TagType                      tag_i,
  input  logic                        mask_i,
  input  AuxType                      aux_i,
  // Input Handshake
  input  logic                        in_valid_i,
  output logic                        in_ready_o,
  input  logic                        flush_i,
  // Output signals
  output logic [WIDTH-1:0]            result_o,
  output fpnew_pkg::status_t          status_o,
  output logic                        extension_bit_o,
  output TagType                      tag_o,
  output logic                        mask_o,
  output AuxType                      aux_o,
  // Output handshake
  output logic                        out_valid_o,
  input  logic                        out_ready_i,
  // Indication of valid data in flight
  output logic                        busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0]   reg_ena_i
);

  // ----------
  // Constants
  // ----------
  // Pipelines
  localparam NUM_INP_REGS = (PipeConfig == fpnew_pkg::BEFORE)
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 2) // Last to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = (PipeConfig == fpnew_pkg::AFTER || PipeConfig == fpnew_pkg::INSIDE)
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 2) // First to get distributed regs
                               : 0); // no regs here otherwise

  // ---------------
  // Input pipeline
  // ---------------
  // Selected pipeline output signals as non-arrays
  logic [1:0][WIDTH-1:0] operands_q;
  fpnew_pkg::roundmode_e rnd_mode_q;
  fpnew_pkg::operation_e op_q;
  logic                  in_valid_q;

  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][1:0][WIDTH-1:0]       inp_pipe_operands_q;
  fpnew_pkg::roundmode_e [0:NUM_INP_REGS]                       inp_pipe_rnd_mode_q;
  fpnew_pkg::operation_e [0:NUM_INP_REGS]                       inp_pipe_op_q;
  TagType                [0:NUM_INP_REGS]                       inp_pipe_tag_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_mask_q;
  AuxType                [0:NUM_INP_REGS]                       inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_mask_q[0]     = mask_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, fpnew_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, fpnew_pkg::FMADD)
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign operands_q = inp_pipe_operands_q[NUM_INP_REGS];
  assign rnd_mode_q = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign op_q       = inp_pipe_op_q[NUM_INP_REGS];
  assign in_valid_q = inp_pipe_valid_q[NUM_INP_REGS];

  // ------------
  // Control FSM
  // ------------
  logic in_ready;               // input handshake with upstream
  logic div_op, sqrt_op;        // input signalling with unit
  logic unit_ready_q, unit_done;  // status signals from unit instance
  logic op_starting;            // high in the cycle a new operation starts
  logic out_valid, out_ready;   // output handshake with downstream
  logic hold_result;            // whether to put result into hold register
  logic data_is_held;           // data in hold register is valid
  logic unit_busy;              // valid data in flight
  // FSM states
  typedef enum logic [1:0] {IDLE, BUSY, HOLD, UNREACHABLE} fsm_state_e;
  fsm_state_e state_q, state_d;

  // Operations are gated by the FSM ready. Invalid input ops run a sqrt to not lose illegal instr.
  assign div_op   = in_valid_q & (op_q == fpnew_pkg::DIV) & in_ready & ~flush_i;  //in_ready delete, valid independent of ready
  assign sqrt_op  = in_valid_q & (op_q == fpnew_pkg::SQRT) & in_ready & ~flush_i;
  assign op_starting = div_op | sqrt_op;  //start computing or handshake, modify tb handshake right

  logic fdsu_fpu_ex1_stall, fdsu_fpu_ex1_stall_q;
  logic div_op_d, div_op_q;
  logic sqrt_op_d, sqrt_op_q;

  assign div_op_d  = (fdsu_fpu_ex1_stall) ? div_op  : 1'b0;
  assign sqrt_op_d = (fdsu_fpu_ex1_stall) ? sqrt_op : 1'b0;

  `FFL(fdsu_fpu_ex1_stall_q, fdsu_fpu_ex1_stall, 1'b1, '0)
  `FFL(div_op_q, div_op_d, 1'b1, '0)
  `FFL(sqrt_op_q, sqrt_op_d, 1'b1, '0)

  // FSM to safely apply and receive data from DIVSQRT unit
  always_comb begin : flag_fsm
    // Default assignments
    in_ready     = 1'b0;
    out_valid    = 1'b0;
    hold_result  = 1'b0;
    data_is_held = 1'b0;
    unit_busy    = 1'b0;
    state_d      = state_q;
    inp_pipe_ready[NUM_INP_REGS] = unit_ready_q;

    unique case (state_q)
      // Waiting for work
      IDLE: begin
        // in_ready = 1'b1; // we're ready
        in_ready = unit_ready_q;  //***
        if (in_valid_q && unit_ready_q) begin // New work arrives
          inp_pipe_ready[NUM_INP_REGS] = unit_ready_q && !fdsu_fpu_ex1_stall;
          state_d = BUSY; // go into processing state
        end
      end
      // Operation in progress
      BUSY: begin
        inp_pipe_ready[NUM_INP_REGS] = fdsu_fpu_ex1_stall_q;
        unit_busy = 1'b1; // data in flight
        // If the unit is done with processing
        if (unit_done) begin
          out_valid = 1'b1; // try to commit result downstream
          // If downstream accepts our result
          if (out_ready) begin
            state_d = IDLE; // we anticipate going back to idling..
            if (in_valid_q && unit_ready_q) begin // ..unless new work comes in
              in_ready = 1'b1; // we acknowledge the instruction
              state_d  = BUSY; // and stay busy with it
            end
          // Otherwise if downstream is not ready for the result
          end else begin
            hold_result = 1'b1; // activate the hold register
            state_d     = HOLD; // wait for the pipeline to take the data
          end
        end
      end
      // Waiting with valid result for downstream
      HOLD: begin
        unit_busy    = 1'b1; // data in flight
        data_is_held = 1'b1; // data in hold register is valid
        out_valid    = 1'b1; // try to commit result downstream
        // If the result is accepted by downstream
        if (out_ready) begin
          state_d = IDLE; // go back to idle..
          if (in_valid_q && unit_ready_q) begin // ..unless new work comes in
            in_ready = 1'b1; // acknowledge the new transaction
            state_d  = BUSY; // will be busy with the next instruction
          end
        end
      end
      // fall into idle state otherwise
      default: state_d = IDLE;
    endcase

    // Flushing overrides the other actions
    if (flush_i) begin
      unit_busy = 1'b0; // data is invalidated
      out_valid = 1'b0; // cancel any valid data
      state_d   = IDLE; // go to default state
    end
  end

  // FSM status register (asynch active low reset)
  `FF(state_q, state_d, IDLE)

  // Hold additional information while the operation is in progress
  TagType result_tag_q;
  AuxType result_aux_q;
  logic   result_mask_q;

  // Fill the registers everytime a valid operation arrives (load FF, active low asynch rst)
  `FFL(result_tag_q,  inp_pipe_tag_q[NUM_INP_REGS],  op_starting, '0)
  `FFL(result_mask_q, inp_pipe_mask_q[NUM_INP_REGS], op_starting, '0)
  `FFL(result_aux_q,  inp_pipe_aux_q[NUM_INP_REGS],  op_starting, '0)

  // -----------------
  // DIVSQRT instance
  // -----------------
  logic [WIDTH-1:0]   unit_result, held_result_q;
  fpnew_pkg::status_t unit_status, held_status_q;

  // thead define fdsu module's input and output
  logic        ctrl_fdsu_ex1_sel;
  logic        fdsu_fpu_ex1_cmplt;
  logic  [4:0] fdsu_fpu_ex1_fflags;
  logic  [7:0] fdsu_fpu_ex1_special_sel;
  logic  [3:0] fdsu_fpu_ex1_special_sign;
  logic        fdsu_fpu_no_op;
  logic  [2:0] idu_fpu_ex1_eu_sel;
  logic [31:0] fdsu_frbus_data;
  logic  [4:0] fdsu_frbus_fflags;
  logic        fdsu_frbus_wb_vld;

  // dp
  logic [31:0] dp_frbus_ex2_data;
  logic  [4:0] dp_frbus_ex2_fflags;
  logic  [2:0] dp_xx_ex1_cnan;
  logic  [2:0] dp_xx_ex1_id;
  logic  [2:0] dp_xx_ex1_inf;
  logic  [2:0] dp_xx_ex1_norm;
  logic  [2:0] dp_xx_ex1_qnan;
  logic  [2:0] dp_xx_ex1_snan;
  logic  [2:0] dp_xx_ex1_zero;
  logic        ex2_inst_wb;
  logic        ex2_inst_wb_vld_d, ex2_inst_wb_vld_q;

  // frbus
  logic [31:0] fpu_idu_fwd_data;
  logic  [4:0] fpu_idu_fwd_fflags;
  logic        fpu_idu_fwd_vld;

  logic unit_ready_d;

  // unit_ready_q related to state machine, different under special and normal cases.
  always_comb begin
    if(op_starting && unit_ready_q) begin
      if(ex2_inst_wb && ex2_inst_wb_vld_q) begin
        unit_ready_d = 1'b1;
      end else begin
        unit_ready_d = 1'b0;
      end
    end else if(fpu_idu_fwd_vld | flush_i) begin
      unit_ready_d = 1'b1;
    end else begin
      unit_ready_d = unit_ready_q;
    end
  end

  `FFL(unit_ready_q, unit_ready_d, 1'b1, 1'b1)

  // determine input of time to select operands
  always_comb begin
    ctrl_fdsu_ex1_sel = 1'b0;
    idu_fpu_ex1_eu_sel = 3'h0;
    if (op_starting) begin  // time to start calculation
      ctrl_fdsu_ex1_sel = 1'b1;  // time to select operands
      idu_fpu_ex1_eu_sel = 3'h4; // time to select operands, only idu_fpu_ex1_eu_sel_i[2] works in fdsu module
    end else if (fdsu_fpu_ex1_stall_q) begin
      ctrl_fdsu_ex1_sel = 1'b1;  // time to select operands
      idu_fpu_ex1_eu_sel = 3'h4; // time to select operands, only idu_fpu_ex1_eu_sel_i[2] works in fdsu module
    end else begin
      ctrl_fdsu_ex1_sel = 1'b0;
      idu_fpu_ex1_eu_sel = 3'h0;
    end
  end

  pa_fdsu_top i_divsqrt_thead (
   .cp0_fpu_icg_en                ( 1'b0               ),  // input clock gate enable in gated_clk_cell, active 0.
   .cp0_fpu_xx_dqnan              ( 1'b0               ),  // When dqnan = 0, QNAN (0x7fc00000).
   .cp0_yy_clk_en                 ( 1'b1               ),  // clock enable in gated_clk_cell, active 1.
   .cpurst_b                      ( rst_ni             ),  // If negedge cpu reset, all state machines reset to IDLE.
   .ctrl_fdsu_ex1_sel             ( ctrl_fdsu_ex1_sel  ),  // select operands
   .ctrl_xx_ex1_cmplt_dp          ( ctrl_fdsu_ex1_sel  ),  // complete datapath
   .ctrl_xx_ex1_inst_vld          ( ctrl_fdsu_ex1_sel  ),  // instance valid
   .ctrl_xx_ex1_stall             ( fdsu_fpu_ex1_stall ),
   .ctrl_xx_ex1_warm_up           ( 1'b0               ),
   .ctrl_xx_ex2_warm_up           ( 1'b0               ),
   .ctrl_xx_ex3_warm_up           ( 1'b0               ),
   .dp_xx_ex1_cnan                ( dp_xx_ex1_cnan     ),  // Special input type determination
   .dp_xx_ex1_id                  ( dp_xx_ex1_id       ),
   .dp_xx_ex1_inf                 ( dp_xx_ex1_inf      ),
   .dp_xx_ex1_qnan                ( dp_xx_ex1_qnan     ),
   .dp_xx_ex1_rm                  ( rnd_mode_q         ),  // rounding mode
   .dp_xx_ex1_snan                ( dp_xx_ex1_snan     ),
   .dp_xx_ex1_zero                ( dp_xx_ex1_zero     ),
   .fdsu_fpu_debug_info           (                    ),  // output, not used
   .fdsu_fpu_ex1_cmplt            ( fdsu_fpu_ex1_cmplt ),  // output, ctrl_xx_ex1_cmplt_dp && idu_fpu_ex1_eu_sel_i[2]
   .fdsu_fpu_ex1_cmplt_dp         (                    ),  // output, not used
   .fdsu_fpu_ex1_fflags           ( fdsu_fpu_ex1_fflags       ),  // output, special case fflags
   .fdsu_fpu_ex1_special_sel      ( fdsu_fpu_ex1_special_sel  ),  // output, special case type selection
   .fdsu_fpu_ex1_special_sign     ( fdsu_fpu_ex1_special_sign ),  // output, special case sign determination
   .fdsu_fpu_ex1_stall            ( fdsu_fpu_ex1_stall        ),  // output, determine whether stall in ex1
   .fdsu_fpu_no_op                ( fdsu_fpu_no_op            ),  // output, if Write Back SM and fdsu SM no operation, fdsu_fpu_no_op = 1; Otherwise if busy, fdsu_fpu_no_op = 0. (not used)
   .fdsu_frbus_data               ( fdsu_frbus_data           ),  // output, normal case result
   .fdsu_frbus_fflags             ( fdsu_frbus_fflags         ),  // output, normal case fflags
   .fdsu_frbus_freg               (                           ),  // output, determined by input idu_fpu_ex1_dst_freg
   .fdsu_frbus_wb_vld             ( fdsu_frbus_wb_vld         ),  // output, determine whether write back valid
   .forever_cpuclk                ( clk_i                     ),
   .frbus_fdsu_wb_grant           ( fdsu_frbus_wb_vld         ),  // input is fdsu_frbus_wb_vld
   .idu_fpu_ex1_dst_freg          ( 5'h0f                     ),  // register index to write back (not used)
   .idu_fpu_ex1_eu_sel            ( idu_fpu_ex1_eu_sel        ),  // time to select operands
   .idu_fpu_ex1_func              ( {8'b0, div_op | div_op_q, sqrt_op | sqrt_op_q} ),
   .idu_fpu_ex1_srcf0             ( operands_q[0][31:0]       ),  // the first operand
   .idu_fpu_ex1_srcf1             ( operands_q[1][31:0]       ),  // the second operand
   .pad_yy_icg_scan_en            ( 1'b0                      ),  // input of core_top, set to 1'b0 from the beginning to end
   .rtu_xx_ex1_cancel             ( 1'b0                      ),
   .rtu_xx_ex2_cancel             ( 1'b0                      ),
   .rtu_yy_xx_async_flush         ( flush_i                   ),
   .rtu_yy_xx_flush               ( 1'b0                      )
  );

  pa_fpu_dp  x_pa_fpu_dp (
    .cp0_fpu_icg_en              ( 1'b0                       ),
    .cp0_fpu_xx_rm               ( rnd_mode_q                 ),
    .cp0_yy_clk_en               ( 1'b1                       ),
    .ctrl_xx_ex1_inst_vld        ( ctrl_fdsu_ex1_sel          ),
    .ctrl_xx_ex1_stall           ( 1'b0                       ),
    .ctrl_xx_ex1_warm_up         ( 1'b0                       ),
    .dp_frbus_ex2_data           ( dp_frbus_ex2_data          ),  // output
    .dp_frbus_ex2_fflags         ( dp_frbus_ex2_fflags        ),  // output
    .dp_xx_ex1_cnan              ( dp_xx_ex1_cnan             ),  // output
    .dp_xx_ex1_id                ( dp_xx_ex1_id               ),  // output
    .dp_xx_ex1_inf               ( dp_xx_ex1_inf              ),  // output
    .dp_xx_ex1_norm              ( dp_xx_ex1_norm             ),  // output
    .dp_xx_ex1_qnan              ( dp_xx_ex1_qnan             ),  // output
    .dp_xx_ex1_snan              ( dp_xx_ex1_snan             ),  // output
    .dp_xx_ex1_zero              ( dp_xx_ex1_zero             ),  // output
    .ex2_inst_wb                 ( ex2_inst_wb                ),  // output
    .fdsu_fpu_ex1_fflags         ( fdsu_fpu_ex1_fflags        ),
    .fdsu_fpu_ex1_special_sel    ( fdsu_fpu_ex1_special_sel   ),
    .fdsu_fpu_ex1_special_sign   ( fdsu_fpu_ex1_special_sign  ),
    .forever_cpuclk              ( clk_i                      ),
    .idu_fpu_ex1_eu_sel          ( idu_fpu_ex1_eu_sel         ),
    .idu_fpu_ex1_func            ( {8'b0, div_op, sqrt_op}    ),
    .idu_fpu_ex1_gateclk_vld     ( fdsu_fpu_ex1_cmplt         ),
    .idu_fpu_ex1_rm              ( rnd_mode_q                 ),
    .idu_fpu_ex1_srcf0           ( operands_q[0][31:0]        ),
    .idu_fpu_ex1_srcf1           ( operands_q[1][31:0]        ),
    .idu_fpu_ex1_srcf2           ( '0                         ),
    .pad_yy_icg_scan_en          ( 1'b0                       )
  );

  assign ex2_inst_wb_vld_d = ctrl_fdsu_ex1_sel;
  `FF(ex2_inst_wb_vld_q, ex2_inst_wb_vld_d, '0)

  pa_fpu_frbus x_pa_fpu_frbus (
    .ctrl_frbus_ex2_wb_req     ( ex2_inst_wb & ex2_inst_wb_vld_q ),
    .dp_frbus_ex2_data         ( dp_frbus_ex2_data   ),
    .dp_frbus_ex2_fflags       ( dp_frbus_ex2_fflags ),
    .fdsu_frbus_data           ( fdsu_frbus_data     ),
    .fdsu_frbus_fflags         ( fdsu_frbus_fflags   ),
    .fdsu_frbus_wb_vld         ( fdsu_frbus_wb_vld   ),
    .fpu_idu_fwd_data          ( fpu_idu_fwd_data    ),  // output
    .fpu_idu_fwd_fflags        ( fpu_idu_fwd_fflags  ),  // output
    .fpu_idu_fwd_vld           ( fpu_idu_fwd_vld     )   // output
  );

  always_comb begin
    unit_result[31:0] = fpu_idu_fwd_data[31:0];
    unit_status[4:0]  = fpu_idu_fwd_fflags[4:0];
    unit_done         = fpu_idu_fwd_vld;
  end

  // The Hold register (load, no reset)
  `FFLNR(held_result_q, unit_result, hold_result, clk_i)
  `FFLNR(held_status_q, unit_status, hold_result, clk_i)

  // --------------
  // Output Select
  // --------------
  logic [WIDTH-1:0]   result_d;
  fpnew_pkg::status_t status_d;
  // Prioritize hold register data
  assign result_d = data_is_held ? held_result_q : unit_result;
  assign status_d = data_is_held ? held_status_q : unit_status;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  logic               [0:NUM_OUT_REGS][WIDTH-1:0] out_pipe_result_q;
  fpnew_pkg::status_t [0:NUM_OUT_REGS]            out_pipe_status_q;
  TagType             [0:NUM_OUT_REGS]            out_pipe_tag_q;
  AuxType             [0:NUM_OUT_REGS]            out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_mask_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0] = result_d;
  assign out_pipe_status_q[0] = status_d;
  assign out_pipe_tag_q[0]    = result_tag_q;
  assign out_pipe_mask_q[0]   = result_mask_q;
  assign out_pipe_aux_q[0]    = result_aux_q;
  assign out_pipe_valid_q[0]  = out_valid;
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign out_ready = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1], out_pipe_result_q[i], reg_ena, '0)
    `FFL(out_pipe_status_q[i+1], out_pipe_status_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],    out_pipe_tag_q[i],    reg_ena, TagType'('0))
    `FFL(out_pipe_mask_q[i+1],   out_pipe_mask_q[i],   reg_ena, '0)
    `FFL(out_pipe_aux_q[i+1],    out_pipe_aux_q[i],    reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = 1'b1; // always NaN-Box result
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, unit_busy, out_pipe_valid_q});
endmodule
// ----- 8< ----- FILE "./fpnew_fma.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>



module fpnew_fma #(
  parameter fpnew_pkg::fp_format_e   FpFormat    = fpnew_pkg::fp_format_e'(0),
  parameter int unsigned             NumPipeRegs = 0,
  parameter fpnew_pkg::pipe_config_t PipeConfig  = fpnew_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH = fpnew_pkg::fp_width(FpFormat),
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input logic                      clk_i,
  input logic                      rst_ni,
  // Input signals
  input logic [2:0][WIDTH-1:0]     operands_i, // 3 operands
  input logic [2:0]                is_boxed_i, // 3 operands
  input fpnew_pkg::roundmode_e     rnd_mode_i,
  input fpnew_pkg::operation_e     op_i,
  input logic                      op_mod_i,
  input TagType                    tag_i,
  input logic                      mask_i,
  input AuxType                    aux_i,
  // Input Handshake
  input  logic                     in_valid_i,
  output logic                     in_ready_o,
  input  logic                     flush_i,
  // Output signals
  output logic [WIDTH-1:0]         result_o,
  output fpnew_pkg::status_t       status_o,
  output logic                     extension_bit_o,
  output TagType                   tag_o,
  output logic                     mask_o,
  output AuxType                   aux_o,
  // Output handshake
  output logic                     out_valid_o,
  input  logic                     out_ready_i,
  // Indication of valid data in flight
  output logic                     busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0] reg_ena_i
);

  // ----------
  // Constants
  // ----------
  localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(FpFormat);
  localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(FpFormat);
  localparam int unsigned BIAS     = fpnew_pkg::bias(FpFormat);
  // Precision bits 'p' include the implicit bit
  localparam int unsigned PRECISION_BITS = MAN_BITS + 1;
  // The lower 2p+3 bits of the internal FMA result will be needed for leading-zero detection
  localparam int unsigned LOWER_SUM_WIDTH  = 2 * PRECISION_BITS + 3;
  localparam int unsigned LZC_RESULT_WIDTH = $clog2(LOWER_SUM_WIDTH);
  // Internal exponent width of FMA must accomodate all meaningful exponent values in order to avoid
  // datapath leakage. This is either given by the exponent bits or the width of the LZC result.
  // In most reasonable FP formats the internal exponent will be wider than the LZC result.
  localparam int unsigned EXP_WIDTH = unsigned'(fpnew_pkg::maximum(EXP_BITS + 2, LZC_RESULT_WIDTH));
  // Shift amount width: maximum internal mantissa size is 3p+4 bits
  localparam int unsigned SHIFT_AMOUNT_WIDTH = $clog2(3 * PRECISION_BITS + 5);
  // Pipelines
  localparam NUM_INP_REGS = PipeConfig == fpnew_pkg::BEFORE
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 3) // Second to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_MID_REGS = PipeConfig == fpnew_pkg::INSIDE
                          ? NumPipeRegs
                          : (PipeConfig == fpnew_pkg::DISTRIBUTED
                             ? ((NumPipeRegs + 2) / 3) // First to get distributed regs
                             : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = PipeConfig == fpnew_pkg::AFTER
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 3) // Last to get distributed regs
                               : 0); // no regs here otherwise

  // ----------------
  // Type definition
  // ----------------
  typedef struct packed {
    logic                sign;
    logic [EXP_BITS-1:0] exponent;
    logic [MAN_BITS-1:0] mantissa;
  } fp_t;

  // ---------------
  // Input pipeline
  // ---------------
  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][2:0][WIDTH-1:0] inp_pipe_operands_q;
  logic                  [0:NUM_INP_REGS][2:0]            inp_pipe_is_boxed_q;
  fpnew_pkg::roundmode_e [0:NUM_INP_REGS]                 inp_pipe_rnd_mode_q;
  fpnew_pkg::operation_e [0:NUM_INP_REGS]                 inp_pipe_op_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_op_mod_q;
  TagType                [0:NUM_INP_REGS]                 inp_pipe_tag_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_mask_q;
  AuxType                [0:NUM_INP_REGS]                 inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_is_boxed_q[0] = is_boxed_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_op_mod_q[0]   = op_mod_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_mask_q[0]     = mask_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, fpnew_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, fpnew_pkg::FMADD)
    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end

  // -----------------
  // Input processing
  // -----------------
  fpnew_pkg::fp_info_t [2:0] info_q;

  // Classify input
  fpnew_classifier #(
    .FpFormat    ( FpFormat ),
    .NumOperands ( 3        )
    ) i_class_inputs (
    .operands_i ( inp_pipe_operands_q[NUM_INP_REGS] ),
    .is_boxed_i ( inp_pipe_is_boxed_q[NUM_INP_REGS] ),
    .info_o     ( info_q                            )
  );

  fp_t                 operand_a, operand_b, operand_c;
  fpnew_pkg::fp_info_t info_a,    info_b,    info_c;

  // Operation selection and operand adjustment
  // | \c op_q  | \c op_mod_q | Operation Adjustment
  // |:--------:|:-----------:|---------------------
  // | FMADD    | \c 0        | FMADD: none
  // | FMADD    | \c 1        | FMSUB: Invert sign of operand C
  // | FNMSUB   | \c 0        | FNMSUB: Invert sign of operand A
  // | FNMSUB   | \c 1        | FNMADD: Invert sign of operands A and C
  // | ADD      | \c 0        | ADD: Set operand A to +1.0
  // | ADD      | \c 1        | SUB: Set operand A to +1.0, invert sign of operand C
  // | MUL      | \c 0        | MUL: Set operand C to +0.0 or -0.0 depending on the rounding mode
  // | *others* | \c -        | *invalid*
  // \note \c op_mod_q always inverts the sign of the addend.
  always_comb begin : op_select

    // Default assignments - packing-order-agnostic
    operand_a = inp_pipe_operands_q[NUM_INP_REGS][0];
    operand_b = inp_pipe_operands_q[NUM_INP_REGS][1];
    operand_c = inp_pipe_operands_q[NUM_INP_REGS][2];
    info_a    = info_q[0];
    info_b    = info_q[1];
    info_c    = info_q[2];

    // op_mod_q inverts sign of operand C
    operand_c.sign = operand_c.sign ^ inp_pipe_op_mod_q[NUM_INP_REGS];

    unique case (inp_pipe_op_q[NUM_INP_REGS])
      fpnew_pkg::FMADD:  ; // do nothing
      fpnew_pkg::FNMSUB: operand_a.sign = ~operand_a.sign; // invert sign of product
      fpnew_pkg::ADD: begin // Set multiplicand to +1
        operand_a = '{sign: 1'b0, exponent: BIAS, mantissa: '0};
        info_a    = '{is_normal: 1'b1, is_boxed: 1'b1, default: 1'b0}; //normal, boxed value.
      end
      fpnew_pkg::MUL: begin // Set addend to +0 or -0, depending whether the rounding mode is RDN
        if (inp_pipe_rnd_mode_q[NUM_INP_REGS] == fpnew_pkg::RDN)
          operand_c = '{sign: 1'b0, exponent: '0, mantissa: '0};
        else
          operand_c = '{sign: 1'b1, exponent: '0, mantissa: '0};
        info_c    = '{is_zero: 1'b1, is_boxed: 1'b1, default: 1'b0}; //zero, boxed value.
      end
      default: begin // propagate don't cares
        operand_a  = '{default: fpnew_pkg::DONT_CARE};
        operand_b  = '{default: fpnew_pkg::DONT_CARE};
        operand_c  = '{default: fpnew_pkg::DONT_CARE};
        info_a     = '{default: fpnew_pkg::DONT_CARE};
        info_b     = '{default: fpnew_pkg::DONT_CARE};
        info_c     = '{default: fpnew_pkg::DONT_CARE};
      end
    endcase
  end

  // ---------------------
  // Input classification
  // ---------------------
  logic any_operand_inf;
  logic any_operand_nan;
  logic signalling_nan;
  logic effective_subtraction;
  logic tentative_sign;

  // Reduction for special case handling
  assign any_operand_inf = (| {info_a.is_inf,        info_b.is_inf,        info_c.is_inf});
  assign any_operand_nan = (| {info_a.is_nan,        info_b.is_nan,        info_c.is_nan});
  assign signalling_nan  = (| {info_a.is_signalling, info_b.is_signalling, info_c.is_signalling});
  // Effective subtraction in FMA occurs when product and addend signs differ
  assign effective_subtraction = operand_a.sign ^ operand_b.sign ^ operand_c.sign;
  // The tentative sign of the FMA shall be the sign of the product
  assign tentative_sign = operand_a.sign ^ operand_b.sign;

  // ----------------------
  // Special case handling
  // ----------------------
  fp_t                special_result;
  fpnew_pkg::status_t special_status;
  logic               result_is_special;

  always_comb begin : special_cases
    // Default assignments
    special_result    = '{sign: 1'b0, exponent: '1, mantissa: 2**(MAN_BITS-1)}; // canonical qNaN
    special_status    = '0;
    result_is_special = 1'b0;

    // Handle potentially mixed nan & infinity input => important for the case where infinity and
    // zero are multiplied and added to a qnan.
    // RISC-V mandates raising the NV exception in these cases:
    // (inf * 0) + c or (0 * inf) + c INVALID, no matter c (even quiet NaNs)
    if ((info_a.is_inf && info_b.is_zero) || (info_a.is_zero && info_b.is_inf)) begin
      result_is_special = 1'b1; // bypass FMA, output is the canonical qNaN
      special_status.NV = 1'b1; // invalid operation
    // NaN Inputs cause canonical quiet NaN at the output and maybe invalid OP
    end else if (any_operand_nan) begin
      result_is_special = 1'b1;           // bypass FMA, output is the canonical qNaN
      special_status.NV = signalling_nan; // raise the invalid operation flag if signalling
    // Special cases involving infinity
    end else if (any_operand_inf) begin
      result_is_special = 1'b1; // bypass FMA
      // Effective addition of opposite infinities (??inf - ??inf) is invalid!
      if ((info_a.is_inf || info_b.is_inf) && info_c.is_inf && effective_subtraction)
        special_status.NV = 1'b1; // invalid operation
      // Handle cases where output will be inf because of inf product input
      else if (info_a.is_inf || info_b.is_inf) begin
        // Result is infinity with the sign of the product
        special_result    = '{sign: operand_a.sign ^ operand_b.sign, exponent: '1, mantissa: '0};
      // Handle cases where the addend is inf
      end else if (info_c.is_inf) begin
        // Result is inifinity with sign of the addend (= operand_c)
        special_result    = '{sign: operand_c.sign, exponent: '1, mantissa: '0};
      end
    end
  end

  // ---------------------------
  // Initial exponent data path
  // ---------------------------
  logic signed [EXP_WIDTH-1:0] exponent_a, exponent_b, exponent_c;
  logic signed [EXP_WIDTH-1:0] exponent_addend, exponent_product, exponent_difference;
  logic signed [EXP_WIDTH-1:0] tentative_exponent;

  // Zero-extend exponents into signed container - implicit width extension
  assign exponent_a = signed'({1'b0, operand_a.exponent});
  assign exponent_b = signed'({1'b0, operand_b.exponent});
  assign exponent_c = signed'({1'b0, operand_c.exponent});

  // Calculate internal exponents from encoded values. Real exponents are (ex = Ex - bias + 1 - nx)
  // with Ex the encoded exponent and nx the implicit bit. Internal exponents stay biased.
  assign exponent_addend = signed'(exponent_c + $signed({1'b0, ~info_c.is_normal})); // 0 as subnorm
  // Biased product exponent is the sum of encoded exponents minus the bias.
  assign exponent_product = (info_a.is_zero || info_b.is_zero)
                            ? 2 - signed'(BIAS) // in case the product is zero, set minimum exp.
                            : signed'(exponent_a + info_a.is_subnormal
                                      + exponent_b + info_b.is_subnormal
                                      - signed'(BIAS));
  // Exponent difference is the addend exponent minus the product exponent
  assign exponent_difference = exponent_addend - exponent_product;
  // The tentative exponent will be the larger of the product or addend exponent
  assign tentative_exponent = (exponent_difference > 0) ? exponent_addend : exponent_product;

  // Shift amount for addend based on exponents (unsigned as only right shifts)
  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt;

  always_comb begin : addend_shift_amount
    // Product-anchored case, saturated shift (addend is only in the sticky bit)
    if (exponent_difference <= signed'(-2 * PRECISION_BITS - 1))
      addend_shamt = 3 * PRECISION_BITS + 4;
    // Addend and product will have mutual bits to add
    else if (exponent_difference <= signed'(PRECISION_BITS + 2))
      addend_shamt = unsigned'(signed'(PRECISION_BITS) + 3 - exponent_difference);
    // Addend-anchored case, saturated shift (product is only in the sticky bit)
    else
      addend_shamt = 0;
  end

  // ------------------
  // Product data path
  // ------------------
  logic [PRECISION_BITS-1:0]   mantissa_a, mantissa_b, mantissa_c;
  logic [2*PRECISION_BITS-1:0] product;             // the p*p product is 2p bits wide
  logic [3*PRECISION_BITS+3:0] product_shifted;     // addends are 3p+4 bit wide (including G/R)

  // Add implicit bits to mantissae
  assign mantissa_a = {info_a.is_normal, operand_a.mantissa};
  assign mantissa_b = {info_b.is_normal, operand_b.mantissa};
  assign mantissa_c = {info_c.is_normal, operand_c.mantissa};

  // Mantissa multiplier (a*b)
  assign product = mantissa_a * mantissa_b;

  // Product is placed into a 3p+4 bit wide vector, padded with 2 bits for round and sticky:
  // | 000...000 | product | RS |
  //  <-  p+2  -> <-  2p -> < 2>
  assign product_shifted = product << 2; // constant shift

  // -----------------
  // Addend data path
  // -----------------
  logic [3*PRECISION_BITS+3:0] addend_after_shift;  // upper 3p+4 bits are needed to go on
  logic [PRECISION_BITS-1:0]   addend_sticky_bits;  // up to p bit of shifted addend are sticky
  logic                        sticky_before_add;   // they are compressed into a single sticky bit
  logic [3*PRECISION_BITS+3:0] addend_shifted;      // addends are 3p+4 bit wide (including G/R)
  logic                        inject_carry_in;     // inject carry for subtractions if needed

  // In parallel, the addend is right-shifted according to the exponent difference. Up to p bits
  // are shifted out and compressed into a sticky bit.
  // BEFORE THE SHIFT:
  // | mantissa_c | 000..000 |
  //  <-    p   -> <- 3p+4 ->
  // AFTER THE SHIFT:
  // | 000..........000 | mantissa_c | 000...............0GR |  sticky bits  |
  //  <- addend_shamt -> <-    p   -> <- 2p+4-addend_shamt -> <-  up to p  ->
  assign {addend_after_shift, addend_sticky_bits} =
      (mantissa_c << (3 * PRECISION_BITS + 4)) >> addend_shamt;

  assign sticky_before_add     = (| addend_sticky_bits);
  // assign addend_after_shift[0] = sticky_before_add;

  // In case of a subtraction, the addend is inverted
  assign addend_shifted  = (effective_subtraction) ? ~addend_after_shift : addend_after_shift;
  assign inject_carry_in = effective_subtraction & ~sticky_before_add;

  // ------
  // Adder
  // ------
  logic [3*PRECISION_BITS+4:0] sum_raw;   // added one bit for the carry
  logic                        sum_carry; // observe carry bit from sum for sign fixing
  logic [3*PRECISION_BITS+3:0] sum;       // discard carry as sum won't overflow
  logic                        final_sign;

  //Mantissa adder (ab+c). In normal addition, it cannot overflow.
  assign sum_raw = product_shifted + addend_shifted + inject_carry_in;
  assign sum_carry = sum_raw[3*PRECISION_BITS+4];

  // Complement negative sum (can only happen in subtraction -> overflows for positive results)
  assign sum        = (effective_subtraction && ~sum_carry) ? -sum_raw : sum_raw;

  // In case of a mispredicted subtraction result, do a sign flip
  assign final_sign = (effective_subtraction && (sum_carry == tentative_sign))
                      ? 1'b1
                      : (effective_subtraction ? 1'b0 : tentative_sign);

  // ---------------
  // Internal pipeline
  // ---------------
  // Pipeline output signals as non-arrays
  logic                          effective_subtraction_q;
  logic signed [EXP_WIDTH-1:0]   exponent_product_q;
  logic signed [EXP_WIDTH-1:0]   exponent_difference_q;
  logic signed [EXP_WIDTH-1:0]   tentative_exponent_q;
  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt_q;
  logic                          sticky_before_add_q;
  logic [3*PRECISION_BITS+3:0]   sum_q;
  logic                          final_sign_q;
  fpnew_pkg::roundmode_e         rnd_mode_q;
  logic                          result_is_special_q;
  fp_t                           special_result_q;
  fpnew_pkg::status_t            special_status_q;
  // Internal pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_MID_REGS]                         mid_pipe_eff_sub_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_prod_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_diff_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_tent_exp_q;
  logic                  [0:NUM_MID_REGS][SHIFT_AMOUNT_WIDTH-1:0] mid_pipe_add_shamt_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_sticky_q;
  logic                  [0:NUM_MID_REGS][3*PRECISION_BITS+3:0]   mid_pipe_sum_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_final_sign_q;
  fpnew_pkg::roundmode_e [0:NUM_MID_REGS]                         mid_pipe_rnd_mode_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_res_is_spec_q;
  fp_t                   [0:NUM_MID_REGS]                         mid_pipe_spec_res_q;
  fpnew_pkg::status_t    [0:NUM_MID_REGS]                         mid_pipe_spec_stat_q;
  TagType                [0:NUM_MID_REGS]                         mid_pipe_tag_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_mask_q;
  AuxType                [0:NUM_MID_REGS]                         mid_pipe_aux_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_MID_REGS] mid_pipe_ready;

  // Input stage: First element of pipeline is taken from upstream logic
  assign mid_pipe_eff_sub_q[0]     = effective_subtraction;
  assign mid_pipe_exp_prod_q[0]    = exponent_product;
  assign mid_pipe_exp_diff_q[0]    = exponent_difference;
  assign mid_pipe_tent_exp_q[0]    = tentative_exponent;
  assign mid_pipe_add_shamt_q[0]   = addend_shamt;
  assign mid_pipe_sticky_q[0]      = sticky_before_add;
  assign mid_pipe_sum_q[0]         = sum;
  assign mid_pipe_final_sign_q[0]  = final_sign;
  assign mid_pipe_rnd_mode_q[0]    = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign mid_pipe_res_is_spec_q[0] = result_is_special;
  assign mid_pipe_spec_res_q[0]    = special_result;
  assign mid_pipe_spec_stat_q[0]   = special_status;
  assign mid_pipe_tag_q[0]         = inp_pipe_tag_q[NUM_INP_REGS];
  assign mid_pipe_mask_q[0]        = inp_pipe_mask_q[NUM_INP_REGS];
  assign mid_pipe_aux_q[0]         = inp_pipe_aux_q[NUM_INP_REGS];
  assign mid_pipe_valid_q[0]       = inp_pipe_valid_q[NUM_INP_REGS];
  // Input stage: Propagate pipeline ready signal to input pipe
  assign inp_pipe_ready[NUM_INP_REGS] = mid_pipe_ready[0];

  // Generate the register stages
  for (genvar i = 0; i < NUM_MID_REGS; i++) begin : gen_inside_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign mid_pipe_ready[i] = mid_pipe_ready[i+1] | ~mid_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(mid_pipe_valid_q[i+1], mid_pipe_valid_q[i], mid_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (mid_pipe_ready[i] & mid_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(mid_pipe_eff_sub_q[i+1],     mid_pipe_eff_sub_q[i],     reg_ena, '0)
    `FFL(mid_pipe_exp_prod_q[i+1],    mid_pipe_exp_prod_q[i],    reg_ena, '0)
    `FFL(mid_pipe_exp_diff_q[i+1],    mid_pipe_exp_diff_q[i],    reg_ena, '0)
    `FFL(mid_pipe_tent_exp_q[i+1],    mid_pipe_tent_exp_q[i],    reg_ena, '0)
    `FFL(mid_pipe_add_shamt_q[i+1],   mid_pipe_add_shamt_q[i],   reg_ena, '0)
    `FFL(mid_pipe_sticky_q[i+1],      mid_pipe_sticky_q[i],      reg_ena, '0)
    `FFL(mid_pipe_sum_q[i+1],         mid_pipe_sum_q[i],         reg_ena, '0)
    `FFL(mid_pipe_final_sign_q[i+1],  mid_pipe_final_sign_q[i],  reg_ena, '0)
    `FFL(mid_pipe_rnd_mode_q[i+1],    mid_pipe_rnd_mode_q[i],    reg_ena, fpnew_pkg::RNE)
    `FFL(mid_pipe_res_is_spec_q[i+1], mid_pipe_res_is_spec_q[i], reg_ena, '0)
    `FFL(mid_pipe_spec_res_q[i+1],    mid_pipe_spec_res_q[i],    reg_ena, '0)
    `FFL(mid_pipe_spec_stat_q[i+1],   mid_pipe_spec_stat_q[i],   reg_ena, '0)
    `FFL(mid_pipe_tag_q[i+1],         mid_pipe_tag_q[i],         reg_ena, TagType'('0))
    `FFL(mid_pipe_mask_q[i+1],        mid_pipe_mask_q[i],        reg_ena, '0)
    `FFL(mid_pipe_aux_q[i+1],         mid_pipe_aux_q[i],         reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign effective_subtraction_q = mid_pipe_eff_sub_q[NUM_MID_REGS];
  assign exponent_product_q      = mid_pipe_exp_prod_q[NUM_MID_REGS];
  assign exponent_difference_q   = mid_pipe_exp_diff_q[NUM_MID_REGS];
  assign tentative_exponent_q    = mid_pipe_tent_exp_q[NUM_MID_REGS];
  assign addend_shamt_q          = mid_pipe_add_shamt_q[NUM_MID_REGS];
  assign sticky_before_add_q     = mid_pipe_sticky_q[NUM_MID_REGS];
  assign sum_q                   = mid_pipe_sum_q[NUM_MID_REGS];
  assign final_sign_q            = mid_pipe_final_sign_q[NUM_MID_REGS];
  assign rnd_mode_q              = mid_pipe_rnd_mode_q[NUM_MID_REGS];
  assign result_is_special_q     = mid_pipe_res_is_spec_q[NUM_MID_REGS];
  assign special_result_q        = mid_pipe_spec_res_q[NUM_MID_REGS];
  assign special_status_q        = mid_pipe_spec_stat_q[NUM_MID_REGS];

  // --------------
  // Normalization
  // --------------
  logic        [LOWER_SUM_WIDTH-1:0]  sum_lower;              // lower 2p+3 bits of sum are searched
  logic        [LZC_RESULT_WIDTH-1:0] leading_zero_count;     // the number of leading zeroes
  logic signed [LZC_RESULT_WIDTH:0]   leading_zero_count_sgn; // signed leading-zero count
  logic                               lzc_zeroes;             // in case only zeroes found

  logic        [SHIFT_AMOUNT_WIDTH-1:0] norm_shamt; // Normalization shift amount
  logic signed [EXP_WIDTH-1:0]          normalized_exponent;

  logic [3*PRECISION_BITS+4:0] sum_shifted;       // result after first normalization shift
  logic [PRECISION_BITS:0]     final_mantissa;    // final mantissa before rounding with round bit
  logic [2*PRECISION_BITS+2:0] sum_sticky_bits;   // remaining 2p+3 sticky bits after normalization
  logic                        sticky_after_norm; // sticky bit after normalization

  logic signed [EXP_WIDTH-1:0] final_exponent;

  assign sum_lower = sum_q[LOWER_SUM_WIDTH-1:0];

  // Leading zero counter for cancellations
  lzc #(
    .WIDTH ( LOWER_SUM_WIDTH ),
    .MODE  ( 1               ) // MODE = 1 counts leading zeroes
  ) i_lzc (
    .in_i    ( sum_lower          ),
    .cnt_o   ( leading_zero_count ),
    .empty_o ( lzc_zeroes         )
  );

  assign leading_zero_count_sgn = signed'({1'b0, leading_zero_count});

  // Normalization shift amount based on exponents and LZC (unsigned as only left shifts)
  always_comb begin : norm_shift_amount
    // Product-anchored case or cancellations require LZC
    if ((exponent_difference_q <= 0) || (effective_subtraction_q && (exponent_difference_q <= 2))) begin
      // Normal result (biased exponent > 0 and not a zero)
      if ((exponent_product_q - leading_zero_count_sgn + 1 >= 0) && !lzc_zeroes) begin
        // Undo initial product shift, remove the counted zeroes
        norm_shamt          = PRECISION_BITS + 2 + leading_zero_count;
        normalized_exponent = exponent_product_q - leading_zero_count_sgn + 1; // account for shift
      // Subnormal result
      end else begin
        // Cap the shift distance to align mantissa with minimum exponent
        norm_shamt          = unsigned'(signed'(PRECISION_BITS) + 2 + exponent_product_q);
        normalized_exponent = 0; // subnormals encoded as 0
      end
    // Addend-anchored case
    end else begin
      norm_shamt          = addend_shamt_q; // Undo the initial shift
      normalized_exponent = tentative_exponent_q;
    end
  end

  // Do the large normalization shift
  assign sum_shifted       = sum_q << norm_shamt;

  // The addend-anchored case needs a 1-bit normalization since the leading-one can be to the left
  // or right of the (non-carry) MSB of the sum.
  always_comb begin : small_norm
    // Default assignment, discarding carry bit
    {final_mantissa, sum_sticky_bits} = sum_shifted;
    final_exponent                    = normalized_exponent;

    // The normalized sum has overflown, align right and fix exponent
    if (sum_shifted[3*PRECISION_BITS+4]) begin // check the carry bit
      {final_mantissa, sum_sticky_bits} = sum_shifted >> 1;
      final_exponent                    = normalized_exponent + 1;
    // The normalized sum is normal, nothing to do
    end else if (sum_shifted[3*PRECISION_BITS+3]) begin // check the sum MSB
      // do nothing
    // The normalized sum is still denormal, align left - unless the result is not already subnormal
    end else if (normalized_exponent > 1) begin
      {final_mantissa, sum_sticky_bits} = sum_shifted << 1;
      final_exponent                    = normalized_exponent - 1;
    // Otherwise we're denormal
    end else begin
      final_exponent = '0;
    end
  end

  // Update the sticky bit with the shifted-out bits
  assign sticky_after_norm = (| {sum_sticky_bits}) | sticky_before_add_q;

  // ----------------------------
  // Rounding and classification
  // ----------------------------
  logic                         pre_round_sign;
  logic [EXP_BITS-1:0]          pre_round_exponent;
  logic [MAN_BITS-1:0]          pre_round_mantissa;
  logic [EXP_BITS+MAN_BITS-1:0] pre_round_abs; // absolute value of result before rounding
  logic [1:0]                   round_sticky_bits;

  logic of_before_round, of_after_round; // overflow
  logic uf_before_round, uf_after_round; // underflow
  logic result_zero;

  logic                         rounded_sign;
  logic [EXP_BITS+MAN_BITS-1:0] rounded_abs; // absolute value of result after rounding

  // Classification before round. RISC-V mandates checking underflow AFTER rounding!
  assign of_before_round = final_exponent >= 2**(EXP_BITS)-1; // infinity exponent is all ones
  assign uf_before_round = final_exponent == 0;               // exponent for subnormals capped to 0

  // Assemble result before rounding. In case of overflow, the largest normal value is set.
  assign pre_round_sign     = final_sign_q;
  assign pre_round_exponent = (of_before_round) ? 2**EXP_BITS-2 : unsigned'(final_exponent[EXP_BITS-1:0]);
  assign pre_round_mantissa = (of_before_round) ? '1 : final_mantissa[MAN_BITS:1]; // bit 0 is R bit
  assign pre_round_abs      = {pre_round_exponent, pre_round_mantissa};

  // In case of overflow, the round and sticky bits are set for proper rounding
  assign round_sticky_bits  = (of_before_round) ? 2'b11 : {final_mantissa[0], sticky_after_norm};

  // Perform the rounding
  fpnew_rounding #(
    .AbsWidth ( EXP_BITS + MAN_BITS )
  ) i_fpnew_rounding (
    .abs_value_i             ( pre_round_abs           ),
    .sign_i                  ( pre_round_sign          ),
    .round_sticky_bits_i     ( round_sticky_bits       ),
    .rnd_mode_i              ( rnd_mode_q              ),
    .effective_subtraction_i ( effective_subtraction_q ),
    .abs_rounded_o           ( rounded_abs             ),
    .sign_o                  ( rounded_sign            ),
    .exact_zero_o            ( result_zero             )
  );

  // Classification after rounding
  assign uf_after_round = (rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0) // denormal
        || ((pre_round_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0) && (rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == 1) && 
           ((round_sticky_bits != 2'b11) || (!sum_sticky_bits[MAN_BITS*2 + 4] && ((rnd_mode_i == fpnew_pkg::RNE) || (rnd_mode_i == fpnew_pkg::RMM)))));
  assign of_after_round = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '1; // exponent all ones

  // -----------------
  // Result selection
  // -----------------
  logic [WIDTH-1:0]     regular_result;
  fpnew_pkg::status_t   regular_status;

  // Assemble regular result
  assign regular_result    = {rounded_sign, rounded_abs};
  assign regular_status.NV = 1'b0; // only valid cases are handled in regular path
  assign regular_status.DZ = 1'b0; // no divisions
  assign regular_status.OF = of_before_round | of_after_round;   // rounding can introduce overflow
  assign regular_status.UF = uf_after_round & regular_status.NX; // only inexact results raise UF
  assign regular_status.NX = (| round_sticky_bits) | of_before_round | of_after_round;

  // Final results for output pipeline
  fp_t                result_d;
  fpnew_pkg::status_t status_d;

  // Select output depending on special case detection
  assign result_d = result_is_special_q ? special_result_q : regular_result;
  assign status_d = result_is_special_q ? special_status_q : regular_status;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  fp_t                [0:NUM_OUT_REGS] out_pipe_result_q;
  fpnew_pkg::status_t [0:NUM_OUT_REGS] out_pipe_status_q;
  TagType             [0:NUM_OUT_REGS] out_pipe_tag_q;
  logic               [0:NUM_OUT_REGS] out_pipe_mask_q;
  AuxType             [0:NUM_OUT_REGS] out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS] out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0] = result_d;
  assign out_pipe_status_q[0] = status_d;
  assign out_pipe_tag_q[0]    = mid_pipe_tag_q[NUM_MID_REGS];
  assign out_pipe_mask_q[0]   = mid_pipe_mask_q[NUM_MID_REGS];
  assign out_pipe_aux_q[0]    = mid_pipe_aux_q[NUM_MID_REGS];
  assign out_pipe_valid_q[0]  = mid_pipe_valid_q[NUM_MID_REGS];
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign mid_pipe_ready[NUM_MID_REGS] = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + NUM_MID_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1], out_pipe_result_q[i], reg_ena, '0)
    `FFL(out_pipe_status_q[i+1], out_pipe_status_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],    out_pipe_tag_q[i],    reg_ena, TagType'('0))
    `FFL(out_pipe_mask_q[i+1],   out_pipe_mask_q[i],   reg_ena, '0)
    `FFL(out_pipe_aux_q[i+1],    out_pipe_aux_q[i],    reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = 1'b1; // always NaN-Box result
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, mid_pipe_valid_q, out_pipe_valid_q});
endmodule
// ----- 8< ----- FILE "./fpnew_fma_multi.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>



module fpnew_fma_multi #(
  parameter fpnew_pkg::fmt_logic_t   FpFmtConfig = '1,
  parameter int unsigned             NumPipeRegs = 0,
  parameter fpnew_pkg::pipe_config_t PipeConfig  = fpnew_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH       = fpnew_pkg::max_fp_width(FpFmtConfig),
  localparam int unsigned NUM_FORMATS = fpnew_pkg::NUM_FP_FORMATS,
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input  logic                        clk_i,
  input  logic                        rst_ni,
  // Input signals
  input  logic [2:0][WIDTH-1:0]       operands_i, // 3 operands
  input  logic [NUM_FORMATS-1:0][2:0] is_boxed_i, // 3 operands
  input  fpnew_pkg::roundmode_e       rnd_mode_i,
  input  fpnew_pkg::operation_e       op_i,
  input  logic                        op_mod_i,
  input  fpnew_pkg::fp_format_e       src_fmt_i, // format of the multiplicands
  input  fpnew_pkg::fp_format_e       dst_fmt_i, // format of the addend and result
  input  TagType                      tag_i,
  input  logic                        mask_i,
  input  AuxType                      aux_i,
  // Input Handshake
  input  logic                        in_valid_i,
  output logic                        in_ready_o,
  input  logic                        flush_i,
  // Output signals
  output logic [WIDTH-1:0]            result_o,
  output fpnew_pkg::status_t          status_o,
  output logic                        extension_bit_o,
  output TagType                      tag_o,
  output logic                        mask_o,
  output AuxType                      aux_o,
  // Output handshake
  output logic                        out_valid_o,
  input  logic                        out_ready_i,
  // Indication of valid data in flight
  output logic                        busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0]   reg_ena_i
);

  // ----------
  // Constants
  // ----------
  // The super-format that can hold all formats
  localparam fpnew_pkg::fp_encoding_t SUPER_FORMAT = fpnew_pkg::super_format(FpFmtConfig);

  localparam int unsigned SUPER_EXP_BITS = SUPER_FORMAT.exp_bits;
  localparam int unsigned SUPER_MAN_BITS = SUPER_FORMAT.man_bits;

  // Precision bits 'p' include the implicit bit
  localparam int unsigned PRECISION_BITS = SUPER_MAN_BITS + 1;
  // The lower 2p+3 bits of the internal FMA result will be needed for leading-zero detection
  localparam int unsigned LOWER_SUM_WIDTH  = 2 * PRECISION_BITS + 3;
  localparam int unsigned LZC_RESULT_WIDTH = $clog2(LOWER_SUM_WIDTH);
  // Internal exponent width of FMA must accomodate all meaningful exponent values in order to avoid
  // datapath leakage. This is either given by the exponent bits or the width of the LZC result.
  // In most reasonable FP formats the internal exponent will be wider than the LZC result.
  localparam int unsigned EXP_WIDTH = fpnew_pkg::maximum(SUPER_EXP_BITS + 2, LZC_RESULT_WIDTH);
  // Shift amount width: maximum internal mantissa size is 3p+4 bits
  localparam int unsigned SHIFT_AMOUNT_WIDTH = $clog2(3 * PRECISION_BITS + 5);
  // Pipelines
  localparam NUM_INP_REGS = PipeConfig == fpnew_pkg::BEFORE
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 3) // Second to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_MID_REGS = PipeConfig == fpnew_pkg::INSIDE
                          ? NumPipeRegs
                          : (PipeConfig == fpnew_pkg::DISTRIBUTED
                             ? ((NumPipeRegs + 2) / 3) // First to get distributed regs
                             : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = PipeConfig == fpnew_pkg::AFTER
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 3) // Last to get distributed regs
                               : 0); // no regs here otherwise

  // ----------------
  // Type definition
  // ----------------
  typedef struct packed {
    logic                      sign;
    logic [SUPER_EXP_BITS-1:0] exponent;
    logic [SUPER_MAN_BITS-1:0] mantissa;
  } fp_t;

  // ---------------
  // Input pipeline
  // ---------------
  // Selected pipeline output signals as non-arrays
  logic [2:0][WIDTH-1:0] operands_q;
  fpnew_pkg::fp_format_e src_fmt_q;
  fpnew_pkg::fp_format_e dst_fmt_q;

  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][2:0][WIDTH-1:0]       inp_pipe_operands_q;
  logic                  [0:NUM_INP_REGS][NUM_FORMATS-1:0][2:0] inp_pipe_is_boxed_q;
  fpnew_pkg::roundmode_e [0:NUM_INP_REGS]                       inp_pipe_rnd_mode_q;
  fpnew_pkg::operation_e [0:NUM_INP_REGS]                       inp_pipe_op_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_op_mod_q;
  fpnew_pkg::fp_format_e [0:NUM_INP_REGS]                       inp_pipe_src_fmt_q;
  fpnew_pkg::fp_format_e [0:NUM_INP_REGS]                       inp_pipe_dst_fmt_q;
  TagType                [0:NUM_INP_REGS]                       inp_pipe_tag_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_mask_q;
  AuxType                [0:NUM_INP_REGS]                       inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_is_boxed_q[0] = is_boxed_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_op_mod_q[0]   = op_mod_i;
  assign inp_pipe_src_fmt_q[0]  = src_fmt_i;
  assign inp_pipe_dst_fmt_q[0]  = dst_fmt_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_mask_q[0]     = mask_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, fpnew_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, fpnew_pkg::FMADD)
    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)
    `FFL(inp_pipe_src_fmt_q[i+1],  inp_pipe_src_fmt_q[i],  reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(inp_pipe_dst_fmt_q[i+1],  inp_pipe_dst_fmt_q[i],  reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign operands_q = inp_pipe_operands_q[NUM_INP_REGS];
  assign src_fmt_q  = inp_pipe_src_fmt_q[NUM_INP_REGS];
  assign dst_fmt_q  = inp_pipe_dst_fmt_q[NUM_INP_REGS];

  // -----------------
  // Input processing
  // -----------------
  logic        [NUM_FORMATS-1:0][2:0]                     fmt_sign;
  logic signed [NUM_FORMATS-1:0][2:0][SUPER_EXP_BITS-1:0] fmt_exponent;
  logic        [NUM_FORMATS-1:0][2:0][SUPER_MAN_BITS-1:0] fmt_mantissa;

  fpnew_pkg::fp_info_t [NUM_FORMATS-1:0][2:0] info_q;

  // FP Input initialization
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : fmt_init_inputs
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      logic [2:0][FP_WIDTH-1:0] trimmed_ops;

      // Classify input
      fpnew_classifier #(
        .FpFormat    ( fpnew_pkg::fp_format_e'(fmt) ),
        .NumOperands ( 3                            )
      ) i_fpnew_classifier (
        .operands_i ( trimmed_ops                            ),
        .is_boxed_i ( inp_pipe_is_boxed_q[NUM_INP_REGS][fmt] ),
        .info_o     ( info_q[fmt]                            )
      );
      for (genvar op = 0; op < 3; op++) begin : gen_operands
        assign trimmed_ops[op]       = operands_q[op][FP_WIDTH-1:0];
        assign fmt_sign[fmt][op]     = operands_q[op][FP_WIDTH-1];
        assign fmt_exponent[fmt][op] = signed'({1'b0, operands_q[op][MAN_BITS+:EXP_BITS]});
        assign fmt_mantissa[fmt][op] = {info_q[fmt][op].is_normal, operands_q[op][MAN_BITS-1:0]} <<
                                       (SUPER_MAN_BITS - MAN_BITS); // move to left of mantissa
      end
    end else begin : inactive_format
      assign info_q[fmt]                 = '{default: fpnew_pkg::DONT_CARE}; // format disabled
      assign fmt_sign[fmt]               = fpnew_pkg::DONT_CARE;             // format disabled
      assign fmt_exponent[fmt]           = '{default: fpnew_pkg::DONT_CARE}; // format disabled
      assign fmt_mantissa[fmt]           = '{default: fpnew_pkg::DONT_CARE}; // format disabled
    end
  end

  fp_t                 operand_a, operand_b, operand_c;
  fpnew_pkg::fp_info_t info_a,    info_b,    info_c;

  // Operation selection and operand adjustment
  // | \c op_q  | \c op_mod_q | Operation Adjustment
  // |:--------:|:-----------:|---------------------
  // | FMADD    | \c 0        | FMADD: none
  // | FMADD    | \c 1        | FMSUB: Invert sign of operand C
  // | FNMSUB   | \c 0        | FNMSUB: Invert sign of operand A
  // | FNMSUB   | \c 1        | FNMADD: Invert sign of operands A and C
  // | ADD      | \c 0        | ADD: Set operand A to +1.0
  // | ADD      | \c 1        | SUB: Set operand A to +1.0, invert sign of operand C
  // | MUL      | \c 0        | MUL: Set operand C to +0.0 or -0.0 depending on the rounding mode
  // | *others* | \c -        | *invalid*
  // \note \c op_mod_q always inverts the sign of the addend.
  always_comb begin : op_select

    // Default assignments - packing-order-agnostic
    operand_a = {fmt_sign[src_fmt_q][0], fmt_exponent[src_fmt_q][0], fmt_mantissa[src_fmt_q][0]};
    operand_b = {fmt_sign[src_fmt_q][1], fmt_exponent[src_fmt_q][1], fmt_mantissa[src_fmt_q][1]};
    operand_c = {fmt_sign[dst_fmt_q][2], fmt_exponent[dst_fmt_q][2], fmt_mantissa[dst_fmt_q][2]};
    info_a    = info_q[src_fmt_q][0];
    info_b    = info_q[src_fmt_q][1];
    info_c    = info_q[dst_fmt_q][2];

    // op_mod_q inverts sign of operand C
    operand_c.sign = operand_c.sign ^ inp_pipe_op_mod_q[NUM_INP_REGS];

    unique case (inp_pipe_op_q[NUM_INP_REGS])
      fpnew_pkg::FMADD:  ; // do nothing
      fpnew_pkg::FNMSUB: operand_a.sign = ~operand_a.sign; // invert sign of product
      fpnew_pkg::ADD: begin // Set multiplicand to +1
        operand_a = '{sign: 1'b0, exponent: fpnew_pkg::bias(src_fmt_q), mantissa: '0};
        info_a    = '{is_normal: 1'b1, is_boxed: 1'b1, default: 1'b0}; //normal, boxed value.
      end
      fpnew_pkg::MUL: begin // Set addend to +0 or -0, depending whether the rounding mode is RDN
        if (inp_pipe_rnd_mode_q[NUM_INP_REGS] == fpnew_pkg::RDN)
          operand_c = '{sign: 1'b0, exponent: '0, mantissa: '0};
        else
          operand_c = '{sign: 1'b1, exponent: '0, mantissa: '0};
        info_c    = '{is_zero: 1'b1, is_boxed: 1'b1, default: 1'b0}; //zero, boxed value.
      end
      default: begin // propagate don't cares
        operand_a  = '{default: fpnew_pkg::DONT_CARE};
        operand_b  = '{default: fpnew_pkg::DONT_CARE};
        operand_c  = '{default: fpnew_pkg::DONT_CARE};
        info_a     = '{default: fpnew_pkg::DONT_CARE};
        info_b     = '{default: fpnew_pkg::DONT_CARE};
        info_c     = '{default: fpnew_pkg::DONT_CARE};
      end
    endcase
  end

  // ---------------------
  // Input classification
  // ---------------------
  logic any_operand_inf;
  logic any_operand_nan;
  logic signalling_nan;
  logic effective_subtraction;
  logic tentative_sign;

  // Reduction for special case handling
  assign any_operand_inf = (| {info_a.is_inf,        info_b.is_inf,        info_c.is_inf});
  assign any_operand_nan = (| {info_a.is_nan,        info_b.is_nan,        info_c.is_nan});
  assign signalling_nan  = (| {info_a.is_signalling, info_b.is_signalling, info_c.is_signalling});
  // Effective subtraction in FMA occurs when product and addend signs differ
  assign effective_subtraction = operand_a.sign ^ operand_b.sign ^ operand_c.sign;
  // The tentative sign of the FMA shall be the sign of the product
  assign tentative_sign = operand_a.sign ^ operand_b.sign;

  // ----------------------
  // Special case handling
  // ----------------------
  logic [WIDTH-1:0]   special_result;
  fpnew_pkg::status_t special_status;
  logic               result_is_special;

  logic [NUM_FORMATS-1:0][WIDTH-1:0]    fmt_special_result;
  fpnew_pkg::status_t [NUM_FORMATS-1:0] fmt_special_status;
  logic [NUM_FORMATS-1:0]               fmt_result_is_special;


  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_special_results
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    localparam logic [EXP_BITS-1:0] QNAN_EXPONENT = '1;
    localparam logic [MAN_BITS-1:0] QNAN_MANTISSA = 2**(MAN_BITS-1);
    localparam logic [MAN_BITS-1:0] ZERO_MANTISSA = '0;

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : special_results
        logic [FP_WIDTH-1:0] special_res;

        // Default assignment
        special_res                = {1'b0, QNAN_EXPONENT, QNAN_MANTISSA}; // qNaN
        fmt_special_status[fmt]    = '0;
        fmt_result_is_special[fmt] = 1'b0;

        // Handle potentially mixed nan & infinity input => important for the case where infinity and
        // zero are multiplied and added to a qnan.
        // RISC-V mandates raising the NV exception in these cases:
        // (inf * 0) + c or (0 * inf) + c INVALID, no matter c (even quiet NaNs)
        if ((info_a.is_inf && info_b.is_zero) || (info_a.is_zero && info_b.is_inf)) begin
          fmt_result_is_special[fmt] = 1'b1; // bypass FMA, output is the canonical qNaN
          fmt_special_status[fmt].NV = 1'b1; // invalid operation
        // NaN Inputs cause canonical quiet NaN at the output and maybe invalid OP
        end else if (any_operand_nan) begin
          fmt_result_is_special[fmt] = 1'b1;           // bypass FMA, output is the canonical qNaN
          fmt_special_status[fmt].NV = signalling_nan; // raise the invalid operation flag if signalling
        // Special cases involving infinity
        end else if (any_operand_inf) begin
          fmt_result_is_special[fmt] = 1'b1; // bypass FMA
          // Effective addition of opposite infinities (??inf - ??inf) is invalid!
          if ((info_a.is_inf || info_b.is_inf) && info_c.is_inf && effective_subtraction)
            fmt_special_status[fmt].NV = 1'b1; // invalid operation
          // Handle cases where output will be inf because of inf product input
          else if (info_a.is_inf || info_b.is_inf) begin
            // Result is infinity with the sign of the product
            special_res = {operand_a.sign ^ operand_b.sign, QNAN_EXPONENT, ZERO_MANTISSA};
          // Handle cases where the addend is inf
          end else if (info_c.is_inf) begin
            // Result is inifinity with sign of the addend (= operand_c)
            special_res = {operand_c.sign, QNAN_EXPONENT, ZERO_MANTISSA};
          end
        end
        // Initialize special result with ones (NaN-box)
        fmt_special_result[fmt]               = '1;
        fmt_special_result[fmt][FP_WIDTH-1:0] = special_res;
      end
    end else begin : inactive_format
      assign fmt_special_result[fmt] = '{default: fpnew_pkg::DONT_CARE};
      assign fmt_special_status[fmt] = '0;
      assign fmt_result_is_special[fmt] = 1'b0;
    end
  end

  // Detect special case from source format, I2F casts don't produce a special result
  assign result_is_special = fmt_result_is_special[dst_fmt_q]; // they're all the same
  // Signalling input NaNs raise invalid flag, otherwise no flags set
  assign special_status = fmt_special_status[dst_fmt_q];
  // Assemble result according to destination format
  assign special_result = fmt_special_result[dst_fmt_q]; // destination format

  // ---------------------------
  // Initial exponent data path
  // ---------------------------
  logic signed [EXP_WIDTH-1:0] exponent_a, exponent_b, exponent_c;
  logic signed [EXP_WIDTH-1:0] exponent_addend, exponent_product, exponent_difference;
  logic signed [EXP_WIDTH-1:0] tentative_exponent;

  // Zero-extend exponents into signed container - implicit width extension
  assign exponent_a = signed'({1'b0, operand_a.exponent});
  assign exponent_b = signed'({1'b0, operand_b.exponent});
  assign exponent_c = signed'({1'b0, operand_c.exponent});

  // Calculate internal exponents from encoded values. Real exponents are (ex = Ex - bias + 1 - nx)
  // with Ex the encoded exponent and nx the implicit bit. Internal exponents are biased to dst fmt.
  assign exponent_addend = signed'(exponent_c + $signed({1'b0, ~info_c.is_normal})); // 0 as subnorm
  // Biased product exponent is the sum of encoded exponents minus the bias.
  assign exponent_product = (info_a.is_zero || info_b.is_zero) // in case the product is zero, set minimum exp.
                            ? 2 - signed'(fpnew_pkg::bias(dst_fmt_q))
                            : signed'(exponent_a + info_a.is_subnormal
                                      + exponent_b + info_b.is_subnormal
                                      - 2*signed'(fpnew_pkg::bias(src_fmt_q))
                                      + signed'(fpnew_pkg::bias(dst_fmt_q))); // rebias for dst fmt
  // Exponent difference is the addend exponent minus the product exponent
  assign exponent_difference = exponent_addend - exponent_product;
  // The tentative exponent will be the larger of the product or addend exponent
  assign tentative_exponent = (exponent_difference > 0) ? exponent_addend : exponent_product;

  // Shift amount for addend based on exponents (unsigned as only right shifts)
  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt;

  always_comb begin : addend_shift_amount
    // Product-anchored case, saturated shift (addend is only in the sticky bit)
    if (exponent_difference <= signed'(-2 * PRECISION_BITS - 1))
      addend_shamt = 3 * PRECISION_BITS + 4;
    // Addend and product will have mutual bits to add
    else if (exponent_difference <= signed'(PRECISION_BITS + 2))
      addend_shamt = unsigned'(signed'(PRECISION_BITS) + 3 - exponent_difference);
    // Addend-anchored case, saturated shift (product is only in the sticky bit)
    else
      addend_shamt = 0;
  end

  // ------------------
  // Product data path
  // ------------------
  logic [PRECISION_BITS-1:0]   mantissa_a, mantissa_b, mantissa_c;
  logic [2*PRECISION_BITS-1:0] product;             // the p*p product is 2p bits wide
  logic [3*PRECISION_BITS+3:0] product_shifted;     // addends are 3p+4 bit wide (including G/R)

  // Add implicit bits to mantissae
  assign mantissa_a = {info_a.is_normal, operand_a.mantissa};
  assign mantissa_b = {info_b.is_normal, operand_b.mantissa};
  assign mantissa_c = {info_c.is_normal, operand_c.mantissa};

  // Mantissa multiplier (a*b)
  assign product = mantissa_a * mantissa_b;

  // Product is placed into a 3p+4 bit wide vector, padded with 2 bits for round and sticky:
  // | 000...000 | product | RS |
  //  <-  p+2  -> <-  2p -> < 2>
  assign product_shifted = product << 2; // constant shift

  // -----------------
  // Addend data path
  // -----------------
  logic [3*PRECISION_BITS+3:0] addend_after_shift;  // upper 3p+4 bits are needed to go on
  logic [PRECISION_BITS-1:0]   addend_sticky_bits;  // up to p bit of shifted addend are sticky
  logic                        sticky_before_add;   // they are compressed into a single sticky bit
  logic [3*PRECISION_BITS+3:0] addend_shifted;      // addends are 3p+4 bit wide (including G/R)
  logic                        inject_carry_in;     // inject carry for subtractions if needed

  // In parallel, the addend is right-shifted according to the exponent difference. Up to p bits are
  // shifted out and compressed into a sticky bit.
  // BEFORE THE SHIFT:
  // | mantissa_c | 000..000 |
  //  <-    p   -> <- 3p+4 ->
  // AFTER THE SHIFT:
  // | 000..........000 | mantissa_c | 000...............0GR |  sticky bits  |
  //  <- addend_shamt -> <-    p   -> <- 2p+4-addend_shamt -> <-  up to p  ->
  assign {addend_after_shift, addend_sticky_bits} =
      (mantissa_c << (3 * PRECISION_BITS + 4)) >> addend_shamt;

  assign sticky_before_add     = (| addend_sticky_bits);

  // In case of a subtraction, the addend is inverted
  assign addend_shifted = (effective_subtraction) ? ~addend_after_shift : addend_after_shift;
  assign inject_carry_in = effective_subtraction & ~sticky_before_add;

  // ------
  // Adder
  // ------
  logic [3*PRECISION_BITS+4:0] sum_raw;   // added one bit for the carry
  logic                        sum_carry; // observe carry bit from sum for sign fixing
  logic [3*PRECISION_BITS+3:0] sum;       // discard carry as sum won't overflow
  logic                        final_sign;

  //Mantissa adder (ab+c). In normal addition, it cannot overflow.
  assign sum_raw = product_shifted + addend_shifted + inject_carry_in;
  assign sum_carry = sum_raw[3*PRECISION_BITS+4];

  // Complement negative sum (can only happen in subtraction -> overflows for positive results)
  assign sum        = (effective_subtraction && ~sum_carry) ? -sum_raw : sum_raw;

  // In case of a mispredicted subtraction result, do a sign flip
  assign final_sign = (effective_subtraction && (sum_carry == tentative_sign))
                      ? 1'b1
                      : (effective_subtraction ? 1'b0 : tentative_sign);

  // ---------------
  // Internal pipeline
  // ---------------
  // Pipeline output signals as non-arrays
  logic                          effective_subtraction_q;
  logic signed [EXP_WIDTH-1:0]   exponent_product_q;
  logic signed [EXP_WIDTH-1:0]   exponent_difference_q;
  logic signed [EXP_WIDTH-1:0]   tentative_exponent_q;
  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt_q;
  logic                          sticky_before_add_q;
  logic [3*PRECISION_BITS+3:0]   sum_q;
  logic                          final_sign_q;
  fpnew_pkg::fp_format_e         dst_fmt_q2;
  fpnew_pkg::roundmode_e         rnd_mode_q;
  logic                          result_is_special_q;
  fp_t                           special_result_q;
  fpnew_pkg::status_t            special_status_q;
  // Internal pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_MID_REGS]                         mid_pipe_eff_sub_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_prod_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_diff_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_tent_exp_q;
  logic                  [0:NUM_MID_REGS][SHIFT_AMOUNT_WIDTH-1:0] mid_pipe_add_shamt_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_sticky_q;
  logic                  [0:NUM_MID_REGS][3*PRECISION_BITS+3:0]   mid_pipe_sum_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_final_sign_q;
  fpnew_pkg::roundmode_e [0:NUM_MID_REGS]                         mid_pipe_rnd_mode_q;
  fpnew_pkg::fp_format_e [0:NUM_MID_REGS]                         mid_pipe_dst_fmt_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_res_is_spec_q;
  fp_t                   [0:NUM_MID_REGS]                         mid_pipe_spec_res_q;
  fpnew_pkg::status_t    [0:NUM_MID_REGS]                         mid_pipe_spec_stat_q;
  TagType                [0:NUM_MID_REGS]                         mid_pipe_tag_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_mask_q;
  AuxType                [0:NUM_MID_REGS]                         mid_pipe_aux_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_MID_REGS] mid_pipe_ready;

  // Input stage: First element of pipeline is taken from upstream logic
  assign mid_pipe_eff_sub_q[0]     = effective_subtraction;
  assign mid_pipe_exp_prod_q[0]    = exponent_product;
  assign mid_pipe_exp_diff_q[0]    = exponent_difference;
  assign mid_pipe_tent_exp_q[0]    = tentative_exponent;
  assign mid_pipe_add_shamt_q[0]   = addend_shamt;
  assign mid_pipe_sticky_q[0]      = sticky_before_add;
  assign mid_pipe_sum_q[0]         = sum;
  assign mid_pipe_final_sign_q[0]  = final_sign;
  assign mid_pipe_rnd_mode_q[0]    = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign mid_pipe_dst_fmt_q[0]     = dst_fmt_q;
  assign mid_pipe_res_is_spec_q[0] = result_is_special;
  assign mid_pipe_spec_res_q[0]    = special_result;
  assign mid_pipe_spec_stat_q[0]   = special_status;
  assign mid_pipe_tag_q[0]         = inp_pipe_tag_q[NUM_INP_REGS];
  assign mid_pipe_mask_q[0]        = inp_pipe_mask_q[NUM_INP_REGS];
  assign mid_pipe_aux_q[0]         = inp_pipe_aux_q[NUM_INP_REGS];
  assign mid_pipe_valid_q[0]       = inp_pipe_valid_q[NUM_INP_REGS];
  // Input stage: Propagate pipeline ready signal to input pipe
  assign inp_pipe_ready[NUM_INP_REGS] = mid_pipe_ready[0];

  // Generate the register stages
  for (genvar i = 0; i < NUM_MID_REGS; i++) begin : gen_inside_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign mid_pipe_ready[i] = mid_pipe_ready[i+1] | ~mid_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(mid_pipe_valid_q[i+1], mid_pipe_valid_q[i], mid_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (mid_pipe_ready[i] & mid_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(mid_pipe_eff_sub_q[i+1],     mid_pipe_eff_sub_q[i],     reg_ena, '0)
    `FFL(mid_pipe_exp_prod_q[i+1],    mid_pipe_exp_prod_q[i],    reg_ena, '0)
    `FFL(mid_pipe_exp_diff_q[i+1],    mid_pipe_exp_diff_q[i],    reg_ena, '0)
    `FFL(mid_pipe_tent_exp_q[i+1],    mid_pipe_tent_exp_q[i],    reg_ena, '0)
    `FFL(mid_pipe_add_shamt_q[i+1],   mid_pipe_add_shamt_q[i],   reg_ena, '0)
    `FFL(mid_pipe_sticky_q[i+1],      mid_pipe_sticky_q[i],      reg_ena, '0)
    `FFL(mid_pipe_sum_q[i+1],         mid_pipe_sum_q[i],         reg_ena, '0)
    `FFL(mid_pipe_final_sign_q[i+1],  mid_pipe_final_sign_q[i],  reg_ena, '0)
    `FFL(mid_pipe_rnd_mode_q[i+1],    mid_pipe_rnd_mode_q[i],    reg_ena, fpnew_pkg::RNE)
    `FFL(mid_pipe_dst_fmt_q[i+1],     mid_pipe_dst_fmt_q[i],     reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(mid_pipe_res_is_spec_q[i+1], mid_pipe_res_is_spec_q[i], reg_ena, '0)
    `FFL(mid_pipe_spec_res_q[i+1],    mid_pipe_spec_res_q[i],    reg_ena, '0)
    `FFL(mid_pipe_spec_stat_q[i+1],   mid_pipe_spec_stat_q[i],   reg_ena, '0)
    `FFL(mid_pipe_tag_q[i+1],         mid_pipe_tag_q[i],         reg_ena, TagType'('0))
    `FFL(mid_pipe_mask_q[i+1],        mid_pipe_mask_q[i],        reg_ena, '0)
    `FFL(mid_pipe_aux_q[i+1],         mid_pipe_aux_q[i],         reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign effective_subtraction_q = mid_pipe_eff_sub_q[NUM_MID_REGS];
  assign exponent_product_q      = mid_pipe_exp_prod_q[NUM_MID_REGS];
  assign exponent_difference_q   = mid_pipe_exp_diff_q[NUM_MID_REGS];
  assign tentative_exponent_q    = mid_pipe_tent_exp_q[NUM_MID_REGS];
  assign addend_shamt_q          = mid_pipe_add_shamt_q[NUM_MID_REGS];
  assign sticky_before_add_q     = mid_pipe_sticky_q[NUM_MID_REGS];
  assign sum_q                   = mid_pipe_sum_q[NUM_MID_REGS];
  assign final_sign_q            = mid_pipe_final_sign_q[NUM_MID_REGS];
  assign rnd_mode_q              = mid_pipe_rnd_mode_q[NUM_MID_REGS];
  assign dst_fmt_q2              = mid_pipe_dst_fmt_q[NUM_MID_REGS];
  assign result_is_special_q     = mid_pipe_res_is_spec_q[NUM_MID_REGS];
  assign special_result_q        = mid_pipe_spec_res_q[NUM_MID_REGS];
  assign special_status_q        = mid_pipe_spec_stat_q[NUM_MID_REGS];

  // --------------
  // Normalization
  // --------------
  logic        [LOWER_SUM_WIDTH-1:0]  sum_lower;              // lower 2p+3 bits of sum are searched
  logic        [LZC_RESULT_WIDTH-1:0] leading_zero_count;     // the number of leading zeroes
  logic signed [LZC_RESULT_WIDTH:0]   leading_zero_count_sgn; // signed leading-zero count
  logic                               lzc_zeroes;             // in case only zeroes found

  logic        [SHIFT_AMOUNT_WIDTH-1:0] norm_shamt; // Normalization shift amount
  logic signed [EXP_WIDTH-1:0]          normalized_exponent;

  logic [3*PRECISION_BITS+4:0] sum_shifted;       // result after first normalization shift
  logic [PRECISION_BITS:0]     final_mantissa;    // final mantissa before rounding with round bit
  logic [2*PRECISION_BITS+2:0] sum_sticky_bits;   // remaining 2p+3 sticky bits after normalization
  logic                        sticky_after_norm; // sticky bit after normalization

  logic signed [EXP_WIDTH-1:0] final_exponent;

  assign sum_lower = sum_q[LOWER_SUM_WIDTH-1:0];

  // Leading zero counter for cancellations
  lzc #(
    .WIDTH ( LOWER_SUM_WIDTH ),
    .MODE  ( 1               ) // MODE = 1 counts leading zeroes
  ) i_lzc (
    .in_i    ( sum_lower          ),
    .cnt_o   ( leading_zero_count ),
    .empty_o ( lzc_zeroes         )
  );

  assign leading_zero_count_sgn = signed'({1'b0, leading_zero_count});

  // Normalization shift amount based on exponents and LZC (unsigned as only left shifts)
  always_comb begin : norm_shift_amount
    // Product-anchored case or cancellations require LZC
    if ((exponent_difference_q <= 0) || (effective_subtraction_q && (exponent_difference_q <= 2))) begin
      // Normal result (biased exponent > 0 and not a zero)
      if ((exponent_product_q - leading_zero_count_sgn + 1 >= 0) && !lzc_zeroes) begin
        // Undo initial product shift, remove the counted zeroes
        norm_shamt          = PRECISION_BITS + 2 + leading_zero_count;
        normalized_exponent = exponent_product_q - leading_zero_count_sgn + 1; // account for shift
      // Subnormal result
      end else begin
        // Cap the shift distance to align mantissa with minimum exponent
        norm_shamt          = unsigned'(signed'(PRECISION_BITS + 2 + exponent_product_q));
        normalized_exponent = 0; // subnormals encoded as 0
      end
    // Addend-anchored case
    end else begin
      norm_shamt          = addend_shamt_q; // Undo the initial shift
      normalized_exponent = tentative_exponent_q;
    end
  end

  // Do the large normalization shift
  assign sum_shifted       = sum_q << norm_shamt;

  // The addend-anchored case needs a 1-bit normalization since the leading-one can be to the left
  // or right of the (non-carry) MSB of the sum.
  always_comb begin : small_norm
    // Default assignment, discarding carry bit
    {final_mantissa, sum_sticky_bits} = sum_shifted;
    final_exponent                    = normalized_exponent;

    // The normalized sum has overflown, align right and fix exponent
    if (sum_shifted[3*PRECISION_BITS+4]) begin // check the carry bit
      {final_mantissa, sum_sticky_bits} = sum_shifted >> 1;
      final_exponent                    = normalized_exponent + 1;
    // The normalized sum is normal, nothing to do
    end else if (sum_shifted[3*PRECISION_BITS+3]) begin // check the sum MSB
      // do nothing
    // The normalized sum is still denormal, align left - unless the result is not already subnormal
    end else if (normalized_exponent > 1) begin
      {final_mantissa, sum_sticky_bits} = sum_shifted << 1;
      final_exponent                    = normalized_exponent - 1;
    // Otherwise we're denormal
    end else begin
      final_exponent = '0;
    end
  end

  // Update the sticky bit with the shifted-out bits
  assign sticky_after_norm = (| {sum_sticky_bits}) | sticky_before_add_q;

  // ----------------------------
  // Rounding and classification
  // ----------------------------
  logic                                     pre_round_sign;
  logic [SUPER_EXP_BITS+SUPER_MAN_BITS-1:0] pre_round_abs; // absolute value of result before rounding
  logic [1:0]                               round_sticky_bits;

  logic of_before_round, of_after_round; // overflow
  logic uf_before_round, uf_after_round; // underflow

  logic [NUM_FORMATS-1:0][SUPER_EXP_BITS+SUPER_MAN_BITS-1:0] fmt_pre_round_abs; // per format
  logic [NUM_FORMATS-1:0][1:0]                               fmt_round_sticky_bits;

  logic [NUM_FORMATS-1:0]                                    fmt_of_after_round;
  logic [NUM_FORMATS-1:0]                                    fmt_uf_after_round;

  logic                                     rounded_sign;
  logic [SUPER_EXP_BITS+SUPER_MAN_BITS-1:0] rounded_abs; // absolute value of result after rounding
  logic                                     result_zero;

  // Classification before round. RISC-V mandates checking underflow AFTER rounding!
  assign of_before_round = final_exponent >= 2**(fpnew_pkg::exp_bits(dst_fmt_q2))-1; // infinity exponent is all ones
  assign uf_before_round = final_exponent == 0;               // exponent for subnormals capped to 0

  // Pack exponent and mantissa into proper rounding form
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_res_assemble
    // Set up some constants
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    logic [EXP_BITS-1:0] pre_round_exponent;
    logic [MAN_BITS-1:0] pre_round_mantissa;

    if (FpFmtConfig[fmt]) begin : active_format

      assign pre_round_exponent = (of_before_round) ? 2**EXP_BITS-2 : final_exponent[EXP_BITS-1:0];
      assign pre_round_mantissa = (of_before_round) ? '1 : final_mantissa[SUPER_MAN_BITS-:MAN_BITS];
      // Assemble result before rounding. In case of overflow, the largest normal value is set.
      assign fmt_pre_round_abs[fmt] = {pre_round_exponent, pre_round_mantissa}; // 0-extend

      // Round bit is after mantissa (1 in case of overflow for rounding)
      assign fmt_round_sticky_bits[fmt][1] = final_mantissa[SUPER_MAN_BITS-MAN_BITS] |
                                             of_before_round;

      // remaining bits in mantissa to sticky (1 in case of overflow for rounding)
      if (MAN_BITS < SUPER_MAN_BITS) begin : narrow_sticky
        assign fmt_round_sticky_bits[fmt][0] = (| final_mantissa[SUPER_MAN_BITS-MAN_BITS-1:0]) |
                                               sticky_after_norm | of_before_round;
      end else begin : normal_sticky
        assign fmt_round_sticky_bits[fmt][0] = sticky_after_norm | of_before_round;
      end
    end else begin : inactive_format
      assign fmt_pre_round_abs[fmt] = '{default: fpnew_pkg::DONT_CARE};
      assign fmt_round_sticky_bits[fmt] = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Assemble result before rounding. In case of overflow, the largest normal value is set.
  assign pre_round_sign     = final_sign_q;
  assign pre_round_abs      = fmt_pre_round_abs[dst_fmt_q2];

  // In case of overflow, the round and sticky bits are set for proper rounding
  assign round_sticky_bits  = fmt_round_sticky_bits[dst_fmt_q2];

  // Perform the rounding
  fpnew_rounding #(
    .AbsWidth ( SUPER_EXP_BITS + SUPER_MAN_BITS )
  ) i_fpnew_rounding (
    .abs_value_i             ( pre_round_abs           ),
    .sign_i                  ( pre_round_sign          ),
    .round_sticky_bits_i     ( round_sticky_bits       ),
    .rnd_mode_i              ( rnd_mode_q              ),
    .effective_subtraction_i ( effective_subtraction_q ),
    .abs_rounded_o           ( rounded_abs             ),
    .sign_o                  ( rounded_sign            ),
    .exact_zero_o            ( result_zero             )
  );

  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_result;

  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_sign_inject
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : post_process
        // detect of / uf        
        fmt_uf_after_round[fmt] = (rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0) // denormal
        || ((pre_round_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0) && (rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == 1) && 
              ((round_sticky_bits != 2'b11) || (!sum_sticky_bits[MAN_BITS*2 + 4] && ((rnd_mode_i == fpnew_pkg::RNE) || (rnd_mode_i == fpnew_pkg::RMM)))));
        fmt_of_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '1; // inf exp.

        // Assemble regular result, nan box short ones.
        fmt_result[fmt]               = '1;
        fmt_result[fmt][FP_WIDTH-1:0] = {rounded_sign, rounded_abs[EXP_BITS+MAN_BITS-1:0]};
      end
    end else begin : inactive_format
      assign fmt_uf_after_round[fmt] = fpnew_pkg::DONT_CARE;
      assign fmt_of_after_round[fmt] = fpnew_pkg::DONT_CARE;
      assign fmt_result[fmt]         = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Classification after rounding select by destination format
  assign uf_after_round = fmt_uf_after_round[dst_fmt_q2];
  assign of_after_round = fmt_of_after_round[dst_fmt_q2];


  // -----------------
  // Result selection
  // -----------------
  logic [WIDTH-1:0]     regular_result;
  fpnew_pkg::status_t   regular_status;

  // Assemble regular result
  assign regular_result = fmt_result[dst_fmt_q2];
  assign regular_status.NV = 1'b0; // only valid cases are handled in regular path
  assign regular_status.DZ = 1'b0; // no divisions
  assign regular_status.OF = of_before_round | of_after_round;   // rounding can introduce overflow
  assign regular_status.UF = uf_after_round & regular_status.NX; // only inexact results raise UF
  assign regular_status.NX = (| round_sticky_bits) | of_before_round | of_after_round;

  // Final results for output pipeline
  logic [WIDTH-1:0]   result_d;
  fpnew_pkg::status_t status_d;

  // Select output depending on special case detection
  assign result_d = result_is_special_q ? special_result_q : regular_result;
  assign status_d = result_is_special_q ? special_status_q : regular_status;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  logic               [0:NUM_OUT_REGS][WIDTH-1:0] out_pipe_result_q;
  fpnew_pkg::status_t [0:NUM_OUT_REGS]            out_pipe_status_q;
  TagType             [0:NUM_OUT_REGS]            out_pipe_tag_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_mask_q;
  AuxType             [0:NUM_OUT_REGS]            out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0] = result_d;
  assign out_pipe_status_q[0] = status_d;
  assign out_pipe_tag_q[0]    = mid_pipe_tag_q[NUM_MID_REGS];
  assign out_pipe_mask_q[0]   = mid_pipe_mask_q[NUM_MID_REGS];
  assign out_pipe_aux_q[0]    = mid_pipe_aux_q[NUM_MID_REGS];
  assign out_pipe_valid_q[0]  = mid_pipe_valid_q[NUM_MID_REGS];
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign mid_pipe_ready[NUM_MID_REGS] = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + NUM_MID_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1], out_pipe_result_q[i], reg_ena, '0)
    `FFL(out_pipe_status_q[i+1], out_pipe_status_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],    out_pipe_tag_q[i],    reg_ena, TagType'('0))
    `FFL(out_pipe_mask_q[i+1],   out_pipe_mask_q[i],   reg_ena, '0)
    `FFL(out_pipe_aux_q[i+1],    out_pipe_aux_q[i],    reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = 1'b1; // always NaN-Box result
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, mid_pipe_valid_q, out_pipe_valid_q});
endmodule
// ----- 8< ----- FILE "./fpnew_noncomp.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>



module fpnew_noncomp #(
  parameter fpnew_pkg::fp_format_e   FpFormat    = fpnew_pkg::fp_format_e'(0),
  parameter int unsigned             NumPipeRegs = 0,
  parameter fpnew_pkg::pipe_config_t PipeConfig  = fpnew_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH = fpnew_pkg::fp_width(FpFormat),
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input logic                  clk_i,
  input logic                  rst_ni,
  // Input signals
  input logic [1:0][WIDTH-1:0]     operands_i, // 2 operands
  input logic [1:0]                is_boxed_i, // 2 operands
  input fpnew_pkg::roundmode_e     rnd_mode_i,
  input fpnew_pkg::operation_e     op_i,
  input logic                      op_mod_i,
  input TagType                    tag_i,
  input logic                      mask_i,
  input AuxType                    aux_i,
  // Input Handshake
  input  logic                     in_valid_i,
  output logic                     in_ready_o,
  input  logic                     flush_i,
  // Output signals
  output logic [WIDTH-1:0]         result_o,
  output fpnew_pkg::status_t       status_o,
  output logic                     extension_bit_o,
  output fpnew_pkg::classmask_e    class_mask_o,
  output logic                     is_class_o,
  output TagType                   tag_o,
  output logic                     mask_o,
  output AuxType                   aux_o,
  // Output handshake
  output logic                     out_valid_o,
  input  logic                     out_ready_i,
  // Indication of valid data in flight
  output logic                     busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0] reg_ena_i
);

  // ----------
  // Constants
  // ----------
  localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(FpFormat);
  localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(FpFormat);
  // Pipelines
  localparam NUM_INP_REGS = (PipeConfig == fpnew_pkg::BEFORE || PipeConfig == fpnew_pkg::INSIDE)
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 2) // First to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = PipeConfig == fpnew_pkg::AFTER
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 2) // Last to get distributed regs
                               : 0); // no regs here otherwise

  // ----------------
  // Type definition
  // ----------------
  typedef struct packed {
    logic                sign;
    logic [EXP_BITS-1:0] exponent;
    logic [MAN_BITS-1:0] mantissa;
  } fp_t;

  // ---------------
  // Input pipeline
  // ---------------
  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][1:0][WIDTH-1:0] inp_pipe_operands_q;
  logic                  [0:NUM_INP_REGS][1:0]            inp_pipe_is_boxed_q;
  fpnew_pkg::roundmode_e [0:NUM_INP_REGS]                 inp_pipe_rnd_mode_q;
  fpnew_pkg::operation_e [0:NUM_INP_REGS]                 inp_pipe_op_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_op_mod_q;
  TagType                [0:NUM_INP_REGS]                 inp_pipe_tag_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_mask_q;
  AuxType                [0:NUM_INP_REGS]                 inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_is_boxed_q[0] = is_boxed_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_op_mod_q[0]   = op_mod_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_mask_q[0]     = mask_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, fpnew_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, fpnew_pkg::FMADD)
    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end

  // ---------------------
  // Input classification
  // ---------------------
  fpnew_pkg::fp_info_t [1:0] info_q;

  // Classify input
  fpnew_classifier #(
    .FpFormat    ( FpFormat ),
    .NumOperands ( 2        )
    ) i_class_a (
    .operands_i ( inp_pipe_operands_q[NUM_INP_REGS] ),
    .is_boxed_i ( inp_pipe_is_boxed_q[NUM_INP_REGS] ),
    .info_o     ( info_q                            )
  );

  fp_t                 operand_a, operand_b;
  fpnew_pkg::fp_info_t info_a,    info_b;

  // Packing-order-agnostic assignments
  assign operand_a = inp_pipe_operands_q[NUM_INP_REGS][0];
  assign operand_b = inp_pipe_operands_q[NUM_INP_REGS][1];
  assign info_a    = info_q[0];
  assign info_b    = info_q[1];

  logic any_operand_inf;
  logic any_operand_nan;
  logic signalling_nan;

  // Reduction for special case handling
  assign any_operand_inf = (| {info_a.is_inf,        info_b.is_inf});
  assign any_operand_nan = (| {info_a.is_nan,        info_b.is_nan});
  assign signalling_nan  = (| {info_a.is_signalling, info_b.is_signalling});

  logic operands_equal, operand_a_smaller;

  // Equality checks for zeroes too
  assign operands_equal    = (operand_a == operand_b) || (info_a.is_zero && info_b.is_zero);
  // Invert result if non-zero signs involved (unsigned comparison)
  assign operand_a_smaller = (operand_a < operand_b) ^ (operand_a.sign || operand_b.sign);

  // ---------------
  // Sign Injection
  // ---------------
  fp_t                sgnj_result;
  fpnew_pkg::status_t sgnj_status;
  logic               sgnj_extension_bit;

  // Sign Injection - operation is encoded in rnd_mode_q:
  // RNE = SGNJ, RTZ = SGNJN, RDN = SGNJX, RUP = Passthrough (no NaN-box check)
  always_comb begin : sign_injections
    logic sign_a, sign_b; // internal signs
    // Default assignment
    sgnj_result = operand_a; // result based on operand a

    // NaN-boxing check will treat invalid inputs as canonical NaNs
    if (!info_a.is_boxed) sgnj_result = '{sign: 1'b0, exponent: '1, mantissa: 2**(MAN_BITS-1)};

    // Internal signs are treated as positive in case of non-NaN-boxed values
    sign_a = operand_a.sign & info_a.is_boxed;
    sign_b = operand_b.sign & info_b.is_boxed;

    // Do the sign injection based on rm field
    unique case (inp_pipe_rnd_mode_q[NUM_INP_REGS])
      fpnew_pkg::RNE: sgnj_result.sign = sign_b;          // SGNJ
      fpnew_pkg::RTZ: sgnj_result.sign = ~sign_b;         // SGNJN
      fpnew_pkg::RDN: sgnj_result.sign = sign_a ^ sign_b; // SGNJX
      fpnew_pkg::RUP: sgnj_result      = operand_a;       // passthrough
      default: sgnj_result = '{default: fpnew_pkg::DONT_CARE}; // don't care
    endcase
  end

  assign sgnj_status = '0;        // sign injections never raise exceptions

  // op_mod_q enables integer sign-extension of result (for storing to integer regfile)
  assign sgnj_extension_bit = inp_pipe_op_mod_q[NUM_INP_REGS] ? sgnj_result.sign : 1'b1;

  // ------------------
  // Minimum / Maximum
  // ------------------
  fp_t                minmax_result;
  fpnew_pkg::status_t minmax_status;
  logic               minmax_extension_bit;

  // Minimum/Maximum - operation is encoded in rnd_mode_q:
  // RNE = MIN, RTZ = MAX
  always_comb begin : min_max
    // Default assignment
    minmax_status = '0;

    // Min/Max use quiet comparisons - only sNaN are invalid
    minmax_status.NV = signalling_nan;

    // Both NaN inputs cause a NaN output
    if (info_a.is_nan && info_b.is_nan)
      minmax_result = '{sign: 1'b0, exponent: '1, mantissa: 2**(MAN_BITS-1)}; // canonical qNaN
    // If one operand is NaN, the non-NaN operand is returned
    else if (info_a.is_nan) minmax_result = operand_b;
    else if (info_b.is_nan) minmax_result = operand_a;
    // Otherwise decide according to the operation
    else begin
      unique case (inp_pipe_rnd_mode_q[NUM_INP_REGS])
        fpnew_pkg::RNE: minmax_result = operand_a_smaller ? operand_a : operand_b; // MIN
        fpnew_pkg::RTZ: minmax_result = operand_a_smaller ? operand_b : operand_a; // MAX
        default: minmax_result = '{default: fpnew_pkg::DONT_CARE}; // don't care
      endcase
    end
  end

  assign minmax_extension_bit = 1'b1; // NaN-box as result is always a float value

  // ------------
  // Comparisons
  // ------------
  fp_t                cmp_result;
  fpnew_pkg::status_t cmp_status;
  logic               cmp_extension_bit;

  // Comparisons - operation is encoded in rnd_mode_q:
  // RNE = LE, RTZ = LT, RDN = EQ
  // op_mod_q inverts boolean outputs
  always_comb begin : comparisons
    // Default assignment
    cmp_result = '0; // false
    cmp_status = '0; // no flags

    // Signalling NaNs always compare as false and are illegal
    if (signalling_nan) cmp_status.NV = 1'b1; // invalid operation
    // Otherwise do comparisons
    else begin
      unique case (inp_pipe_rnd_mode_q[NUM_INP_REGS])
        fpnew_pkg::RNE: begin // Less than or equal
          if (any_operand_nan) cmp_status.NV = 1'b1; // Signalling comparison: NaNs are invalid
          else cmp_result = (operand_a_smaller | operands_equal) ^ inp_pipe_op_mod_q[NUM_INP_REGS];
        end
        fpnew_pkg::RTZ: begin // Less than
          if (any_operand_nan) cmp_status.NV = 1'b1; // Signalling comparison: NaNs are invalid
          else cmp_result = (operand_a_smaller & ~operands_equal) ^ inp_pipe_op_mod_q[NUM_INP_REGS];
        end
        fpnew_pkg::RDN: begin // Equal
          if (any_operand_nan) cmp_result = inp_pipe_op_mod_q[NUM_INP_REGS]; // NaN always not equal
          else cmp_result = operands_equal ^ inp_pipe_op_mod_q[NUM_INP_REGS];
        end
        default: cmp_result = '{default: fpnew_pkg::DONT_CARE}; // don't care
      endcase
    end
  end

  assign cmp_extension_bit = 1'b0; // Comparisons always produce booleans in integer registers

  // ---------------
  // Classification
  // ---------------
  fpnew_pkg::status_t    class_status;
  logic                  class_extension_bit;
  fpnew_pkg::classmask_e class_mask_d; // the result is actually here

  // Classification - always return the classification mask on the dedicated port
  always_comb begin : classify
    if (info_a.is_normal) begin
      class_mask_d = operand_a.sign       ? fpnew_pkg::NEGNORM    : fpnew_pkg::POSNORM;
    end else if (info_a.is_subnormal) begin
      class_mask_d = operand_a.sign       ? fpnew_pkg::NEGSUBNORM : fpnew_pkg::POSSUBNORM;
    end else if (info_a.is_zero) begin
      class_mask_d = operand_a.sign       ? fpnew_pkg::NEGZERO    : fpnew_pkg::POSZERO;
    end else if (info_a.is_inf) begin
      class_mask_d = operand_a.sign       ? fpnew_pkg::NEGINF     : fpnew_pkg::POSINF;
    end else if (info_a.is_nan) begin
      class_mask_d = info_a.is_signalling ? fpnew_pkg::SNAN       : fpnew_pkg::QNAN;
    end else begin
      class_mask_d = fpnew_pkg::QNAN; // default value
    end
  end

  assign class_status        = '0;   // classification does not set flags
  assign class_extension_bit = 1'b0; // classification always produces results in integer registers

  // -----------------
  // Result selection
  // -----------------
  fp_t                   result_d;
  fpnew_pkg::status_t    status_d;
  logic                  extension_bit_d;
  logic                  is_class_d;

  // Select result
  always_comb begin : select_result
    unique case (inp_pipe_op_q[NUM_INP_REGS])
      fpnew_pkg::SGNJ: begin
        result_d        = sgnj_result;
        status_d        = sgnj_status;
        extension_bit_d = sgnj_extension_bit;
      end
      fpnew_pkg::MINMAX: begin
        result_d        = minmax_result;
        status_d        = minmax_status;
        extension_bit_d = minmax_extension_bit;
      end
      fpnew_pkg::CMP: begin
        result_d        = cmp_result;
        status_d        = cmp_status;
        extension_bit_d = cmp_extension_bit;
      end
      fpnew_pkg::CLASSIFY: begin
        result_d        = '{default: fpnew_pkg::DONT_CARE}; // unused
        status_d        = class_status;
        extension_bit_d = class_extension_bit;
      end
      default: begin
        result_d        = '{default: fpnew_pkg::DONT_CARE}; // dont care
        status_d        = '{default: fpnew_pkg::DONT_CARE}; // dont care
        extension_bit_d = fpnew_pkg::DONT_CARE;             // dont care
      end
    endcase
  end

  assign is_class_d = (inp_pipe_op_q[NUM_INP_REGS] == fpnew_pkg::CLASSIFY);

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  fp_t                   [0:NUM_OUT_REGS] out_pipe_result_q;
  fpnew_pkg::status_t    [0:NUM_OUT_REGS] out_pipe_status_q;
  logic                  [0:NUM_OUT_REGS] out_pipe_extension_bit_q;
  fpnew_pkg::classmask_e [0:NUM_OUT_REGS] out_pipe_class_mask_q;
  logic                  [0:NUM_OUT_REGS] out_pipe_is_class_q;
  TagType                [0:NUM_OUT_REGS] out_pipe_tag_q;
  logic                  [0:NUM_OUT_REGS] out_pipe_mask_q;
  AuxType                [0:NUM_OUT_REGS] out_pipe_aux_q;
  logic                  [0:NUM_OUT_REGS] out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0]        = result_d;
  assign out_pipe_status_q[0]        = status_d;
  assign out_pipe_extension_bit_q[0] = extension_bit_d;
  assign out_pipe_class_mask_q[0]    = class_mask_d;
  assign out_pipe_is_class_q[0]      = is_class_d;
  assign out_pipe_tag_q[0]           = inp_pipe_tag_q[NUM_INP_REGS];
  assign out_pipe_mask_q[0]          = inp_pipe_mask_q[NUM_INP_REGS];
  assign out_pipe_aux_q[0]           = inp_pipe_aux_q[NUM_INP_REGS];
  assign out_pipe_valid_q[0]         = inp_pipe_valid_q[NUM_INP_REGS];
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign inp_pipe_ready[NUM_INP_REGS] = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1],        out_pipe_result_q[i],        reg_ena, '0)
    `FFL(out_pipe_status_q[i+1],        out_pipe_status_q[i],        reg_ena, '0)
    `FFL(out_pipe_extension_bit_q[i+1], out_pipe_extension_bit_q[i], reg_ena, '0)
    `FFL(out_pipe_class_mask_q[i+1],    out_pipe_class_mask_q[i],    reg_ena, fpnew_pkg::QNAN)
    `FFL(out_pipe_is_class_q[i+1],      out_pipe_is_class_q[i],      reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],           out_pipe_tag_q[i],           reg_ena, TagType'('0))
    `FFL(out_pipe_mask_q[i+1],          out_pipe_mask_q[i],          reg_ena, '0)
    `FFL(out_pipe_aux_q[i+1],           out_pipe_aux_q[i],           reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = out_pipe_extension_bit_q[NUM_OUT_REGS];
  assign class_mask_o    = out_pipe_class_mask_q[NUM_OUT_REGS];
  assign is_class_o      = out_pipe_is_class_q[NUM_OUT_REGS];
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, out_pipe_valid_q});
endmodule
// ----- 8< ----- FILE "./fpnew_opgroup_block.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module fpnew_opgroup_block #(
  parameter fpnew_pkg::opgroup_e        OpGroup       = fpnew_pkg::ADDMUL,
  // FPU configuration
  parameter int unsigned                Width         = 32,
  parameter logic                       EnableVectors = 1'b1,
  parameter logic                       PulpDivsqrt   = 1'b1,
  parameter fpnew_pkg::fmt_logic_t      FpFmtMask     = '1,
  parameter fpnew_pkg::ifmt_logic_t     IntFmtMask    = '1,
  parameter fpnew_pkg::fmt_unsigned_t   FmtPipeRegs   = '{default: 0},
  parameter fpnew_pkg::fmt_unit_types_t FmtUnitTypes  = '{default: fpnew_pkg::PARALLEL},
  parameter fpnew_pkg::pipe_config_t    PipeConfig    = fpnew_pkg::BEFORE,
  parameter type                        TagType       = logic,
  parameter int unsigned                TrueSIMDClass = 0,
  // Do not change
  localparam int unsigned NUM_FORMATS  = fpnew_pkg::NUM_FP_FORMATS,
  localparam int unsigned NUM_OPERANDS = fpnew_pkg::num_operands(OpGroup),
  localparam int unsigned NUM_LANES    = fpnew_pkg::max_num_lanes(Width, FpFmtMask, EnableVectors),
  localparam type         MaskType     = logic [NUM_LANES-1:0]
) (
  input logic                                     clk_i,
  input logic                                     rst_ni,
  // Input signals
  input logic [NUM_OPERANDS-1:0][Width-1:0]       operands_i,
  input logic [NUM_FORMATS-1:0][NUM_OPERANDS-1:0] is_boxed_i,
  input fpnew_pkg::roundmode_e                    rnd_mode_i,
  input fpnew_pkg::operation_e                    op_i,
  input logic                                     op_mod_i,
  input fpnew_pkg::fp_format_e                    src_fmt_i,
  input fpnew_pkg::fp_format_e                    dst_fmt_i,
  input fpnew_pkg::int_format_e                   int_fmt_i,
  input logic                                     vectorial_op_i,
  input TagType                                   tag_i,
  input MaskType                                  simd_mask_i,
  // Input Handshake
  input  logic                                    in_valid_i,
  output logic                                    in_ready_o,
  input  logic                                    flush_i,
  // Output signals
  output logic [Width-1:0]                        result_o,
  output fpnew_pkg::status_t                      status_o,
  output logic                                    extension_bit_o,
  output TagType                                  tag_o,
  // Output handshake
  output logic                                    out_valid_o,
  input  logic                                    out_ready_i,
  // Indication of valid data in flight
  output logic                                    busy_o
);

  // ----------------
  // Type Definition
  // ----------------
  typedef struct packed {
    logic [Width-1:0]   result;
    fpnew_pkg::status_t status;
    logic               ext_bit;
    TagType             tag;
  } output_t;

  // Handshake signals for the slices
  logic [NUM_FORMATS-1:0] fmt_in_ready, fmt_out_valid, fmt_out_ready, fmt_busy;
  output_t [NUM_FORMATS-1:0] fmt_outputs;

  // -----------
  // Input Side
  // -----------
  assign in_ready_o = in_valid_i & fmt_in_ready[dst_fmt_i]; // Ready is given by selected format

  // -------------------------
  // Generate Parallel Slices
  // -------------------------
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_parallel_slices
    // Some constants for this format
    localparam logic ANY_MERGED = fpnew_pkg::any_enabled_multi(FmtUnitTypes, FpFmtMask);
    localparam logic IS_FIRST_MERGED =
        fpnew_pkg::is_first_enabled_multi(fpnew_pkg::fp_format_e'(fmt), FmtUnitTypes, FpFmtMask);

    // Generate slice only if format enabled
    if (FpFmtMask[fmt] && (FmtUnitTypes[fmt] == fpnew_pkg::PARALLEL)) begin : active_format

      logic in_valid;

      assign in_valid = in_valid_i & (dst_fmt_i == fmt); // enable selected format

      // Forward masks related to the right SIMD lane
      localparam int unsigned INTERNAL_LANES = fpnew_pkg::num_lanes(Width, fpnew_pkg::fp_format_e'(fmt), EnableVectors);
      logic [INTERNAL_LANES-1:0] mask_slice;
      always_comb for (int b = 0; b < INTERNAL_LANES; b++) mask_slice[b] = simd_mask_i[(NUM_LANES/INTERNAL_LANES)*b];

      fpnew_opgroup_fmt_slice #(
        .OpGroup       ( OpGroup                      ),
        .FpFormat      ( fpnew_pkg::fp_format_e'(fmt) ),
        .Width         ( Width                        ),
        .EnableVectors ( EnableVectors                ),
        .NumPipeRegs   ( FmtPipeRegs[fmt]             ),
        .PipeConfig    ( PipeConfig                   ),
        .TagType       ( TagType                      ),
        .TrueSIMDClass ( TrueSIMDClass                )
      ) i_fmt_slice (
        .clk_i,
        .rst_ni,
        .operands_i     ( operands_i               ),
        .is_boxed_i     ( is_boxed_i[fmt]          ),
        .rnd_mode_i,
        .op_i,
        .op_mod_i,
        .vectorial_op_i,
        .tag_i,
        .simd_mask_i    ( mask_slice               ),
        .in_valid_i     ( in_valid                 ),
        .in_ready_o     ( fmt_in_ready[fmt]        ),
        .flush_i,
        .result_o       ( fmt_outputs[fmt].result  ),
        .status_o       ( fmt_outputs[fmt].status  ),
        .extension_bit_o( fmt_outputs[fmt].ext_bit ),
        .tag_o          ( fmt_outputs[fmt].tag     ),
        .out_valid_o    ( fmt_out_valid[fmt]       ),
        .out_ready_i    ( fmt_out_ready[fmt]       ),
        .busy_o         ( fmt_busy[fmt]            ),
        .reg_ena_i      ( '0                       )
      );
    // If the format wants to use merged ops, tie off the dangling ones not used here
    end else if (FpFmtMask[fmt] && ANY_MERGED && !IS_FIRST_MERGED) begin : merged_unused

      localparam FMT = fpnew_pkg::get_first_enabled_multi(FmtUnitTypes, FpFmtMask);
      // Ready is split up into formats
      assign fmt_in_ready[fmt]  = fmt_in_ready[int'(FMT)];

      assign fmt_out_valid[fmt] = 1'b0; // don't emit values
      assign fmt_busy[fmt]      = 1'b0; // never busy
      // Outputs are don't care
      assign fmt_outputs[fmt].result  = '{default: fpnew_pkg::DONT_CARE};
      assign fmt_outputs[fmt].status  = '{default: fpnew_pkg::DONT_CARE};
      assign fmt_outputs[fmt].ext_bit = fpnew_pkg::DONT_CARE;
      assign fmt_outputs[fmt].tag     = TagType'(fpnew_pkg::DONT_CARE);

    // Tie off disabled formats
    end else if (!FpFmtMask[fmt] || (FmtUnitTypes[fmt] == fpnew_pkg::DISABLED)) begin : disable_fmt
      assign fmt_in_ready[fmt]  = 1'b0; // don't accept operations
      assign fmt_out_valid[fmt] = 1'b0; // don't emit values
      assign fmt_busy[fmt]      = 1'b0; // never busy
      // Outputs are don't care
      assign fmt_outputs[fmt].result  = '{default: fpnew_pkg::DONT_CARE};
      assign fmt_outputs[fmt].status  = '{default: fpnew_pkg::DONT_CARE};
      assign fmt_outputs[fmt].ext_bit = fpnew_pkg::DONT_CARE;
      assign fmt_outputs[fmt].tag     = TagType'(fpnew_pkg::DONT_CARE);
    end
  end

  // ----------------------
  // Generate Merged Slice
  // ----------------------
  if (fpnew_pkg::any_enabled_multi(FmtUnitTypes, FpFmtMask)) begin : gen_merged_slice

    localparam FMT = fpnew_pkg::get_first_enabled_multi(FmtUnitTypes, FpFmtMask);
    localparam REG = fpnew_pkg::get_num_regs_multi(FmtPipeRegs, FmtUnitTypes, FpFmtMask);

    logic in_valid;

    assign in_valid = in_valid_i & (FmtUnitTypes[dst_fmt_i] == fpnew_pkg::MERGED);

    fpnew_opgroup_multifmt_slice #(
      .OpGroup       ( OpGroup          ),
      .Width         ( Width            ),
      .FpFmtConfig   ( FpFmtMask        ),
      .IntFmtConfig  ( IntFmtMask       ),
      .EnableVectors ( EnableVectors    ),
      .PulpDivsqrt   ( PulpDivsqrt      ),
      .NumPipeRegs   ( REG              ),
      .PipeConfig    ( PipeConfig       ),
      .TagType       ( TagType          )
    ) i_multifmt_slice (
      .clk_i,
      .rst_ni,
      .operands_i,
      .is_boxed_i,
      .rnd_mode_i,
      .op_i,
      .op_mod_i,
      .src_fmt_i,
      .dst_fmt_i,
      .int_fmt_i,
      .vectorial_op_i,
      .tag_i,
      .simd_mask_i     ( simd_mask_i              ),
      .in_valid_i      ( in_valid                 ),
      .in_ready_o      ( fmt_in_ready[FMT]        ),
      .flush_i,
      .result_o        ( fmt_outputs[FMT].result  ),
      .status_o        ( fmt_outputs[FMT].status  ),
      .extension_bit_o ( fmt_outputs[FMT].ext_bit ),
      .tag_o           ( fmt_outputs[FMT].tag     ),
      .out_valid_o     ( fmt_out_valid[FMT]       ),
      .out_ready_i     ( fmt_out_ready[FMT]       ),
      .busy_o          ( fmt_busy[FMT]            ),
      .reg_ena_i       ( '0                       )
    );

  end

  // ------------------
  // Arbitrate Outputs
  // ------------------
  output_t arbiter_output;

  // Round-Robin arbiter to decide which result to use
  rr_arb_tree #(
    .NumIn     ( NUM_FORMATS ),
    .DataType  ( output_t    ),
    .AxiVldRdy ( 1'b1        )
  ) i_arbiter (
    .clk_i,
    .rst_ni,
    .flush_i,
    .rr_i   ( '0             ),
    .req_i  ( fmt_out_valid  ),
    .gnt_o  ( fmt_out_ready  ),
    .data_i ( fmt_outputs    ),
    .gnt_i  ( out_ready_i    ),
    .req_o  ( out_valid_o    ),
    .data_o ( arbiter_output ),
    .idx_o  ( /* unused */   )
  );

  // Unpack output
  assign result_o        = arbiter_output.result;
  assign status_o        = arbiter_output.status;
  assign extension_bit_o = arbiter_output.ext_bit;
  assign tag_o           = arbiter_output.tag;

  assign busy_o = (| fmt_busy);

endmodule
// ----- 8< ----- FILE "./fpnew_opgroup_fmt_slice.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module fpnew_opgroup_fmt_slice #(
  parameter fpnew_pkg::opgroup_e     OpGroup       = fpnew_pkg::ADDMUL,
  parameter fpnew_pkg::fp_format_e   FpFormat      = fpnew_pkg::fp_format_e'(0),
  // FPU configuration
  parameter int unsigned             Width         = 32,
  parameter logic                    EnableVectors = 1'b1,
  parameter int unsigned             NumPipeRegs   = 0,
  parameter fpnew_pkg::pipe_config_t PipeConfig    = fpnew_pkg::BEFORE,
  parameter logic                    ExtRegEna     = 1'b0,
  parameter type                     TagType       = logic,
  parameter int unsigned             TrueSIMDClass = 0,
  // Do not change
  localparam int unsigned NUM_OPERANDS = fpnew_pkg::num_operands(OpGroup),
  localparam int unsigned NUM_LANES    = fpnew_pkg::num_lanes(Width, FpFormat, EnableVectors),
  localparam type         MaskType     = logic [NUM_LANES-1:0],
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input logic                               clk_i,
  input logic                               rst_ni,
  // Input signals
  input logic [NUM_OPERANDS-1:0][Width-1:0] operands_i,
  input logic [NUM_OPERANDS-1:0]            is_boxed_i,
  input fpnew_pkg::roundmode_e              rnd_mode_i,
  input fpnew_pkg::operation_e              op_i,
  input logic                               op_mod_i,
  input logic                               vectorial_op_i,
  input TagType                             tag_i,
  input MaskType                            simd_mask_i,
  // Input Handshake
  input  logic                              in_valid_i,
  output logic                              in_ready_o,
  input  logic                              flush_i,
  // Output signals
  output logic [Width-1:0]                  result_o,
  output fpnew_pkg::status_t                status_o,
  output logic                              extension_bit_o,
  output TagType                            tag_o,
  // Output handshake
  output logic                              out_valid_o,
  input  logic                              out_ready_i,
  // Indication of valid data in flight
  output logic                              busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0]         reg_ena_i
);

  localparam int unsigned FP_WIDTH  = fpnew_pkg::fp_width(FpFormat);
  localparam int unsigned SIMD_WIDTH = unsigned'(Width/NUM_LANES);


  logic [NUM_LANES-1:0] lane_in_ready, lane_out_valid; // Handshake signals for the lanes
  logic                 vectorial_op;

  logic [NUM_LANES*FP_WIDTH-1:0] slice_result;
  logic [Width-1:0]              slice_regular_result, slice_class_result, slice_vec_class_result;

  fpnew_pkg::status_t    [NUM_LANES-1:0] lane_status;
  logic                  [NUM_LANES-1:0] lane_ext_bit; // only the first one is actually used
  fpnew_pkg::classmask_e [NUM_LANES-1:0] lane_class_mask;
  TagType                [NUM_LANES-1:0] lane_tags; // only the first one is actually used
  logic                  [NUM_LANES-1:0] lane_masks;
  logic                  [NUM_LANES-1:0] lane_vectorial, lane_busy, lane_is_class; // dito

  logic result_is_vector, result_is_class;

  // -----------
  // Input Side
  // -----------
  assign in_ready_o   = lane_in_ready[0]; // Upstream ready is given by first lane
  assign vectorial_op = vectorial_op_i & EnableVectors; // only do vectorial stuff if enabled

  // ---------------
  // Generate Lanes
  // ---------------
  for (genvar lane = 0; lane < int'(NUM_LANES); lane++) begin : gen_num_lanes
    logic [FP_WIDTH-1:0] local_result; // lane-local results
    logic                local_sign;

    // Generate instances only if needed, lane 0 always generated
    if ((lane == 0) || EnableVectors) begin : active_lane
      logic in_valid, out_valid, out_ready; // lane-local handshake

      logic [NUM_OPERANDS-1:0][FP_WIDTH-1:0] local_operands; // lane-local operands
      logic [FP_WIDTH-1:0]                   op_result;      // lane-local results
      fpnew_pkg::status_t                    op_status;

      assign in_valid = in_valid_i & ((lane == 0) | vectorial_op); // upper lanes only for vectors
      // Slice out the operands for this lane
      always_comb begin : prepare_input
        for (int i = 0; i < int'(NUM_OPERANDS); i++) begin
          local_operands[i] = operands_i[i][(unsigned'(lane)+1)*FP_WIDTH-1:unsigned'(lane)*FP_WIDTH];
        end
      end

      // Instantiate the operation from the selected opgroup
      if (OpGroup == fpnew_pkg::ADDMUL) begin : lane_instance
        fpnew_fma #(
          .FpFormat    ( FpFormat    ),
          .NumPipeRegs ( NumPipeRegs ),
          .PipeConfig  ( PipeConfig  ),
          .TagType     ( TagType     ),
          .AuxType     ( logic       )
        ) i_fma (
          .clk_i,
          .rst_ni,
          .operands_i      ( local_operands               ),
          .is_boxed_i      ( is_boxed_i[NUM_OPERANDS-1:0] ),
          .rnd_mode_i,
          .op_i,
          .op_mod_i,
          .tag_i,
          .mask_i          ( simd_mask_i[lane]    ),
          .aux_i           ( vectorial_op         ), // Remember whether operation was vectorial
          .in_valid_i      ( in_valid             ),
          .in_ready_o      ( lane_in_ready[lane]  ),
          .flush_i,
          .result_o        ( op_result            ),
          .status_o        ( op_status            ),
          .extension_bit_o ( lane_ext_bit[lane]   ),
          .tag_o           ( lane_tags[lane]      ),
          .mask_o          ( lane_masks[lane]     ),
          .aux_o           ( lane_vectorial[lane] ),
          .out_valid_o     ( out_valid            ),
          .out_ready_i     ( out_ready            ),
          .busy_o          ( lane_busy[lane]      ),
          .reg_ena_i
        );
        assign lane_is_class[lane]   = 1'b0;
        assign lane_class_mask[lane] = fpnew_pkg::NEGINF;
      end else if (OpGroup == fpnew_pkg::DIVSQRT) begin : lane_instance
        // fpnew_divsqrt #(
        //   .FpFormat   (FpFormat),
        //   .NumPipeRegs(NumPipeRegs),
        //   .PipeConfig (PipeConfig),
        //   .TagType    (TagType),
        //   .AuxType    (logic)
        // ) i_divsqrt (
        //   .clk_i,
        //   .rst_ni,
        //   .operands_i      ( local_operands               ),
        //   .is_boxed_i      ( is_boxed_i[NUM_OPERANDS-1:0] ),
        //   .rnd_mode_i,
        //   .op_i,
        //   .op_mod_i,
        //   .tag_i,
        //   .aux_i           ( vectorial_op         ), // Remember whether operation was vectorial
        //   .in_valid_i      ( in_valid             ),
        //   .in_ready_o      ( lane_in_ready[lane]  ),
        //   .flush_i,
        //   .result_o        ( op_result            ),
        //   .status_o        ( op_status            ),
        //   .extension_bit_o ( lane_ext_bit[lane]   ),
        //   .tag_o           ( lane_tags[lane]      ),
        //   .aux_o           ( lane_vectorial[lane] ),
        //   .out_valid_o     ( out_valid            ),
        //   .out_ready_i     ( out_ready            ),
        //   .busy_o          ( lane_busy[lane]      ),
        //   .reg_ena_i
        // );
        // assign lane_is_class[lane] = 1'b0;
      end else if (OpGroup == fpnew_pkg::NONCOMP) begin : lane_instance
        fpnew_noncomp #(
          .FpFormat   (FpFormat),
          .NumPipeRegs(NumPipeRegs),
          .PipeConfig (PipeConfig),
          .TagType    (TagType),
          .AuxType    (logic)
        ) i_noncomp (
          .clk_i,
          .rst_ni,
          .operands_i      ( local_operands               ),
          .is_boxed_i      ( is_boxed_i[NUM_OPERANDS-1:0] ),
          .rnd_mode_i,
          .op_i,
          .op_mod_i,
          .tag_i,
          .mask_i          ( simd_mask_i[lane]     ),
          .aux_i           ( vectorial_op          ), // Remember whether operation was vectorial
          .in_valid_i      ( in_valid              ),
          .in_ready_o      ( lane_in_ready[lane]   ),
          .flush_i,
          .result_o        ( op_result             ),
          .status_o        ( op_status             ),
          .extension_bit_o ( lane_ext_bit[lane]    ),
          .class_mask_o    ( lane_class_mask[lane] ),
          .is_class_o      ( lane_is_class[lane]   ),
          .tag_o           ( lane_tags[lane]       ),
          .mask_o          ( lane_masks[lane]      ),
          .aux_o           ( lane_vectorial[lane]  ),
          .out_valid_o     ( out_valid             ),
          .out_ready_i     ( out_ready             ),
          .busy_o          ( lane_busy[lane]       ),
          .reg_ena_i
        );
      end // ADD OTHER OPTIONS HERE

      // Handshakes are only done if the lane is actually used
      assign out_ready            = out_ready_i & ((lane == 0) | result_is_vector);
      assign lane_out_valid[lane] = out_valid   & ((lane == 0) | result_is_vector);

      // Properly NaN-box or sign-extend the slice result if not in use
      assign local_result      = (lane_out_valid[lane] | ExtRegEna) ? op_result : '{default: lane_ext_bit[0]};
      assign lane_status[lane] = (lane_out_valid[lane] | ExtRegEna) ? op_status : '0;

    // Otherwise generate constant sign-extension
    end else begin
      assign lane_out_valid[lane] = 1'b0; // unused lane
      assign lane_in_ready[lane]  = 1'b0; // unused lane
      assign local_result         = '{default: lane_ext_bit[0]}; // sign-extend/nan box
      assign lane_status[lane]    = '0;
      assign lane_busy[lane]      = 1'b0;
      assign lane_is_class[lane]  = 1'b0;
    end

    // Insert lane result into slice result
    assign slice_result[(unsigned'(lane)+1)*FP_WIDTH-1:unsigned'(lane)*FP_WIDTH] = local_result;

    // Create Classification results
    if (TrueSIMDClass && SIMD_WIDTH >= 10) begin : vectorial_true_class // true vectorial class blocks are 10bits in size
      assign slice_vec_class_result[lane*SIMD_WIDTH +: 10] = lane_class_mask[lane];
      assign slice_vec_class_result[(lane+1)*SIMD_WIDTH-1 -: SIMD_WIDTH-10] = '0;
    end else if ((lane+1)*8 <= Width) begin : vectorial_class // vectorial class blocks are 8bits in size
      assign local_sign = (lane_class_mask[lane] == fpnew_pkg::NEGINF ||
                           lane_class_mask[lane] == fpnew_pkg::NEGNORM ||
                           lane_class_mask[lane] == fpnew_pkg::NEGSUBNORM ||
                           lane_class_mask[lane] == fpnew_pkg::NEGZERO);
      // Write the current block segment
      assign slice_vec_class_result[(lane+1)*8-1:lane*8] = {
        local_sign,  // BIT 7
        ~local_sign, // BIT 6
        lane_class_mask[lane] == fpnew_pkg::QNAN, // BIT 5
        lane_class_mask[lane] == fpnew_pkg::SNAN, // BIT 4
        lane_class_mask[lane] == fpnew_pkg::POSZERO
            || lane_class_mask[lane] == fpnew_pkg::NEGZERO, // BIT 3
        lane_class_mask[lane] == fpnew_pkg::POSSUBNORM
            || lane_class_mask[lane] == fpnew_pkg::NEGSUBNORM, // BIT 2
        lane_class_mask[lane] == fpnew_pkg::POSNORM
            || lane_class_mask[lane] == fpnew_pkg::NEGNORM, // BIT 1
        lane_class_mask[lane] == fpnew_pkg::POSINF
            || lane_class_mask[lane] == fpnew_pkg::NEGINF // BIT 0
      };
    end
  end

  // ------------
  // Output Side
  // ------------
  assign result_is_vector = lane_vectorial[0];
  assign result_is_class  = lane_is_class[0];

  assign slice_regular_result = $signed({extension_bit_o, slice_result});

  localparam int unsigned CLASS_VEC_BITS = (NUM_LANES*8 > Width) ? 8 * (Width / 8) : NUM_LANES*8;

  // Pad out unused vec_class bits if each classify result is on 8 bits
  if (!(TrueSIMDClass && SIMD_WIDTH >= 10)) begin
    if (CLASS_VEC_BITS < Width) begin : pad_vectorial_class
      assign slice_vec_class_result[Width-1:CLASS_VEC_BITS] = '0;
    end
  end

  // localparam logic [Width-1:0] CLASS_VEC_MASK = 2**CLASS_VEC_BITS - 1;

  assign slice_class_result = result_is_vector ? slice_vec_class_result : lane_class_mask[0];

  // Select the proper result
  assign result_o = result_is_class ? slice_class_result : slice_regular_result;

  assign extension_bit_o                              = lane_ext_bit[0]; // upper lanes unused
  assign tag_o                                        = lane_tags[0];    // upper lanes unused
  assign busy_o                                       = (| lane_busy);
  assign out_valid_o                                  = lane_out_valid[0]; // upper lanes unused


  // Collapse the lane status
  always_comb begin : output_processing
    // Collapse the status
    automatic fpnew_pkg::status_t temp_status;
    temp_status = '0;
    for (int i = 0; i < int'(NUM_LANES); i++)
      temp_status |= lane_status[i] & {5{lane_masks[i]}};
    status_o = temp_status;
  end
endmodule
// ----- 8< ----- FILE "./fpnew_opgroup_multifmt_slice.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>



module fpnew_opgroup_multifmt_slice #(
  parameter fpnew_pkg::opgroup_e     OpGroup       = fpnew_pkg::CONV,
  parameter int unsigned             Width         = 64,
  // FPU configuration
  parameter fpnew_pkg::fmt_logic_t   FpFmtConfig   = '1,
  parameter fpnew_pkg::ifmt_logic_t  IntFmtConfig  = '1,
  parameter logic                    EnableVectors = 1'b1,
  parameter logic                    PulpDivsqrt   = 1'b1,
  parameter int unsigned             NumPipeRegs   = 0,
  parameter fpnew_pkg::pipe_config_t PipeConfig    = fpnew_pkg::BEFORE,
  parameter logic                    ExtRegEna     = 1'b0,
  parameter type                     TagType       = logic,
  // Do not change
  localparam int unsigned NUM_OPERANDS = fpnew_pkg::num_operands(OpGroup),
  localparam int unsigned NUM_FORMATS  = fpnew_pkg::NUM_FP_FORMATS,
  localparam int unsigned NUM_SIMD_LANES = fpnew_pkg::max_num_lanes(Width, FpFmtConfig, EnableVectors),
  localparam type         MaskType     = logic [NUM_SIMD_LANES-1:0],
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input logic                                     clk_i,
  input logic                                     rst_ni,
  // Input signals
  input logic [NUM_OPERANDS-1:0][Width-1:0]       operands_i,
  input logic [NUM_FORMATS-1:0][NUM_OPERANDS-1:0] is_boxed_i,
  input fpnew_pkg::roundmode_e                    rnd_mode_i,
  input fpnew_pkg::operation_e                    op_i,
  input logic                                     op_mod_i,
  input fpnew_pkg::fp_format_e                    src_fmt_i,
  input fpnew_pkg::fp_format_e                    dst_fmt_i,
  input fpnew_pkg::int_format_e                   int_fmt_i,
  input logic                                     vectorial_op_i,
  input TagType                                   tag_i,
  input MaskType                                  simd_mask_i,
  // Input Handshake
  input  logic                                    in_valid_i,
  output logic                                    in_ready_o,
  input  logic                                    flush_i,
  // Output signals
  output logic [Width-1:0]                        result_o,
  output fpnew_pkg::status_t                      status_o,
  output logic                                    extension_bit_o,
  output TagType                                  tag_o,
  // Output handshake
  output logic                                    out_valid_o,
  input  logic                                    out_ready_i,
  // Indication of valid data in flight
  output logic                                    busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0]               reg_ena_i
);

  if ((OpGroup == fpnew_pkg::DIVSQRT) && !PulpDivsqrt &&
      !((FpFmtConfig[0] == 1) && (FpFmtConfig[1:NUM_FORMATS-1] == '0))) begin
    $fatal(1, "T-Head-based DivSqrt unit supported only in FP32-only configurations. \
Set PulpDivsqrt to 1 not to use the PULP DivSqrt unit \
or set Features.FpFmtMask to support only FP32");
  end

  localparam int unsigned MAX_FP_WIDTH   = fpnew_pkg::max_fp_width(FpFmtConfig);
  localparam int unsigned MAX_INT_WIDTH  = fpnew_pkg::max_int_width(IntFmtConfig);
  localparam int unsigned NUM_LANES = fpnew_pkg::max_num_lanes(Width, FpFmtConfig, 1'b1);
  localparam int unsigned NUM_INT_FORMATS = fpnew_pkg::NUM_INT_FORMATS;
  // We will send the format information along with the data
  localparam int unsigned FMT_BITS =
      fpnew_pkg::maximum($clog2(NUM_FORMATS), $clog2(NUM_INT_FORMATS));
  localparam int unsigned AUX_BITS = FMT_BITS + 2; // also add vectorial and integer flags

  logic [NUM_LANES-1:0] lane_in_ready, lane_out_valid, divsqrt_done, divsqrt_ready; // Handshake signals for the lanes
  logic                 vectorial_op;
  logic [FMT_BITS-1:0]  dst_fmt; // destination format to pass along with operation
  logic [AUX_BITS-1:0]  aux_data;

  // additional flags for CONV
  logic       dst_fmt_is_int, dst_is_cpk;
  logic [1:0] dst_vec_op; // info for vectorial results (for packing)
  logic [2:0] target_aux_d;
  logic       is_up_cast, is_down_cast;

  logic [NUM_FORMATS-1:0][Width-1:0]     fmt_slice_result;
  logic [NUM_INT_FORMATS-1:0][Width-1:0] ifmt_slice_result;

  logic [Width-1:0] conv_target_d, conv_target_q; // vectorial conversions update a register

  fpnew_pkg::status_t [NUM_LANES-1:0]   lane_status;
  logic   [NUM_LANES-1:0]               lane_ext_bit; // only the first one is actually used
  TagType [NUM_LANES-1:0]               lane_tags; // only the first one is actually used
  logic   [NUM_LANES-1:0]               lane_masks;
  logic   [NUM_LANES-1:0][AUX_BITS-1:0] lane_aux; // only the first one is actually used
  logic   [NUM_LANES-1:0]               lane_busy; // dito

  logic                result_is_vector;
  logic [FMT_BITS-1:0] result_fmt;
  logic                result_fmt_is_int, result_is_cpk;
  logic [1:0]          result_vec_op; // info for vectorial results (for packing)

  logic simd_synch_rdy, simd_synch_done;

  // -----------
  // Input Side
  // -----------
  assign in_ready_o   = lane_in_ready[0]; // Upstream ready is given by first lane
  assign vectorial_op = vectorial_op_i & EnableVectors; // only do vectorial stuff if enabled

  // Cast-and-Pack ops are encoded in operation and modifier
  assign dst_fmt_is_int = (OpGroup == fpnew_pkg::CONV) & (op_i == fpnew_pkg::F2I);
  assign dst_is_cpk     = (OpGroup == fpnew_pkg::CONV) & (op_i == fpnew_pkg::CPKAB ||
                                                          op_i == fpnew_pkg::CPKCD);
  assign dst_vec_op     = (OpGroup == fpnew_pkg::CONV) & {(op_i == fpnew_pkg::CPKCD), op_mod_i};

  assign is_up_cast   = (fpnew_pkg::fp_width(dst_fmt_i) > fpnew_pkg::fp_width(src_fmt_i));
  assign is_down_cast = (fpnew_pkg::fp_width(dst_fmt_i) < fpnew_pkg::fp_width(src_fmt_i));

  // The destination format is the int format for F2I casts
  assign dst_fmt    = dst_fmt_is_int ? int_fmt_i : dst_fmt_i;

  // The data sent along consists of the vectorial flag and format bits
  assign aux_data      = {dst_fmt_is_int, vectorial_op, dst_fmt};
  assign target_aux_d  = {dst_vec_op, dst_is_cpk};

  // CONV passes one operand for assembly after the unit: opC for cpk, opB for others
  if (OpGroup == fpnew_pkg::CONV) begin : conv_target
    assign conv_target_d = dst_is_cpk ? operands_i[2] : operands_i[1];
  end else begin : not_conv_target
    assign conv_target_d = '0;
  end

  // For 2-operand units, prepare boxing info
  logic [NUM_FORMATS-1:0]      is_boxed_1op;
  logic [NUM_FORMATS-1:0][1:0] is_boxed_2op;

  always_comb begin : boxed_2op
    for (int fmt = 0; fmt < NUM_FORMATS; fmt++) begin
      is_boxed_1op[fmt] = is_boxed_i[fmt][0];
      is_boxed_2op[fmt] = is_boxed_i[fmt][1:0];
    end
  end

  // ---------------
  // Generate Lanes
  // ---------------
  for (genvar lane = 0; lane < int'(NUM_LANES); lane++) begin : gen_num_lanes
    localparam int unsigned LANE = unsigned'(lane); // unsigned to please the linter
    // Get a mask of active formats for this lane
    localparam fpnew_pkg::fmt_logic_t ACTIVE_FORMATS =
        fpnew_pkg::get_lane_formats(Width, FpFmtConfig, LANE);
    localparam fpnew_pkg::ifmt_logic_t ACTIVE_INT_FORMATS =
        fpnew_pkg::get_lane_int_formats(Width, FpFmtConfig, IntFmtConfig, LANE);
    localparam int unsigned MAX_WIDTH = fpnew_pkg::max_fp_width(ACTIVE_FORMATS);

    // Cast-specific parameters
    localparam fpnew_pkg::fmt_logic_t CONV_FORMATS =
        fpnew_pkg::get_conv_lane_formats(Width, FpFmtConfig, LANE);
    localparam fpnew_pkg::ifmt_logic_t CONV_INT_FORMATS =
        fpnew_pkg::get_conv_lane_int_formats(Width, FpFmtConfig, IntFmtConfig, LANE);
    localparam int unsigned CONV_WIDTH = fpnew_pkg::max_fp_width(CONV_FORMATS);

    // Lane parameters from Opgroup
    localparam fpnew_pkg::fmt_logic_t LANE_FORMATS = (OpGroup == fpnew_pkg::CONV)
                                                     ? CONV_FORMATS : ACTIVE_FORMATS;
    localparam int unsigned LANE_WIDTH = (OpGroup == fpnew_pkg::CONV) ? CONV_WIDTH : MAX_WIDTH;

    logic [LANE_WIDTH-1:0] local_result; // lane-local results

    // Generate instances only if needed, lane 0 always generated
    if ((lane == 0) || EnableVectors) begin : active_lane
      logic in_valid, out_valid, out_ready; // lane-local handshake

      logic [NUM_OPERANDS-1:0][LANE_WIDTH-1:0] local_operands;  // lane-local oprands
      logic [LANE_WIDTH-1:0]                   op_result;       // lane-local results
      fpnew_pkg::status_t                      op_status;

      assign in_valid = in_valid_i & ((lane == 0) | vectorial_op); // upper lanes only for vectors

      // Slice out the operands for this lane, upper bits are ignored in the unit
      always_comb begin : prepare_input
        for (int unsigned i = 0; i < NUM_OPERANDS; i++) begin
          if (i == 2) begin
            local_operands[i] = operands_i[i] >> LANE*fpnew_pkg::fp_width(dst_fmt_i);
          end else begin
            local_operands[i] = operands_i[i] >> LANE*fpnew_pkg::fp_width(src_fmt_i);
          end
        end

        // override operand 0 for some conversions
        if (OpGroup == fpnew_pkg::CONV) begin
          // Source is an integer
          if (op_i == fpnew_pkg::I2F) begin
            local_operands[0] = operands_i[0] >> LANE*fpnew_pkg::int_width(int_fmt_i);
          // vectorial F2F up casts
          end else if (op_i == fpnew_pkg::F2F) begin
            if (vectorial_op && op_mod_i && is_up_cast) begin // up cast with upper half
              local_operands[0] = operands_i[0] >> LANE*fpnew_pkg::fp_width(src_fmt_i) +
                                                   MAX_FP_WIDTH/2;
            end
          // CPK
          end else if (dst_is_cpk) begin
            if (lane == 1) begin
              local_operands[0] = operands_i[1][LANE_WIDTH-1:0]; // using opB as second argument
            end
          end
        end
      end

      // Instantiate the operation from the selected opgroup
      if (OpGroup == fpnew_pkg::ADDMUL) begin : lane_instance
        fpnew_fma_multi #(
          .FpFmtConfig ( LANE_FORMATS         ),
          .NumPipeRegs ( NumPipeRegs          ),
          .PipeConfig  ( PipeConfig           ),
          .TagType     ( TagType              ),
          .AuxType     ( logic [AUX_BITS-1:0] )
        ) i_fpnew_fma_multi (
          .clk_i,
          .rst_ni,
          .operands_i      ( local_operands  ),
          .is_boxed_i,
          .rnd_mode_i,
          .op_i,
          .op_mod_i,
          .src_fmt_i,
          .dst_fmt_i,
          .tag_i,
          .mask_i          ( simd_mask_i[lane]   ),
          .aux_i           ( aux_data            ),
          .in_valid_i      ( in_valid            ),
          .in_ready_o      ( lane_in_ready[lane] ),
          .flush_i,
          .result_o        ( op_result           ),
          .status_o        ( op_status           ),
          .extension_bit_o ( lane_ext_bit[lane]  ),
          .tag_o           ( lane_tags[lane]     ),
          .mask_o          ( lane_masks[lane]    ),
          .aux_o           ( lane_aux[lane]      ),
          .out_valid_o     ( out_valid           ),
          .out_ready_i     ( out_ready           ),
          .busy_o          ( lane_busy[lane]     ),
          .reg_ena_i
        );

      end else if (OpGroup == fpnew_pkg::DIVSQRT) begin : lane_instance
        if (!PulpDivsqrt && LANE_FORMATS[0] && (LANE_FORMATS[1:fpnew_pkg::NUM_FP_FORMATS-1] == '0)) begin
          // The T-head-based DivSqrt unit is supported only in FP32-only configurations
          fpnew_divsqrt_th_32 #(
            .NumPipeRegs ( NumPipeRegs          ),
            .PipeConfig  ( PipeConfig           ),
            .TagType     ( TagType              ),
            .AuxType     ( logic [AUX_BITS-1:0] )
          ) i_fpnew_divsqrt_multi_th (
            .clk_i,
            .rst_ni,
            .operands_i      ( local_operands[1:0] ), // 2 operands
            .is_boxed_i      ( is_boxed_2op        ), // 2 operands
            .rnd_mode_i,
            .op_i,
            .tag_i,
            .mask_i          ( simd_mask_i[lane]   ),
            .aux_i           ( aux_data            ),
            .in_valid_i      ( in_valid            ),
            .in_ready_o      ( lane_in_ready[lane] ),
            .flush_i,
            .result_o        ( op_result           ),
            .status_o        ( op_status           ),
            .extension_bit_o ( lane_ext_bit[lane]  ),
            .tag_o           ( lane_tags[lane]     ),
            .mask_o          ( lane_masks[lane]    ),
            .aux_o           ( lane_aux[lane]      ),
            .out_valid_o     ( out_valid           ),
            .out_ready_i     ( out_ready           ),
            .busy_o          ( lane_busy[lane]     ),
            .reg_ena_i
          );
        end else begin
          fpnew_divsqrt_multi #(
            .FpFmtConfig ( LANE_FORMATS         ),
            .NumPipeRegs ( NumPipeRegs          ),
            .PipeConfig  ( PipeConfig           ),
            .TagType     ( TagType              ),
            .AuxType     ( logic [AUX_BITS-1:0] )
          ) i_fpnew_divsqrt_multi (
            .clk_i,
            .rst_ni,
            .operands_i       ( local_operands[1:0] ), // 2 operands
            .is_boxed_i       ( is_boxed_2op        ), // 2 operands
            .rnd_mode_i,
            .op_i,
            .dst_fmt_i,
            .tag_i,
            .mask_i           ( simd_mask_i[lane]   ),
            .aux_i            ( aux_data            ),
            .vectorial_op_i   ( vectorial_op        ),
            .in_valid_i       ( in_valid            ),
            .in_ready_o       ( lane_in_ready[lane] ),
            .divsqrt_done_o   ( divsqrt_done[lane]  ),
            .simd_synch_done_i( simd_synch_done     ),
            .divsqrt_ready_o  ( divsqrt_ready[lane] ),
            .simd_synch_rdy_i ( simd_synch_rdy      ),
            .flush_i,
            .result_o         ( op_result           ),
            .status_o         ( op_status           ),
            .extension_bit_o  ( lane_ext_bit[lane]  ),
            .tag_o            ( lane_tags[lane]     ),
            .mask_o           ( lane_masks[lane]    ),
            .aux_o            ( lane_aux[lane]      ),
            .out_valid_o      ( out_valid           ),
            .out_ready_i      ( out_ready           ),
            .busy_o           ( lane_busy[lane]     ),
            .reg_ena_i
          );
        end
      end else if (OpGroup == fpnew_pkg::NONCOMP) begin : lane_instance

      end else if (OpGroup == fpnew_pkg::CONV) begin : lane_instance
        fpnew_cast_multi #(
          .FpFmtConfig  ( LANE_FORMATS         ),
          .IntFmtConfig ( CONV_INT_FORMATS     ),
          .NumPipeRegs  ( NumPipeRegs          ),
          .PipeConfig   ( PipeConfig           ),
          .TagType      ( TagType              ),
          .AuxType      ( logic [AUX_BITS-1:0] )
        ) i_fpnew_cast_multi (
          .clk_i,
          .rst_ni,
          .operands_i      ( local_operands[0]   ),
          .is_boxed_i      ( is_boxed_1op        ),
          .rnd_mode_i,
          .op_i,
          .op_mod_i,
          .src_fmt_i,
          .dst_fmt_i,
          .int_fmt_i,
          .tag_i,
          .mask_i          ( simd_mask_i[lane]   ),
          .aux_i           ( aux_data            ),
          .in_valid_i      ( in_valid            ),
          .in_ready_o      ( lane_in_ready[lane] ),
          .flush_i,
          .result_o        ( op_result           ),
          .status_o        ( op_status           ),
          .extension_bit_o ( lane_ext_bit[lane]  ),
          .tag_o           ( lane_tags[lane]     ),
          .mask_o          ( lane_masks[lane]    ),
          .aux_o           ( lane_aux[lane]      ),
          .out_valid_o     ( out_valid           ),
          .out_ready_i     ( out_ready           ),
          .busy_o          ( lane_busy[lane]     ),
          .reg_ena_i
        );
      end // ADD OTHER OPTIONS HERE

      // Handshakes are only done if the lane is actually used
      assign out_ready            = out_ready_i & ((lane == 0) | result_is_vector);
      assign lane_out_valid[lane] = out_valid & ((lane == 0) | result_is_vector);

      // Properly NaN-box or sign-extend the slice result if not in use
      assign local_result      = (lane_out_valid[lane] | ExtRegEna) ? op_result : '{default: lane_ext_bit[0]};
      assign lane_status[lane] = (lane_out_valid[lane] | ExtRegEna) ? op_status : '0;

    // Otherwise generate constant sign-extension
    end else begin : inactive_lane
      assign lane_out_valid[lane] = 1'b0; // unused lane
      assign lane_in_ready[lane]  = 1'b0; // unused lane
      assign lane_aux[lane]       = 1'b0; // unused lane
      assign lane_masks[lane]     = 1'b1; // unused lane
      assign lane_tags[lane]      = 1'b0; // unused lane
      assign divsqrt_done[lane]   = 1'b0; // unused lane
      assign divsqrt_ready[lane]  = 1'b0; // unused lane
      assign lane_ext_bit[lane]   = 1'b1; // NaN-box unused lane
      assign local_result         = {(LANE_WIDTH){lane_ext_bit[0]}}; // sign-extend/nan box
      assign lane_status[lane]    = '0;
      assign lane_busy[lane]      = 1'b0;
    end

    // Generate result packing depending on float format
    for (genvar fmt = 0; fmt < NUM_FORMATS; fmt++) begin : pack_fp_result
      // Set up some constants
      localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
      // only for active formats within the lane
      if (ACTIVE_FORMATS[fmt]) begin
        assign fmt_slice_result[fmt][(LANE+1)*FP_WIDTH-1:LANE*FP_WIDTH] =
            local_result[FP_WIDTH-1:0];
      end else if ((LANE+1)*FP_WIDTH <= Width) begin
        assign fmt_slice_result[fmt][(LANE+1)*FP_WIDTH-1:LANE*FP_WIDTH] =
            '{default: lane_ext_bit[LANE]};
      end else if (LANE*FP_WIDTH < Width) begin
        assign fmt_slice_result[fmt][Width-1:LANE*FP_WIDTH] =
            '{default: lane_ext_bit[LANE]};
      end
    end

    // Generate result packing depending on integer format
    if (OpGroup == fpnew_pkg::CONV) begin : int_results_enabled
      for (genvar ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++) begin : pack_int_result
        // Set up some constants
        localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));
        if (ACTIVE_INT_FORMATS[ifmt]) begin
          assign ifmt_slice_result[ifmt][(LANE+1)*INT_WIDTH-1:LANE*INT_WIDTH] =
            local_result[INT_WIDTH-1:0];
        end else if ((LANE+1)*INT_WIDTH <= Width) begin
          assign ifmt_slice_result[ifmt][(LANE+1)*INT_WIDTH-1:LANE*INT_WIDTH] = '0;
        end else if (LANE*INT_WIDTH < Width) begin
          assign ifmt_slice_result[ifmt][Width-1:LANE*INT_WIDTH] = '0;
        end
      end
    end
  end

  // Extend slice result if needed
  for (genvar fmt = 0; fmt < NUM_FORMATS; fmt++) begin : extend_fp_result
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    if (NUM_LANES*FP_WIDTH < Width)
      assign fmt_slice_result[fmt][Width-1:NUM_LANES*FP_WIDTH] = '{default: lane_ext_bit[0]};
  end

  for (genvar ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++) begin : extend_or_mute_int_result
    // Mute int results if unused
    if (OpGroup != fpnew_pkg::CONV) begin : mute_int_result
      assign ifmt_slice_result[ifmt] = '0;

    // Extend slice result if needed
    end else begin : extend_int_result
      // Set up some constants
      localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));
      if (NUM_LANES*INT_WIDTH < Width)
        assign ifmt_slice_result[ifmt][Width-1:NUM_LANES*INT_WIDTH] = '0;
    end
  end

  // Bypass lanes with target operand for vectorial casts
  if (OpGroup == fpnew_pkg::CONV) begin : target_regs
    // Bypass pipeline signals, index i holds signal after i register stages
    logic [0:NumPipeRegs][Width-1:0] byp_pipe_target_q;
    logic [0:NumPipeRegs][2:0]       byp_pipe_aux_q;
    logic [0:NumPipeRegs]            byp_pipe_valid_q;
    // Ready signal is combinatorial for all stages
    logic [0:NumPipeRegs] byp_pipe_ready;

    // Input stage: First element of pipeline is taken from inputs
    assign byp_pipe_target_q[0]  = conv_target_d;
    assign byp_pipe_aux_q[0]     = target_aux_d;
    assign byp_pipe_valid_q[0]   = in_valid_i & vectorial_op;
    // Generate the register stages
    for (genvar i = 0; i < NumPipeRegs; i++) begin : gen_bypass_pipeline
      // Internal register enable for this stage
      logic reg_ena;
      // Determine the ready signal of the current stage - advance the pipeline:
      // 1. if the next stage is ready for our data
      // 2. if the next stage only holds a bubble (not valid) -> we can pop it
      assign byp_pipe_ready[i] = byp_pipe_ready[i+1] | ~byp_pipe_valid_q[i+1];
      // Valid: enabled by ready signal, synchronous clear with the flush signal
      `FFLARNC(byp_pipe_valid_q[i+1], byp_pipe_valid_q[i], byp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
      // Enable register if pipleine ready and a valid data item is present
      assign reg_ena = (byp_pipe_ready[i] & byp_pipe_valid_q[i]) | reg_ena_i[i];
      // Generate the pipeline registers within the stages, use enable-registers
      `FFL(byp_pipe_target_q[i+1],  byp_pipe_target_q[i],  reg_ena, '0)
      `FFL(byp_pipe_aux_q[i+1],     byp_pipe_aux_q[i],     reg_ena, '0)
    end
    // Output stage: Ready travels backwards from output side, driven by downstream circuitry
    assign byp_pipe_ready[NumPipeRegs] = out_ready_i & result_is_vector;
    // Output stage: assign module outputs
    assign conv_target_q = byp_pipe_target_q[NumPipeRegs];

    // decode the aux data
    assign {result_vec_op, result_is_cpk} = byp_pipe_aux_q[NumPipeRegs];
  end else begin : no_conv
    assign {result_vec_op, result_is_cpk} = '0;
    assign conv_target_q = '0;
  end

  if (PulpDivsqrt) begin
    // Synch lanes if there is more than one
    assign simd_synch_rdy  = EnableVectors ? &divsqrt_ready : divsqrt_ready[0];
    assign simd_synch_done = EnableVectors ? &divsqrt_done  : divsqrt_done[0];
  end else begin
    // Unused (alternative divider only supported for scalar FP32 divsqrt)
    assign simd_synch_rdy  = '0;
    assign simd_synch_done = '0;
  end

  // ------------
  // Output Side
  // ------------
  assign {result_fmt_is_int, result_is_vector, result_fmt} = lane_aux[0];

  assign result_o = result_fmt_is_int
                    ? ifmt_slice_result[result_fmt]
                    : fmt_slice_result[result_fmt];

  assign extension_bit_o = lane_ext_bit[0]; // don't care about upper ones
  assign tag_o           = lane_tags[0];    // don't care about upper ones
  assign busy_o          = (| lane_busy);

  assign out_valid_o     = lane_out_valid[0]; // don't care about upper ones

  // Collapse the status
  always_comb begin : output_processing
    // Collapse the status
    automatic fpnew_pkg::status_t temp_status;
    temp_status = '0;
    for (int i = 0; i < int'(NUM_LANES); i++)
      temp_status |= lane_status[i] & {5{lane_masks[i]}};
    status_o = temp_status;
  end

endmodule
// ----- 8< ----- FILE "./fpnew_rounding.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module fpnew_rounding #(
  parameter int unsigned AbsWidth=2 // Width of the abolute value, without sign bit
) (
  // Input value
  input logic [AbsWidth-1:0]   abs_value_i,             // absolute value without sign
  input logic                  sign_i,
  // Rounding information
  input logic [1:0]            round_sticky_bits_i,     // round and sticky bits {RS}
  input fpnew_pkg::roundmode_e rnd_mode_i,
  input logic                  effective_subtraction_i, // sign of inputs affects rounding of zeroes
  // Output value
  output logic [AbsWidth-1:0]  abs_rounded_o,           // absolute value without sign
  output logic                 sign_o,
  // Output classification
  output logic                 exact_zero_o             // output is an exact zero
);

  logic round_up; // Rounding decision

  // Take the rounding decision according to RISC-V spec
  // RoundMode | Mnemonic | Meaning
  // :--------:|:--------:|:-------
  //    000    |   RNE    | Round to Nearest, ties to Even
  //    001    |   RTZ    | Round towards Zero
  //    010    |   RDN    | Round Down (towards -\infty)
  //    011    |   RUP    | Round Up (towards \infty)
  //    100    |   RMM    | Round to Nearest, ties to Max Magnitude
  //    101    |   ROD    | Round towards odd (this mode is not define in RISC-V FP-SPEC)
  //  others   |          | *invalid*
  always_comb begin : rounding_decision
    unique case (rnd_mode_i)
      fpnew_pkg::RNE: // Decide accoring to round/sticky bits
        unique case (round_sticky_bits_i)
          2'b00,
          2'b01: round_up = 1'b0;           // < ulp/2 away, round down
          2'b10: round_up = abs_value_i[0]; // = ulp/2 away, round towards even result
          2'b11: round_up = 1'b1;           // > ulp/2 away, round up
          default: round_up = fpnew_pkg::DONT_CARE;
        endcase
      fpnew_pkg::RTZ: round_up = 1'b0; // always round down
      fpnew_pkg::RDN: round_up = (| round_sticky_bits_i) ? sign_i  : 1'b0; // to 0 if +, away if -
      fpnew_pkg::RUP: round_up = (| round_sticky_bits_i) ? ~sign_i : 1'b0; // to 0 if -, away if +
      fpnew_pkg::RMM: round_up = round_sticky_bits_i[1]; // round down if < ulp/2 away, else up
      fpnew_pkg::ROD: round_up = ~abs_value_i[0] & (| round_sticky_bits_i);
      default: round_up = fpnew_pkg::DONT_CARE; // propagate x
    endcase
  end

  // Perform the rounding, exponent change and overflow to inf happens automagically
  assign abs_rounded_o = abs_value_i + round_up;

  // True zero result is a zero result without dirty round/sticky bits
  assign exact_zero_o = (abs_value_i == '0) && (round_sticky_bits_i == '0);

  // In case of effective subtraction (thus signs of addition operands must have differed) and a
  // true zero result, the result sign is '-' in case of RDN and '+' for other modes.
  assign sign_o = (exact_zero_o && effective_subtraction_i)
                  ? (rnd_mode_i == fpnew_pkg::RDN)
                  : sign_i;

endmodule
// ----- 8< ----- FILE "./fpnew_top.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module fpnew_top #(
  // FPU configuration
  parameter fpnew_pkg::fpu_features_t       Features       = fpnew_pkg::RV64D_Xsflt,
  parameter fpnew_pkg::fpu_implementation_t Implementation = fpnew_pkg::DEFAULT_NOREGS,
  // PulpDivSqrt = 0 enables T-head-based DivSqrt unit. Supported only for FP32-only instances of Fpnew
  parameter logic                           PulpDivsqrt    = 1'b1,
  parameter type                            TagType        = logic,
  parameter int unsigned                    TrueSIMDClass  = 0,
  parameter int unsigned                    EnableSIMDMask = 0,
  // Do not change
  localparam int unsigned NumLanes     = fpnew_pkg::max_num_lanes(Features.Width, Features.FpFmtMask, Features.EnableVectors),
  localparam type         MaskType     = logic [NumLanes-1:0],
  localparam int unsigned WIDTH        = Features.Width,
  localparam int unsigned NUM_OPERANDS = 3
) (
  input logic                               clk_i,
  input logic                               rst_ni,
  // Input signals
  input logic [NUM_OPERANDS-1:0][WIDTH-1:0] operands_i,
  input fpnew_pkg::roundmode_e              rnd_mode_i,
  input fpnew_pkg::operation_e              op_i,
  input logic                               op_mod_i,
  input fpnew_pkg::fp_format_e              src_fmt_i,
  input fpnew_pkg::fp_format_e              dst_fmt_i,
  input fpnew_pkg::int_format_e             int_fmt_i,
  input logic                               vectorial_op_i,
  input TagType                             tag_i,
  input MaskType                            simd_mask_i,
  // Input Handshake
  input  logic                              in_valid_i,
  output logic                              in_ready_o,
  input  logic                              flush_i,
  // Output signals
  output logic [WIDTH-1:0]                  result_o,
  output fpnew_pkg::status_t                status_o,
  output TagType                            tag_o,
  // Output handshake
  output logic                              out_valid_o,
  input  logic                              out_ready_i,
  // Indication of valid data in flight
  output logic                              busy_o
);

  localparam int unsigned NUM_OPGROUPS = fpnew_pkg::NUM_OPGROUPS;
  localparam int unsigned NUM_FORMATS  = fpnew_pkg::NUM_FP_FORMATS;

  // ----------------
  // Type Definition
  // ----------------
  typedef struct packed {
    logic [WIDTH-1:0]   result;
    fpnew_pkg::status_t status;
    TagType             tag;
  } output_t;

  // Handshake signals for the blocks
  logic [NUM_OPGROUPS-1:0] opgrp_in_ready, opgrp_out_valid, opgrp_out_ready, opgrp_ext, opgrp_busy;
  output_t [NUM_OPGROUPS-1:0] opgrp_outputs;

  logic [NUM_FORMATS-1:0][NUM_OPERANDS-1:0] is_boxed;

  // -----------
  // Input Side
  // -----------
  assign in_ready_o = in_valid_i & opgrp_in_ready[fpnew_pkg::get_opgroup(op_i)];

  // NaN-boxing check
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_nanbox_check
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    // NaN boxing is only generated if it's enabled and needed
    if (Features.EnableNanBox && (FP_WIDTH < WIDTH)) begin : check
      for (genvar op = 0; op < int'(NUM_OPERANDS); op++) begin : operands
        assign is_boxed[fmt][op] = (!vectorial_op_i)
                                   ? operands_i[op][WIDTH-1:FP_WIDTH] == '1
                                   : 1'b1;
      end
    end else begin : no_check
      assign is_boxed[fmt] = '1;
    end
  end

  // Filter out the mask if not used
  MaskType simd_mask;
  assign simd_mask = simd_mask_i | ~{NumLanes{logic'(EnableSIMDMask)}};

  // -------------------------
  // Generate Operation Blocks
  // -------------------------
  for (genvar opgrp = 0; opgrp < int'(NUM_OPGROUPS); opgrp++) begin : gen_operation_groups
    localparam int unsigned NUM_OPS = fpnew_pkg::num_operands(fpnew_pkg::opgroup_e'(opgrp));

    logic in_valid;
    logic [NUM_FORMATS-1:0][NUM_OPS-1:0] input_boxed;

    assign in_valid = in_valid_i & (fpnew_pkg::get_opgroup(op_i) == fpnew_pkg::opgroup_e'(opgrp));

    // slice out input boxing
    always_comb begin : slice_inputs
      for (int unsigned fmt = 0; fmt < NUM_FORMATS; fmt++)
        input_boxed[fmt] = is_boxed[fmt][NUM_OPS-1:0];
    end

    fpnew_opgroup_block #(
      .OpGroup       ( fpnew_pkg::opgroup_e'(opgrp)    ),
      .Width         ( WIDTH                           ),
      .EnableVectors ( Features.EnableVectors          ),
      .PulpDivsqrt   ( PulpDivsqrt                     ),
      .FpFmtMask     ( Features.FpFmtMask              ),
      .IntFmtMask    ( Features.IntFmtMask             ),
      .FmtPipeRegs   ( Implementation.PipeRegs[opgrp]  ),
      .FmtUnitTypes  ( Implementation.UnitTypes[opgrp] ),
      .PipeConfig    ( Implementation.PipeConfig       ),
      .TagType       ( TagType                         ),
      .TrueSIMDClass ( TrueSIMDClass                   )
    ) i_opgroup_block (
      .clk_i,
      .rst_ni,
      .operands_i      ( operands_i[NUM_OPS-1:0] ),
      .is_boxed_i      ( input_boxed             ),
      .rnd_mode_i,
      .op_i,
      .op_mod_i,
      .src_fmt_i,
      .dst_fmt_i,
      .int_fmt_i,
      .vectorial_op_i,
      .tag_i,
      .simd_mask_i     ( simd_mask             ),
      .in_valid_i      ( in_valid              ),
      .in_ready_o      ( opgrp_in_ready[opgrp] ),
      .flush_i,
      .result_o        ( opgrp_outputs[opgrp].result ),
      .status_o        ( opgrp_outputs[opgrp].status ),
      .extension_bit_o ( opgrp_ext[opgrp]            ),
      .tag_o           ( opgrp_outputs[opgrp].tag    ),
      .out_valid_o     ( opgrp_out_valid[opgrp]      ),
      .out_ready_i     ( opgrp_out_ready[opgrp]      ),
      .busy_o          ( opgrp_busy[opgrp]           )
    );
  end

  // ------------------
  // Arbitrate Outputs
  // ------------------
  output_t arbiter_output;

  // Round-Robin arbiter to decide which result to use
  rr_arb_tree #(
    .NumIn     ( NUM_OPGROUPS ),
    .DataType  ( output_t     ),
    .AxiVldRdy ( 1'b1         )
  ) i_arbiter (
    .clk_i,
    .rst_ni,
    .flush_i,
    .rr_i   ( '0             ),
    .req_i  ( opgrp_out_valid ),
    .gnt_o  ( opgrp_out_ready ),
    .data_i ( opgrp_outputs   ),
    .gnt_i  ( out_ready_i     ),
    .req_o  ( out_valid_o     ),
    .data_o ( arbiter_output  ),
    .idx_o  ( /* unused */    )
  );

  // Unpack output
  assign result_o        = arbiter_output.result;
  assign status_o        = arbiter_output.status;
  assign tag_o           = arbiter_output.tag;

  assign busy_o = (| opgrp_busy);

endmodule
// ----- 8< ----- FILE "./FloatCoreWrapper.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
module FloatCoreWrapper(
  input logic clk_i,
  input logic rst_ni,
  input logic in_valid_i,
  output logic in_ready_o,
  input logic [32-1:0] operands_i_0,
  input logic [32-1:0] operands_i_1,
  input logic [32-1:0] operands_i_2,
  input logic[4-1:0] op_i,
  input logic op_mod_i,
  input logic[2:0] rnd_mode_i,
  input logic flush_i,
  output logic out_valid_o,
  input logic out_ready_i,
  output logic[32-1:0] result_o,
  output logic[4:0] status_o,
  output logic busy_o);

  logic [3-1:0][32-1:0] operands_i;
  assign operands_i[0] = operands_i_0;
  assign operands_i[1] = operands_i_1;
  assign operands_i[2] = operands_i_2;
  localparam fpnew_pkg::fpu_implementation_t impl = '{
  PipeRegs:   '{default: 'd3},
  UnitTypes:  '{'{default: fpnew_pkg::PARALLEL}, // ADDMUL
                '{default: fpnew_pkg::MERGED},   // DIVSQRT
                '{default: fpnew_pkg::PARALLEL}, // NONCOMP
                '{default: fpnew_pkg::MERGED}},  // CONV
  PipeConfig: fpnew_pkg::DISTRIBUTED
};
  fpnew_top#(
      .Features(fpnew_pkg::RV32F),
      .Implementation(impl),
      .PulpDivsqrt(0)
    ) core(
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .operands_i(operands_i),
    .rnd_mode_i(fpnew_pkg::roundmode_e'(rnd_mode_i)),
    .op_i(fpnew_pkg::operation_e'(op_i)),
    .op_mod_i(op_mod_i),
    .src_fmt_i(fpnew_pkg::FP32),
    .dst_fmt_i(fpnew_pkg::FP32),
    .int_fmt_i(fpnew_pkg::INT32),
    .vectorial_op_i(1'b0),
    .tag_i(1'b0),
    .simd_mask_i(1'b0),
    .in_valid_i(in_valid_i),
    .flush_i(flush_i),
    .out_ready_i(out_ready_i),

    .in_ready_o(in_ready_o),
    .result_o(result_o),
    .status_o(status_o),
    .tag_o(),
    .out_valid_o(out_valid_o),
    .busy_o(busy_o)
  );
endmodule
// ----- 8< ----- FILE "./Sram_12ffcp_128x128.v" ----- 8< -----

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

module Sram_12ffcp_128x128(
  input          clock,
  input          enable,
  input          write,
  input  [6:0]   addr,
  input  [127:0] wdata,
  input  [15:0] wmask,
  output [127:0] rdata
);

`ifndef USE_GENERIC
    wire [127:0] nwmask;
    genvar i;
    generate
      for (i = 0; i < 16; i++) begin
        assign nwmask[8*i +: 8] = {8{~wmask[i]}};
      end
    endgenerate
    TS1N12FFCLLSBLVTC128X128M4SWBSHO u_12ffcp_sram
    (
      // Mode Control
      .BIST(1'b0),          // Built-In Self-Test (active high)
      // Normal Mode Input
      .SLP(1'b0),           // Sleep
      .DSLP(1'b0),          // Deep Sleep
      .SD(1'b0),            // Shut Down
      .CLK(clock),          // Clock
      .CEB(~enable),        // Chip Enable Bar (active low en)
      .WEB(~write),         // Write Enable Bar (active low WE)
      .A(addr),             // Address                               (input [6:0] DM)
      .D(wdata),            // Data                                  (input [127:0] DM)
      .BWEB(nwmask),        // Bit Write Enable Bar (active low BW)  (input [127:0])


      // BIST Mode Input
      .CEBM(1'b0),          // Chip Enable Bar for BIST Mode
      .WEBM(1'b0),          // Write Enable Bar for BIST Mode
      .AM(6'b0),            // Address for BIST Mode               (input [6:0])
      .DM(128'b0),          // Data Input for BIST Mode            (input [127:0] DM)
      .BWEBM({128{1'b1}}),  // Bit Write Enable Bar for BIST Mode  (input [127:0] DM)

      // Data Output
      .Q(rdata),            // Data Output                          (output [127:0])
      .PUDELAY(),           // Power-Up Delay - Connect for tuning timing in late stage design

      // Test Mode
      .RTSEL(2'b0),         // Read Test Select                (input [1:0])
      .WTSEL(2'b0)          // Write Test Select               (input [1:0])
     );

`else
  reg [127:0] mem [0:127];
  reg [6:0] raddr;

  assign rdata = mem[raddr];

`ifndef SYNTHESIS
  task randomMemoryAll;
  for (int i = 0; i < 128; i++) begin
    for (int j = 0; j < 128; j++) begin
      mem[i][j] = $random;
    end
  end
  endtask

  initial begin
    randomMemoryAll;
  end
`endif

  always @(posedge clock) begin
    for (int i = 0; i < 16; i++) begin
      if (enable & write & wmask[i]) begin
        mem[addr][i*8 +: 8] <= wdata[8*i +: 8];
      end
    end

    if (enable & ~write) begin
      raddr <= addr;
    end
  end
`endif // FFCP12_SRAM

endmodule
// ----- 8< ----- FILE "./Sram_512x128.v" ----- 8< -----

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

module Sram_512x128(
  input          clock,
  input          enable,
  input          write,
  input  [8:0]   addr,
  input  [127:0] wdata,
  input  [15:0] wmask,
  output [127:0] rdata
);

///////////////////////////
///// SRAM Selection //////
///////////////////////////
`ifdef USE_TSMC12FFC
///////////////////////////
///// TSMC12FFC SRAM //////
///////////////////////////
    wire [127:0] nwmask;
    genvar i;
    generate
      for (i = 0; i < 16; i++) begin
        assign nwmask[8*i +: 8] = {8{~wmask[i]}};
      end
    endgenerate
    TS1N12FFCLLSBLVTD512X128M4SWBSHO u_12ffcp_sram
    (
      // Mode Control
      .BIST(1'b0),          // Built-In Self-Test (active high)
      // Normal Mode Input
      .SLP(1'b0),           // Sleep
      .DSLP(1'b0),          // Deep Sleep
      .SD(1'b0),            // Shut Down
      .CLK(clock),          // Clock
      .CEB(~enable),        // Chip Enable Bar (active low en)
      .WEB(~write),         // Write Enable Bar (active low WE)
      .A(addr),             // Address                               (input [8:0] DM)
      .D(wdata),            // Data                                  (input [127:0] DM)
      .BWEB(nwmask),        // Bit Write Enable Bar (active low BW)  (input [127:0])


      // BIST Mode Input
      .CEBM(1'b0),          // Chip Enable Bar for BIST Mode
      .WEBM(1'b0),          // Write Enable Bar for BIST Mode
      .AM(9'b0),            // Address for BIST Mode               (input [8:0])
      .DM(128'b0),          // Data Input for BIST Mode            (input [127:0] DM)
      .BWEBM({128{1'b1}}),  // Bit Write Enable Bar for BIST Mode  (input [127:0] DM)

      // Data Output
      .Q(rdata),            // Data Output                          (output [127:0])
      .PUDELAY(),           // Power-Up Delay - Connect for tuning timing in late stage design

      // Test Mode
`ifndef SIMULATION
      .RTSEL(2'b0),         // Read Test Select                (input [1:0])
      .WTSEL(2'b0)          // Write Test Select               (input [1:0])
`else
      .RTSEL(2'b1),         // Read Test Select                (input [1:0])
      .WTSEL(2'b0)          // Write Test Select               (input [1:0])
`endif
     );
`elsif USE_GF22
///////////////////////////
//////// GF22 SRAM ////////
///////////////////////////
    wire [127:0] nwmask;
    genvar i;
    generate
      for (i = 0; i < 16; i++) begin
        assign nwmask[8*i +: 8] = {8{wmask[i]}};
      end
    endgenerate

    sasdulssd8LOW1p512x128m4b1w0c0p0d0l0rm3sdrw01 u_gf22_sram (
      .Q(rdata),
      .ADR(addr),
      .D(wdata),
      .WEM(nwmask),
      .WE(write),
      .ME(enable),
      .CLK(clock),
      .TEST1(1'b0),
      .TEST_RNM(1'b0),
      .RME(1'b0),
      .RM(4'b0),
      .WA(2'b0),
      .WPULSE(3'b0),
      .LS(1'b0),
      .BC0(1'b0),
      .BC1(1'b0),
      .BC2(1'b0)
    );
`else
///////////////////////////
////// Generic SRAM ///////
///////////////////////////
  reg [127:0] mem [0:511];
  reg [8:0] raddr;

  assign rdata = mem[raddr];

`ifndef SYNTHESIS
  task randomMemoryAll;
  for (int i = 0; i < 128; i++) begin
    for (int j = 0; j < 512; j++) begin
      mem[i][j] = $random;
    end
  end
  endtask

  initial begin
    randomMemoryAll;
  end
`endif

  always @(posedge clock) begin
    for (int i = 0; i < 16; i++) begin
      if (enable & write & wmask[i]) begin
        mem[addr][i*8 +: 8] <= wdata[8*i +: 8];
      end
    end

    if (enable & ~write) begin
      raddr <= addr;
    end
  end
`endif

endmodule
